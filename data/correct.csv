,bug_id,bug report text,bug report description,generated patch id,patch text,label
<<<<<<< HEAD
0,Math,ListPopulation Iterator allows remove chromosomes population,Calling iterator method ListPopulation returns iterator protected modifiable list returning iterator wrap unmodifiable list,Calling iterator method ListPopulation returns iterator protected modifiable list returning iterator wrap unmodifiable list,Calling iterator method ListPopulation returns iterator protected modifiable list returning iterator wrap unmodifiable list,1
0,Math,BisectionSolver solve final UnivariateRealFunction f double min double max double initial throws NullPointerException,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl 0 0 1 0 0 5 NullPointerException thrown,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl       NullPointerException thrown,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl NullPointerException thrown,1
0,Math,Complex ZERO reciprocal returns NaN return INF,Complex ZERO reciprocal returns NaN return INF Class org apache commons math3 complex Complex Method reciprocal version Id Complex java 1416643 2012 12 03 19 37 14Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java       Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java Z tn,1
0,Math,Fix deprecate isSupportXxxInclusive RealDistribution interface,conclusion 1 never implemented deprecate properties RealDistribution interface since removal wait 4 0 agree precise definition fix code match mean time definition propose isSupportXxxInclusive means density function applied upper lower bound support returned getSupportXxxBound finite e infinite NaN value returned 1 http markmail org message dxuxh7eybl7xejde,conclusion  never implemented deprecate properties RealDistribution interface since removal wait   agree precise definition fix code match mean time definition propose isSupportXxxInclusive means density function applied upper lower bound support returned getSupportXxxBound finite e infinite NaN value returned  http markmail org message dxuxheyblxejde,conclusion never implemented deprecate properties RealDistribution interface since removal wait agree precise definition fix code match mean time definition propose isSupportXxxInclusive means density function applied upper lower bound support returned getSupportXxxBound finite e infinite NaN value returned http markmail org message dxuxheyblxejde,1
0,Time,Inconsistent interpretation ambiguous time DST,inconsistency appears timezone Europe London three DateTime objects represent moment time even ambiguous always returns earlier instant summer time overlap,inconsistency appears timezone Europe London three DateTime objects represent moment time even ambiguous always returns earlier instant summer time overlap,inconsistency appears timezone Europe London three DateTime objects represent moment time even ambiguous always returns earlier instant summer time overlap,1
0,Lang,NullPointerException isAvailableLocale Locale,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,1
0,Closure,Closure removes needed code,None,None,None,1
0,Closure,Use public tag prevent compression symbol names,None,None,None,1
0,Closure,statement,None,None,None,1
0,Closure,Cannot exclude globalThis checks command line,None,None,None,1
0,Closure,bug implicit namespaces across modules,None,None,None,1
0,Closure,enum type correctly,None,None,None,1
0,Closure,Typos externs html5 js,None,None,None,1
0,Closure,Optimisation convert array join array join,None,None,None,1
0,Closure,Cryptic error message invalid type function annotation,None,None,None,1
0,Closure,Compiler gives false error respect unreachable code,None,None,None,1
0,Closure,compiler crashes goog provide used non string,None,None,None,1
0,Closure,Preserve preserve whitespace start line,None,None,None,1
0,Closure,assignment object conditional causes type error function w record type return type,None,None,None,1
0,Closure,compiler assumes arguments shadowed,None,None,None,1
0,Closure,Compiler warn error instance methods operated,None,None,None,1
0,Closure,Last warning error output truncated,None,None,None,1
0,Closure,Array Join Munged Incorrectly,None,None,None,1
0,Closure,0 0 becomes 0 even whitespace mode,None,None,None,1
0,Closure,Online CC bug report java error,None,None,None,1
0,Closure,Exception parsing erroneous jsdoc return code foo bar baz,None,None,None,1
0,Closure,Advanced compilations renames function deletes leaving reference renamed non existent function,None,None,None,1
0,Closure,closure compiler define annotation allow line split 80 characters,None,None,None,1
0,Closure,void function wrongly identified side effects,None,None,None,1
0,Closure,StackOverflowError exception running closure compiler javascript attached,None,None,None,1
0,Closure,weird object literal invalid property error unrelated object prototype,None,None,None,1
0,Closure,String conversion optimization incorrect,None,None,None,1
0,Closure,Dependency sorting closurePass set false longer works,None,None,None,1
0,Closure,Error trying build try catch block AST,None,None,None,1
0,Closure,Compiler fails find amd module subdirectory,None,None,None,1
0,Closure,Record type invalid property reported function annotation,None,None,None,1
0,Closure,Bad type inference goog isFunction friends,None,None,None,1
0,Closure,closure compiler screws perfectly valid isFunction implementation,None,None,None,1
0,Closure,JSCompiler recursively resolve typedefs,None,None,None,1
0,Closure,Casting function calling produces bad code breaks plugin code,None,None,None,1
0,Closure,Simple Whitespace compression removing keyword var x arr loop,None,None,None,1
0,Closure,Compiler removes function properties,None,None,None,1
0,Closure,Erroneous optimization ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,Assignment removed used expression result Array push,None,None,None,1
0,Closure,goog isArray hint compiler,None,None,None,1
0,Closure,Codepoint U 007f appears raw output,None,None,None,1
0,Closure,Prototype method incorrectly removed,None,None,None,1
0,Closure,IE8 error Object support action,None,None,None,1
0,Closure,Break finally block optimized properly,None,None,None,1
0,Closure,Unexpected expression nodeDELPROP 1,None,None,None,1
0,Closure,Obvious optimizations works inline,None,None,None,1
0,Closure,Overzealous optimization confuses variables,None,None,None,1
0,Closure,better type checking,None,None,None,1
0,Closure,constant functions inlined aggressively enough,None,None,None,1
0,Closure,const dumps type cast information,None,None,None,1
0,Closure,function arguments optimized away,None,None,None,1
0,Closure,Wrong code generated mixing types ternary operator,None,None,None,1
0,Closure,Type refining raises IllegalArgumentException,None,None,None,1
0,Closure,ProcessCommonJSModules module exports failures checkTypes enabled,None,None,None,1
0,Closure,Obfuscated code triggers TypeError Firefox,None,None,None,1
0,Closure,Classify non rightmost expressions problematic,None,None,None,1
0,Closure,closure compiled swfobject error,None,None,None,1
0,Closure,unnamed function statement statements generate parse error,None,None,None,1
0,Closure,Overzealous optimization confuses variables,None,None,None,1
0,Closure,catch e yields JSC UNDEFINED NAME warning e used catch advanced mode,None,None,None,1
0,Closure,side effects analysis incorrectly removing function calls side effects,None,None,None,1
0,Closure,Internal Compiler Error Bullet,None,None,None,1
0,Closure,Break finally block optimized properly,None,None,None,1
0,Closure,alert,None,None,None,1
0,Closure,Allow private top level functions goog scope,None,None,None,1
0,Closure,lends work unless class defined beforehand,None,None,None,1
0,Closure,compiler quotes 0 keys object literals,None,None,None,1
0,Closure,Incorrect assignment removal expression simple mode,None,None,None,1
0,Closure,Wrong type name reported missing property error,None,None,None,1
0,Closure,Identifier minus negative number needs space,None,None,None,1
0,Closure,goog addSingletonGetter prevents unused class removal,None,None,None,1
0,Closure,Add support manage closure dependencies closure dependencies compilation level WHITESPACE,None,None,None,1
0,Closure,unicode characters property names result invalid output,None,None,None,1
0,Closure,support lends annotation,None,None,None,1
0,Closure,String escaping mishandles null byte,None,None,None,1
0,Closure,Column indicating caret sometimes error output,None,None,None,1
0,Closure,Missing type checks var args notation,None,None,None,1
0,Closure,Constructor types return unknown fail parse,None,None,None,1
0,Closure,assignment issues dangerous use global object warning,None,None,None,1
0,Closure,Prototype methods used constructor case prototype explicitly defined,None,None,None,1
0,Closure,Variable names prefixed MSG cause error advanced optimizations,None,None,None,1
0,Closure,bad variable inlining closure,None,None,None,1
0,Closure,compiler 20110811 crashes index 1 must less size 1,None,None,None,1
0,Closure,Combining temporary strings optimized advanced build,None,None,None,1
0,Closure,incomplete function definition crashes compiler ideMode enabled,None,None,None,1
0,Closure,externExport typedef generate invalid externs,None,None,None,1
0,Closure,Exception thrown com google javascript jscomp CollapseProperties addStubsForUndeclaredProperties,None,None,None,1
0,Closure,Prototypes declared quotes produce JSC USED GLOBAL warning,None,None,None,1
0,Closure,Converts string properties numbers literal object definitions,None,None,None,1
0,Closure,process closure primitives set false,None,None,None,1
0,Closure,Exception emitting code containing getters,None,None,None,1
0,Closure,Unsigned Shift Right bug operating negative numbers,None,None,None,1
0,Closure,precondition crash goog scope local aliased type declaration,None,None,None,1
0,Closure,arguments moved another scope,None,None,None,1
0,Closure,language ECMASCRIPT5 STRICT results 1 use strict per input file,None,None,None,1
0,Closure,emits warning used typedef,None,None,None,1
0,Closure,ClassCastException TypeCheck pass,None,None,None,1
0,Closure,RuntimeException compiling extern prototype,None,None,None,1
0,Closure,Template types methods incorrectly trigger inference template class template type unknown,None,None,None,1
0,Closure,ADVANCED mode Compiler fails warn overridden methods different signatures,None,None,None,1
0,Closure,Erroneous optimization ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,Cannot see version version,None,None,None,1
0,Closure,\0 \x00 \u0000 translated null character,None,None,None,1
0,Closure,Generates code invalid left hand assignment,None,None,None,1
0,Closure,Type checking error replacing function stub calling,None,None,None,1
0,Closure,unexpected typed coverage less 100,None,None,None,1
0,Closure,Invalid left hand side assignment detected,None,None,None,1
0,Closure,Different output RestAPI command line jar,None,None,None,1
0,Closure,goog scope properly check declared functions,None,None,None,1
0,Closure,tryFoldArrayAccess check side effects,None,None,None,1
0,Closure,Converting interface type constructor implements causes stack overflow,None,None,None,1
0,Closure,Switched order delete key key statements changes semantic,None,None,None,1
0,Closure,optimization fails variable catch clause,None,None,None,1
0,Closure,Try catch blocks incorporate code inside original blocks,None,None,None,1
0,Closure,Reproduceable crash switch statement,None,None,None,1
0,Closure,warnings private prop redeclared subclass,None,None,None,1
0,Closure,IllegalStateException com google javascript rhino jstype FunctionType getInstanceType,None,None,None,1
0,Closure,Assignments within conditions sometimes incorrectly removed,None,None,None,1
0,Closure,indexOf fails produce missing property warning,None,None,None,1
0,Closure,Incorrect output function assigned variable function contains variable name,None,None,None,1
0,Closure,Inconsistent handling non JSDoc comments,None,None,None,1
0,Closure,smartNameRemoval causing compiler crash,None,None,None,1
0,Closure,Crash web closure compiler,None,None,None,1
0,Closure,Original source line numbers one based source maps,None,None,None,1
0,Closure,Bug require calls processing,None,None,None,1
0,Closure,division zero wrongly throws JSC DIVIDE 0 ERROR,None,None,None,1
0,Closure,combining interface multiple extends crash compiler,None,None,None,1
0,Closure,true false always replaced 0 1,None,None,None,1
0,Closure,Compiler ignores delete statements break functionality,None,None,None,1
0,Closure,bogus missing return warning,None,None,None,1
0,Closure,Classify non rightmost expressions problematic,None,None,None,1
0,Closure,anonymous object type inference behavior different calling constructors,None,None,None,1
0,Chart,Error TimeSeries createCopy method,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart 1 0 7,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart   ,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path1 GeneralPath path2 thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,1
0,Chart,Bug propgated v1 0 5 present,method getRowCount class org jfree data category DefaultIntervalCategoryDataset says Returns number series dataset possibly zero implementation v1 0 5 longer checks null condition would return zero seriesKeys v1 0 4 previous throws Null Pointer seriesKeys never got initialized getRowCount method called,method getRowCount class org jfree data category DefaultIntervalCategoryDataset says Returns number series dataset possibly zero implementation v   longer checks null condition would return zero seriesKeys v   previous throws Null Pointer seriesKeys never got initialized getRowCount method called,method getRowCount class org jfree data category DefaultIntervalCategoryDataset says Returns number series dataset possibly zero implementation v longer checks null condition would return zero seriesKeys v previous throws Null Pointer seriesKeys never got initialized getRowCount method called,1
0,Chart,cloning TimeSeries,minor bug clone TimeSeries items get IllegalArgumentException Requires start end think user responsible checking whether TimeSeries items,minor bug clone TimeSeries items get IllegalArgumentException Requires start end think user responsible checking whether TimeSeries items,minor bug clone TimeSeries items get IllegalArgumentException Requires start end think user responsible checking whether TimeSeries items,1
0,Chart,Potential NPE AbstractCategoryItemRender getLegendItems,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,1
0,Chart,Fix MultiplePiePlot,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,1
0,Chart,Bugs DatasetUtilities iterateRangeBounds methods,None,None,None,1
0,Chart,XYSeries addOrUpdate add duplicates allowed,found bug jfreechart 1 0 9 code org jfree data xy XYSeries change time ago introduced notion allowing duplicate X values XYSeries data method addOrUpdate Number x Number never modified support therefore duplicate data overwriting existing data,found bug jfreechart    code org jfree data xy XYSeries change time ago introduced notion allowing duplicate X values XYSeries data method addOrUpdate Number x Number never modified support therefore duplicate data overwriting existing data,found bug jfreechart code org jfree data xy XYSeries change time ago introduced notion allowing duplicate X values XYSeries data method addOrUpdate Number x Number never modified support therefore duplicate data overwriting existing data,1
0,Math,Dangerous code PoissonDistributionImpl,following excerpt class PoissonDistributionImpl PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z super setNormal z setMean p 1 Overridable methods called within constructor 2 reference z stored modified within class encountered problem 1 several classes working issue 348 cases order remove potential problems copied pasted body setter methods inside constructor think elegant solution would remove setters altogether e make classes immutable Problem 2 also create unexpected behaviour really necessary pass NormalDistribution object always created within class,following excerpt class PoissonDistributionImpl PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z super setNormal z setMean p  Overridable methods called within constructor  reference z stored modified within class encountered problem  several classes working issue  cases order remove potential problems copied pasted body setter methods inside constructor think elegant solution would remove setters altogether e make classes immutable Problem  also create unexpected behaviour really necessary pass NormalDistribution object always created within class,following excerpt class PoissonDistributionImpl PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z super setNormal z setMean p Overridable methods called within constructor reference z stored modified within class encountered problem several classes working issue cases order remove potential problems copied pasted body setter methods inside constructor think elegant solution would remove setters altogether e make classes immutable Problem also create unexpected behaviour really necessary pass NormalDistribution object always created within class,1
0,Math,denominatorDegreeOfFreedom FDistribution leads IllegalArgumentsException UnivariateRealSolverUtils bracket,using FDistributionImpl commons math project statistical calculations namely receiving upper lower boundaries confidence interval Everything working fine results matching reference calculations However FDistribution behaves strange denominatorDegreeOfFreedom 2 used alpha value 0 95 results IllegalArgumentsException stating Invalid endpoint parameters lowerBound 0 0 initial Infinity upperBound 1 7976931348623157E308 coming org apache commons math analysis UnivariateRealSolverUtils bracket problem initial parameter function wich POSITIVE INFINITY therefore within boundaries already pinned problem FDistributions getInitialDomain method wich goes like return getDenominatorDegreesOfFreedom getDenominatorDegreesOfFreedom 2 0 Obviously case denominatorDegreesOfFreedom 2 must lead division zero resulting POSTIVE INFINITY result operation directly passed UnivariateRealSolverUtils bracket method second argument,using FDistributionImpl commons math project statistical calculations namely receiving upper lower boundaries confidence interval Everything working fine results matching reference calculations However FDistribution behaves strange denominatorDegreeOfFreedom  used alpha value   results IllegalArgumentsException stating Invalid endpoint parameters lowerBound   initial Infinity upperBound  E coming org apache commons math analysis UnivariateRealSolverUtils bracket problem initial parameter function wich POSITIVE INFINITY therefore within boundaries already pinned problem FDistributions getInitialDomain method wich goes like return getDenominatorDegreesOfFreedom getDenominatorDegreesOfFreedom   Obviously case denominatorDegreesOfFreedom  must lead division zero resulting POSTIVE INFINITY result operation directly passed UnivariateRealSolverUtils bracket method second argument,using FDistributionImpl commons math project statistical calculations namely receiving upper lower boundaries confidence interval Everything working fine results matching reference calculations However FDistribution behaves strange denominatorDegreeOfFreedom used alpha value results IllegalArgumentsException stating Invalid endpoint parameters lowerBound initial Infinity upperBound E coming org apache commons math analysis UnivariateRealSolverUtils bracket problem initial parameter function wich POSITIVE INFINITY therefore within boundaries already pinned problem FDistributions getInitialDomain method wich goes like return getDenominatorDegreesOfFreedom getDenominatorDegreesOfFreedom Obviously case denominatorDegreesOfFreedom must lead division zero resulting POSTIVE INFINITY result operation directly passed UnivariateRealSolverUtils bracket method second argument,1
0,Math,FastMath max 50 0f 50 0f 50 0f 50 0f,FastMath max 50 0f 50 0f 50 0f 50 0f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,FastMath max  f  f  f  f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,FastMath max f f f f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,1
0,Math,MathUtils binomialCoefficient n k fails large results,Probably due rounding errors MathUtils binomialCoefficient n k fails results near Long MAX VALUE existence failures demonstrated testing recursive property assertEquals MathUtils binomialCoefficient 65 32 MathUtils binomialCoefficient 65 33 MathUtils binomialCoefficient 66 33 directly using externally calculated hopefully correct expected value assertEquals 7219428434016265740L MathUtils binomialCoefficient 66 33 suggest nonrecursive test implementation along lines MathUtilsTest java Exact implementation using BigInteger explicit formula n k k 1 n 1 n k public static long binomialCoefficient int n int k k 0 || k n return 1 BigInteger result BigInteger ONE int k 1 n result result multiply BigInteger valueOf int 1 n k result result divide BigInteger valueOf result compareTo BigInteger valueOf Long MAX VALUE 0 throw new ArithmeticException Binomial coefficient overflow n k return result longValue would allow test expected values directly assertEquals binomialCoefficient 66 33 MathUtils binomialCoefficient 66 33,Probably due rounding errors MathUtils binomialCoefficient n k fails results near Long MAX VALUE existence failures demonstrated testing recursive property assertEquals MathUtils binomialCoefficient   MathUtils binomialCoefficient   MathUtils binomialCoefficient   directly using externally calculated hopefully correct expected value assertEquals L MathUtils binomialCoefficient   suggest nonrecursive test implementation along lines MathUtilsTest java Exact implementation using BigInteger explicit formula n k k  n  n k public static long binomialCoefficient int n int k k  || k n return  BigInteger result BigInteger ONE int k  n result result multiply BigInteger valueOf int  n k result result divide BigInteger valueOf result compareTo BigInteger valueOf Long MAX VALUE  throw new ArithmeticException Binomial coefficient overflow n k return result longValue would allow test expected values directly assertEquals binomialCoefficient   MathUtils binomialCoefficient  ,Probably due rounding errors MathUtils binomialCoefficient n k fails results near Long MAX VALUE existence failures demonstrated testing recursive property assertEquals MathUtils binomialCoefficient MathUtils binomialCoefficient MathUtils binomialCoefficient directly using externally calculated hopefully correct expected value assertEquals L MathUtils binomialCoefficient suggest nonrecursive test implementation along lines MathUtilsTest java Exact implementation using BigInteger explicit formula n k k n n k public static long binomialCoefficient int n int k k || k n return BigInteger result BigInteger ONE int k n result result multiply BigInteger valueOf int n k result result divide BigInteger valueOf result compareTo BigInteger valueOf Long MAX VALUE throw new ArithmeticException Binomial coefficient overflow n k return result longValue would allow test expected values directly assertEquals binomialCoefficient MathUtils binomialCoefficient,1
0,Math,Bugs BrentOptimizer,apologize provided buggy implementation Brent optimization algorithm class BrentOptimizer package optimization univariate unit tests show something wrong although changes xml file discovered time Luc noticed something weird implementation behaviour Comparing implementation Python could figure fixes modify BrentOptimizer add test also propose change name unit test class BrentMinimizerTest BrentOptimizerTest,apologize provided buggy implementation Brent optimization algorithm class BrentOptimizer package optimization univariate unit tests show something wrong although changes xml file discovered time Luc noticed something weird implementation behaviour Comparing implementation Python could figure fixes modify BrentOptimizer add test also propose change name unit test class BrentMinimizerTest BrentOptimizerTest,apologize provided buggy implementation Brent optimization algorithm class BrentOptimizer package optimization univariate unit tests show something wrong although changes xml file discovered time Luc noticed something weird implementation behaviour Comparing implementation Python could figure fixes modify BrentOptimizer add test also propose change name unit test class BrentMinimizerTest BrentOptimizerTest,1
0,Math,Special functions accurate,Gamma Beta functions return values double precision default epsilon set 10e 9 think default set highest possible accuracy expect returned double precision routine Note erf function already uses call Gamma regularizedGammaP epsilon 1 0e 15,Gamma Beta functions return values double precision default epsilon set e  think default set highest possible accuracy expect returned double precision routine Note erf function already uses call Gamma regularizedGammaP epsilon  e ,Gamma Beta functions return values double precision default epsilon set e think default set highest possible accuracy expect returned double precision routine Note erf function already uses call Gamma regularizedGammaP epsilon e,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Math,LevenbergMarquardtOptimizer ignores VectorialConvergenceChecker parameter passed,LevenbergMarquardtOptimizer ignores VectorialConvergenceChecker parameter passed makes hard specify custom stopping criteria optimizer,LevenbergMarquardtOptimizer ignores VectorialConvergenceChecker parameter passed makes hard specify custom stopping criteria optimizer,LevenbergMarquardtOptimizer ignores VectorialConvergenceChecker parameter passed makes hard specify custom stopping criteria optimizer,1
0,Math,ConvergenceException normal CDF,NormalDistributionImpl cumulativeProbability double x throws ConvergenceException x deviates much mean example x 100 mean 0 sd 1 course value CDF hard evaluate cases effectively either zero one,NormalDistributionImpl cumulativeProbability double x throws ConvergenceException x deviates much mean example x  mean  sd  course value CDF hard evaluate cases effectively either zero one,NormalDistributionImpl cumulativeProbability double x throws ConvergenceException x deviates much mean example x mean sd course value CDF hard evaluate cases effectively either zero one,1
0,Math,Truncation issue KMeansPlusPlusClusterer,loop inside KMeansPlusPlusClusterer chooseInitialClusters defines variable int sum 0 variable type double rather int Using int causes method truncate distances points square roots integers especially bad distances points typically less 1 aside version 2 2 bug manifested making clusterer return empty clusters wonder EmptyClusterStrategy would still necessary bug fixed,loop inside KMeansPlusPlusClusterer chooseInitialClusters defines variable int sum  variable type double rather int Using int causes method truncate distances points square roots integers especially bad distances points typically less  aside version   bug manifested making clusterer return empty clusters wonder EmptyClusterStrategy would still necessary bug fixed,loop inside KMeansPlusPlusClusterer chooseInitialClusters defines variable int sum variable type double rather int Using int causes method truncate distances points square roots integers especially bad distances points typically less aside version bug manifested making clusterer return empty clusters wonder EmptyClusterStrategy would still necessary bug fixed,1
0,Math,BSPTree class recovery Euclidean 3D BRep,New work Thanks efforts code create BSPTree BoundaryRep Brep test Brep cube represented float array containing 8 3D points x z order array indices 12 triplets 12 faces cube construct BSPMesh shown code construct PolyhedronsSet problems extracting faces BSPTree reconstruct BRep attached code BSPMesh2 java shows small change 1 vertex positions causes corrects problem ideas,New work Thanks efforts code create BSPTree BoundaryRep Brep test Brep cube represented float array containing  D points x z order array indices  triplets  faces cube construct BSPMesh shown code construct PolyhedronsSet problems extracting faces BSPTree reconstruct BRep attached code BSPMesh java shows small change  vertex positions causes corrects problem ideas,New work Thanks efforts code create BSPTree BoundaryRep Brep test Brep cube represented float array containing points x z order array indices triplets faces cube construct BSPMesh shown code construct PolyhedronsSet problems extracting faces BSPTree reconstruct BRep attached code BSPMesh java shows small change vertex positions causes corrects problem ideas,1
0,Math,Need range checks elitismRate ElitisticListPopulation constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,1
0,Math,chiSquare double expected long observed returning incorrect test statistic,ChiSquareTestImpl returning incorrect chi squared value implicit assumption public double chiSquare double expected long observed sum expected observed equal code int 0 observed length dev double observed expected sumSq dev dev expected calculation correct sum observed sum expected equal one must rescale expected value sum observed sum expected Ironically example unit test ChiSquareTestTest highlights error long observed1 500 623 72 70 31 double expected1 485 541 82 61 37 assertEquals chi square test statistic 16 4131070362 testStatistic chiSquare expected1 observed1 1E 10 assertEquals chi square p value 0 002512096 testStatistic chiSquareTest expected1 observed1 1E 9 16 413 correct expected values make sense 521 19403 581 37313 88 11940 65 55224 39 76119 sum expected equals 1296 sum observed R code r project org proves o1 1 500 623 72 70 31 e1 1 485 541 82 61 37 chisq test o1 p e1 rescale p TRUE Chi squared test given probabilities data o1 X squared 9 0233 df 4 p value 0 06052 chisq test o1 p e1 rescale p TRUE observed 1 500 623 72 70 31 chisq test o1 p e1 rescale p TRUE expected 1 521 19403 581 37313 88 11940 65 55224 39 76119,ChiSquareTestImpl returning incorrect chi squared value implicit assumption public double chiSquare double expected long observed sum expected observed equal code int  observed length dev double observed expected sumSq dev dev expected calculation correct sum observed sum expected equal one must rescale expected value sum observed sum expected Ironically example unit test ChiSquareTestTest highlights error long observed      double expected      assertEquals chi square test statistic   testStatistic chiSquare expected observed E  assertEquals chi square p value   testStatistic chiSquareTest expected observed E    correct expected values make sense           sum expected equals  sum observed R code r project org proves o       e       chisq test o p e rescale p TRUE Chi squared test given probabilities data o X squared   df  p value   chisq test o p e rescale p TRUE observed       chisq test o p e rescale p TRUE expected           ,ChiSquareTestImpl returning incorrect chi squared value implicit assumption public double chiSquare double expected long observed sum expected observed equal code int observed length dev double observed expected sumSq dev dev expected calculation correct sum observed sum expected equal one must rescale expected value sum observed sum expected Ironically example unit test ChiSquareTestTest highlights error long observed double expected assertEquals chi square test statistic testStatistic chiSquare expected observed E assertEquals chi square p value testStatistic chiSquareTest expected observed E correct expected values make sense sum expected equals sum observed R code r project org proves e chisq test p e rescale p TRUE Chi squared test given probabilities data X squared df p value chisq test p e rescale p TRUE observed chisq test p e rescale p TRUE expected,1
0,Math,PearsonsCorrelation getCorrelationPValues precision limited machine epsilon,Similar issue described MATH 201 using PearsonsCorrelation getCorrelationPValues many treatments results p values continuous 2 2e 16 drop 0 MATH 201 problem described essence p value returned TTestImpl tTest 1 0 cumulativeProbability cumulativeProbabily large ish statistics cumulativeProbabilty get quite small cumulativeProbabilty get close 1 0 cumulativeProbability less machine epsilon get p values equal zero 1 0 1 0 0 0 0 0 solution MATH 201 modify p value calculation p 2 0 cumulativeProbability problem similar PearsonsCorrelation getCorrelationPValues p 2 1 tDistribution cumulativeProbability Directly calculating p value using identical code PearsonsCorrelation getCorrelationPValues following change seems solve problem p 2 tDistribution cumulativeProbability,Similar issue described MATH  using PearsonsCorrelation getCorrelationPValues many treatments results p values continuous  e  drop  MATH  problem described essence p value returned TTestImpl tTest   cumulativeProbability cumulativeProbabily large ish statistics cumulativeProbabilty get quite small cumulativeProbabilty get close   cumulativeProbability less machine epsilon get p values equal zero         solution MATH  modify p value calculation p   cumulativeProbability problem similar PearsonsCorrelation getCorrelationPValues p   tDistribution cumulativeProbability Directly calculating p value using identical code PearsonsCorrelation getCorrelationPValues following change seems solve problem p  tDistribution cumulativeProbability,Similar issue described MATH using PearsonsCorrelation getCorrelationPValues many treatments results p values continuous e drop MATH problem described essence p value returned TTestImpl tTest cumulativeProbability cumulativeProbabily large ish statistics cumulativeProbabilty get quite small cumulativeProbabilty get close cumulativeProbability less machine epsilon get p values equal zero solution MATH modify p value calculation p cumulativeProbability problem similar PearsonsCorrelation getCorrelationPValues p tDistribution cumulativeProbability Directly calculating p value using identical code PearsonsCorrelation getCorrelationPValues following change seems solve problem p tDistribution cumulativeProbability,1
0,Math,MultidimensionalCounter getCounts int returns wrong array indices,MultidimensionalCounter counter new MultidimensionalCounter 2 4 Integer counter int x counter getCounts System println Arrays toString Output 0 0 0 1 0 1 2 0 2 3 0 2 0 3 4 1 0 5 1 1 6 1 2 7 1 2 1 3,MultidimensionalCounter counter new MultidimensionalCounter   Integer counter int x counter getCounts System println Arrays toString Output                            ,MultidimensionalCounter counter new MultidimensionalCounter Integer counter int x counter getCounts System println Arrays toString Output,1
0,Math,math SimpleRegression getSumSquaredErrors,getSumSquaredErrors returns value See test public void testSimpleRegression double 8915 102 8919 302 8923 502 double x 1 107178495 1 107264895 1 107351295 double x2 1 107178495E2 1 107264895E2 1 107351295E2 SimpleRegression reg new SimpleRegression int 0 x length reg addData x assertTrue reg getSumSquaredErrors 0 0 OK reg clear int 0 x length reg addData x2 assertTrue reg getSumSquaredErrors 0 0 FAIL,getSumSquaredErrors returns value See test public void testSimpleRegression double       double x       double x  E  E  E SimpleRegression reg new SimpleRegression int  x length reg addData x assertTrue reg getSumSquaredErrors   OK reg clear int  x length reg addData x assertTrue reg getSumSquaredErrors   FAIL,getSumSquaredErrors returns value See test public void testSimpleRegression double double x double x E E E SimpleRegression reg new SimpleRegression int x length reg addData x assertTrue reg getSumSquaredErrors OK reg clear int x length reg addData x assertTrue reg getSumSquaredErrors FAIL,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Math,GaussianFitter Unexpectedly Throws NotStrictlyPositiveException,Running following double observations 1 1143831578403364E 29 4 95281403484594E 28 1 1171347211930288E 26 1 7044813962636277E 25 1 9784716574832164E 24 1 8630236407866774E 23 1 4820532905097742E 22 1 0241963854632831E 21 6 275077366673128E 21 3 461808994532493E 20 1 7407124684715706E 19 8 056687953553974E 19 3 460193945992071E 18 1 3883326374011525E 17 5 233894983671116E 17 1 8630791465263745E 16 6 288759227922111E 16 2 0204433920597856E 15 6 198768938576155E 15 1 821419346860626E 14 5 139176445538471E 14 1 3956427429045787E 13 3 655705706448139E 13 9 253753324779779E 13 2 267636001476696E 12 5 3880460095836855E 12 1 2431632654852931E 11 GaussianFitter g new GaussianFitter new LevenbergMarquardtOptimizer int index 0 index 27 index g addObservedPoint index observations index g fit Results org apache commons math exception NotStrictlyPositiveException 1 277 smaller equal minimum 0 org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java 184 org apache commons math analysis function Gaussian Parametric value Gaussian java 129 guessing initial guess sigma,Running following double observations  E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E  GaussianFitter g new GaussianFitter new LevenbergMarquardtOptimizer int index  index  index g addObservedPoint index observations index g fit Results org apache commons math exception NotStrictlyPositiveException   smaller equal minimum  org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java  org apache commons math analysis function Gaussian Parametric value Gaussian java  guessing initial guess sigma,Running following double observations E E E E E E E E E E E E E E E E E E E E E E E E E E E GaussianFitter g new GaussianFitter new LevenbergMarquardtOptimizer int index index index g addObservedPoint index observations index g fit Results org apache commons math exception NotStrictlyPositiveException smaller equal minimum org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java org apache commons math analysis function Gaussian Parametric value Gaussian java guessing initial guess sigma,1
0,Math,Method getResult MultiStartUnivariateRealOptimizer,MultiStartUnivariateRealOptimizer package optimization method getResult returns result last run underlying optimizer last result might best one case correspond value returned optimize method confusing seem useful think getResult defined public double getResult return optima 0 similarly public double getFunctionValue return optimaValues 0,MultiStartUnivariateRealOptimizer package optimization method getResult returns result last run underlying optimizer last result might best one case correspond value returned optimize method confusing seem useful think getResult defined public double getResult return optima  similarly public double getFunctionValue return optimaValues ,MultiStartUnivariateRealOptimizer package optimization method getResult returns result last run underlying optimizer last result might best one case correspond value returned optimize method confusing seem useful think getResult defined public double getResult return optima similarly public double getFunctionValue return optimaValues,1
0,Math,MathUtils factorial n fails n 17,result MathUtils factorial n n 17 18 19 wrong probably rounding errors double calculations Replace first line MathUtilsTest testFactorial int 1 20 check valid arguments long result see failure suggest implementing simple loop multiply long result even using precomputed long instead adding logarithms,result MathUtils factorial n n    wrong probably rounding errors double calculations Replace first line MathUtilsTest testFactorial int   check valid arguments long result see failure suggest implementing simple loop multiply long result even using precomputed long instead adding logarithms,result MathUtils factorial n n wrong probably rounding errors double calculations Replace first line MathUtilsTest testFactorial int check valid arguments long result see failure suggest implementing simple loop multiply long result even using precomputed long instead adding logarithms,1
0,Math,MathUtils gcd u v fails u v contain high power 2,test beginning MathUtils gcd u v arguments equal zero fails u v contain high enough powers 2 product overflows zero assertEquals 3 1 15 MathUtils gcd 3 1 20 9 1 15 Fix Replace test start MathUtils gcd u v 0 u 0 || v 0,test beginning MathUtils gcd u v arguments equal zero fails u v contain high enough powers  product overflows zero assertEquals    MathUtils gcd       Fix Replace test start MathUtils gcd u v  u  || v ,test beginning MathUtils gcd u v arguments equal zero fails u v contain high enough powers product overflows zero assertEquals MathUtils gcd Fix Replace test start MathUtils gcd u v u || v,1
0,Math,ConvergenceException NormalDistributionImpl cumulativeProbability,get ConvergenceException NormalDistributionImpl cumulativeProbability large small parameters including Infinity Infinity instance following code Test public void testCumulative final NormalDistribution nd new NormalDistributionImpl int 0 500 final double val Math exp try System println val val cumulative nd cumulativeProbability val catch MathException e e printStackTrace fail version 2 0 get exception suggestion change implementation cumulativeProbability double catch ConvergenceException return large small values MaxIterationsExceededException,get ConvergenceException NormalDistributionImpl cumulativeProbability large small parameters including Infinity Infinity instance following code Test public void testCumulative final NormalDistribution nd new NormalDistributionImpl int   final double val Math exp try System println val val cumulative nd cumulativeProbability val catch MathException e e printStackTrace fail version   get exception suggestion change implementation cumulativeProbability double catch ConvergenceException return large small values MaxIterationsExceededException,get ConvergenceException NormalDistributionImpl cumulativeProbability large small parameters including Infinity Infinity instance following code Test public void testCumulative final NormalDistribution nd new NormalDistributionImpl int final double val Math exp try System println val val cumulative nd cumulativeProbability val catch MathException e e printStackTrace fail version get exception suggestion change implementation cumulativeProbability double catch ConvergenceException return large small values MaxIterationsExceededException,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze gives bad results commons math3 3 0 simple test problem works well commons math 2 2,Methode SimplexSolver optimeze gives bad results commons math   simple test problem works well commons math  ,Methode SimplexSolver optimeze gives bad results commons math simple test problem works well commons math,1
0,Math,CMAESOptimizer enforce bounds,CMAESOptimizer exceed bounds passed optimize Looking generationLoop doOptimize bounds check calling isFeasible checkFeasableCount zero default isFeasible never even called Also even non zero checkFeasableCount may give finding bounds offspring go forward bounds offspring svn revision 1387637 provide example program optimizer ends fit outside prescribed bounds would help,CMAESOptimizer exceed bounds passed optimize Looking generationLoop doOptimize bounds check calling isFeasible checkFeasableCount zero default isFeasible never even called Also even non zero checkFeasableCount may give finding bounds offspring go forward bounds offspring svn revision  provide example program optimizer ends fit outside prescribed bounds would help,CMAESOptimizer exceed bounds passed optimize Looking generationLoop doOptimize bounds check calling isFeasible checkFeasableCount zero default isFeasible never even called Also even non zero checkFeasableCount may give finding bounds offspring go forward bounds offspring svn revision provide example program optimizer ends fit outside prescribed bounds would help,1
0,Math,CMAESOptimizer bounds fits finely near lower bound coarsely near upper bound,fitting bounds CMAESOptimizer fits finely near lower bound coarsely near upper bound internally maps fitted parameter range interval 0 1 unit least precision ulp floating point numbers much smaller near zero near one Thus fits much better resolution near lower bound mapped zero upper bound mapped one attach example program demonstrate,fitting bounds CMAESOptimizer fits finely near lower bound coarsely near upper bound internally maps fitted parameter range interval   unit least precision ulp floating point numbers much smaller near zero near one Thus fits much better resolution near lower bound mapped zero upper bound mapped one attach example program demonstrate,fitting bounds CMAESOptimizer fits finely near lower bound coarsely near upper bound internally maps fitted parameter range interval unit least precision ulp floating point numbers much smaller near zero near one Thus fits much better resolution near lower bound mapped zero upper bound mapped one attach example program demonstrate,1
0,Math,Fraction percentageValue rare overflow,percentageValue method Fraction class works first multiplying Fraction 100 converting Fraction double causes overflows numerator greater Integer MAX VALUE 100 even value fraction far value patch changes method first convert double value multiply value 100 result less overflows addition test method covers bug also included,percentageValue method Fraction class works first multiplying Fraction  converting Fraction double causes overflows numerator greater Integer MAX VALUE  even value fraction far value patch changes method first convert double value multiply value  result less overflows addition test method covers bug also included,percentageValue method Fraction class works first multiplying Fraction converting Fraction double causes overflows numerator greater Integer MAX VALUE even value fraction far value patch changes method first convert double value multiply value result less overflows addition test method covers bug also included,1
0,Math,Line revert imprecise,Line revert maintains 10 digits direction becomes issue line position evaluated far origin simple fix would use Vector3D negate direction Also reason Line immutable comprised two vectors,Line revert maintains  digits direction becomes issue line position evaluated far origin simple fix would use VectorD negate direction Also reason Line immutable comprised two vectors,Line revert maintains digits direction becomes issue line position evaluated far origin simple fix would use VectorD negate direction Also reason Line immutable comprised two vectors,1
0,Math,MultivariateNormalDistribution density double returns wrong value dimension odd,reproduce Assert assertEquals 0 398942280401433 new MultivariateNormalDistribution new double 0 new double 1 density new double 0 1e 15,reproduce Assert assertEquals   new MultivariateNormalDistribution new double  new double  density new double  e ,reproduce Assert assertEquals new MultivariateNormalDistribution new double new double density new double e,1
0,Math,event state updated unrelated event triggers RESET STATE ODE integration,ODE solver manages several different event types unwanted side effects one event handler asks RESET STATE integration state eventOccurred method called event handlers trigger event step updated correctly due early return result next step processed reset integration state forgotten event still refer start date previous state implies event handlers checked cases function defining event g double double called state parameters completely wrong one case array contained values 1 1 one function call got values 1 0e20 attached file reproduces problem,ODE solver manages several different event types unwanted side effects one event handler asks RESET STATE integration state eventOccurred method called event handlers trigger event step updated correctly due early return result next step processed reset integration state forgotten event still refer start date previous state implies event handlers checked cases function defining event g double double called state parameters completely wrong one case array contained values   one function call got values  e attached file reproduces problem,ODE solver manages several different event types unwanted side effects one event handler asks RESET STATE integration state eventOccurred method called event handlers trigger event step updated correctly due early return result next step processed reset integration state forgotten event still refer start date previous state implies event handlers checked cases function defining event g double double called state parameters completely wrong one case array contained values one function call got values e attached file reproduces problem,1
0,Math,Bugs RealVector ebeMultiply RealVector ebeDivide RealVector,OpenMapRealVector ebeMultiply RealVector OpenMapRealVector ebeDivide RealVector return wrong values one entry specified RealVector nan infinity bug easy understand current implementation ebeMultiply public OpenMapRealVector ebeMultiply RealVector v checkVectorDimensions v getDimension OpenMapRealVector res new OpenMapRealVector Iterator iter entries iterator iter hasNext iter advance res setEntry iter key iter value v getEntry iter key return res assumption double x x 0d 0d holds true bug easy enough identify complex solve solution come loop entries v instead entries correspond non zero entries afraid performance losses,OpenMapRealVector ebeMultiply RealVector OpenMapRealVector ebeDivide RealVector return wrong values one entry specified RealVector nan infinity bug easy understand current implementation ebeMultiply public OpenMapRealVector ebeMultiply RealVector v checkVectorDimensions v getDimension OpenMapRealVector res new OpenMapRealVector Iterator iter entries iterator iter hasNext iter advance res setEntry iter key iter value v getEntry iter key return res assumption double x x d d holds true bug easy enough identify complex solve solution come loop entries v instead entries correspond non zero entries afraid performance losses,OpenMapRealVector ebeMultiply RealVector OpenMapRealVector ebeDivide RealVector return wrong values one entry specified RealVector nan infinity bug easy understand current implementation ebeMultiply public OpenMapRealVector ebeMultiply RealVector v checkVectorDimensions v getDimension OpenMapRealVector res new OpenMapRealVector Iterator iter entries iterator iter hasNext iter advance res setEntry iter key iter value v getEntry iter key return res assumption double x x holds true bug easy enough identify complex solve solution come loop entries v instead entries correspond non zero entries afraid performance losses,1
0,Math,FastMath cosh sinh support range values Math counterparts,reported Jeff Hain cosh double sinh double Math cosh 709 783 8 991046692770538E307 FastMath cosh 709 783 Infinity Math sinh 709 783 8 991046692770538E307 FastMath sinh 709 783 Infinity due using exp x 2 values |x| 20 result sometimes overflow exp x end infinity values |x| StrictMath log Double MAX VALUE exp overflow need use instead x positive double exp x 0 5 return 0 5 x negative double exp x 0 5 return 0 5,reported Jeff Hain cosh double sinh double Math cosh    E FastMath cosh   Infinity Math sinh    E FastMath sinh   Infinity due using exp x  values |x|  result sometimes overflow exp x end infinity values |x| StrictMath log Double MAX VALUE exp overflow need use instead x positive double exp x   return   x negative double exp x   return  ,reported Jeff Hain cosh double sinh double Math cosh E FastMath cosh Infinity Math sinh E FastMath sinh Infinity due using exp x values |x| result sometimes overflow exp x end infinity values |x| StrictMath log Double MAX VALUE exp overflow need use instead x positive double exp x return x negative double exp x return,1
0,Math,Negative value restrictNonNegative,Problem commons math 2 2 SimplexSolver variable 0 coefficient may assigned negative value nevertheless restrictToNonnegative flag call SimplexSolver optimize function constraints GoalType MINIMIZE true Function 1 x 1 0 Constraints 1 x 0 1 Result x 1 1 Probably variables 0 coefficients omitted point computation restrictions affect values,Problem commons math   SimplexSolver variable  coefficient may assigned negative value nevertheless restrictToNonnegative flag call SimplexSolver optimize function constraints GoalType MINIMIZE true Function  x   Constraints  x   Result x   Probably variables  coefficients omitted point computation restrictions affect values,Problem commons math SimplexSolver variable coefficient may assigned negative value nevertheless restrictToNonnegative flag call SimplexSolver optimize function constraints GoalType MINIMIZE true Function x Constraints x Result x Probably variables coefficients omitted point computation restrictions affect values,1
0,Math,Bugs Frequency API,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return 0 object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ 0 System println f getPct OBJ 0 0 Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return 0 Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return  object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ  System println f getPct OBJ   Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return  Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ System println f getPct OBJ Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return Exception applying instanceof fix would also cause fail,1
0,Math,Integer overflow OpenMapRealMatrix,computeKey integer overflow Since sparse matrix quite easily encountered long heap space exhausted attached code demonstrates problem could potentially security vulnerability example one use matrix store access control information Workaround never create OpenMapRealMatrix cells addressable int,computeKey integer overflow Since sparse matrix quite easily encountered long heap space exhausted attached code demonstrates problem could potentially security vulnerability example one use matrix store access control information Workaround never create OpenMapRealMatrix cells addressable int,computeKey integer overflow Since sparse matrix quite easily encountered long heap space exhausted attached code demonstrates problem could potentially security vulnerability example one use matrix store access control information Workaround never create OpenMapRealMatrix cells addressable int,1
0,Math,Brent solver throw IllegalArgumentException initial guess wrong sign,Javadoc public double solve final UnivariateRealFunction f final double min final double max final double initial claims values function three points sign IllegalArgumentException thrown case even checked,Javadoc public double solve final UnivariateRealFunction f final double min final double max final double initial claims values function three points sign IllegalArgumentException thrown case even checked,Javadoc public double solve final UnivariateRealFunction f final double min final double max final double initial claims values function three points sign IllegalArgumentException thrown case even checked,1
0,Math,Basic variable found correctly simplex tableau,last patch SimplexTableau caused automated test suite running work go new code path uncover hopefully last bug remaining Simplex code SimplexTableau assuming entry tableau nonzero indicate basic variable incorrect entry value equal 1,last patch SimplexTableau caused automated test suite running work go new code path uncover hopefully last bug remaining Simplex code SimplexTableau assuming entry tableau nonzero indicate basic variable incorrect entry value equal ,last patch SimplexTableau caused automated test suite running work go new code path uncover hopefully last bug remaining Simplex code SimplexTableau assuming entry tableau nonzero indicate basic variable incorrect entry value equal,1
0,Math,wrong result eigen decomposition,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version 2 0 public void testMathpbx02 double mainTridiagonal 7484 860960227216 18405 28129035345 13855 225609560746 10016 708722343366 559 8117399576674 6750 190788301587 71 21428769782159 double secondaryTridiagonal 4175 088570476366 1975 7955858241994 5193 178422374075 1995 286659169179 75 34535882933804 234 0808002076056 reference values computed using routine DSTEMR fortran library LAPACK version 3 2 1 double refEigenValues 20654 744890306974412 16828 208208485466457 6893 155912634994820 6757 083016675340332 5887 799885688558788 64 309089923240379 57 992628792736340 RealVector refEigenVectors new ArrayRealVector new double 0 270356342026904 0 852811091326997 0 399639490702077 0 198794657813990 0 019739323307666 0 000106983022327 0 000001216636321 new ArrayRealVector new double 0 179995273578326 0 402807848153042 0 701870993525734 0 555058211014888 0 068079148898236 0 000509139115227 0 000007112235617 new ArrayRealVector new double 0 399582721284727 0 056629954519333 0 514406488522827 0 711168164518580 0 225548081276367 0 125943999652923 0 004321507456014 new ArrayRealVector new double 0 058515721572821 0 010200130057739 0 063516274916536 0 090696087449378 0 017148420432597 0 991318870265707 0 034707338554096 new ArrayRealVector new double 0 855205995537564 0 327134656629775 0 265382397060548 0 282690729026706 0 105736068025572 0 009138126622039 0 000367751821196 new ArrayRealVector new double 0 002913069901144 0 005177515777101 0 041906334478672 0 109315918416258 0 436192305456741 0 026307315639535 0 891797507436344 new ArrayRealVector new double 0 005738311176435 0 010207611670378 0 082662420517928 0 215733886094368 0 861606487840411 0 025478530652759 0 451080697503958 following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int 0 refEigenValues length assertEquals refEigenValues eigenValues 1 0e 3 refEigenVectors dotProduct decomposition getEigenvector 0 assertEquals 0 refEigenVectors add decomposition getEigenvector getNorm 1 0e 5 else assertEquals 0 refEigenVectors subtract decomposition getEigenvector getNorm 1 0e 5,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version   public void testMathpbx double mainTridiagonal               double secondaryTridiagonal             reference values computed using routine DSTEMR fortran library LAPACK version    double refEigenValues               RealVector refEigenVectors new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int  refEigenValues length assertEquals refEigenValues eigenValues  e  refEigenVectors dotProduct decomposition getEigenvector  assertEquals  refEigenVectors add decomposition getEigenvector getNorm  e  else assertEquals  refEigenVectors subtract decomposition getEigenvector getNorm  e ,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version public void testMathpbx double mainTridiagonal double secondaryTridiagonal reference values computed using routine DSTEMR fortran library LAPACK version double refEigenValues RealVector refEigenVectors new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int refEigenValues length assertEquals refEigenValues eigenValues e refEigenVectors dotProduct decomposition getEigenvector assertEquals refEigenVectors add decomposition getEigenvector getNorm e else assertEquals refEigenVectors subtract decomposition getEigenvector getNorm e,1
0,Math,Wrong parameter first step size guess Embedded Runge Kutta methods,space application using DOP853 detected seems bad parameter call method initializeStep class AdaptiveStepsizeIntegrator DormandPrince853Integrator subclass EmbeddedRungeKuttaIntegrator perform call initializeStep beginning method integrate problem comes array scale used parameter call initializeStep Following theory described Hairer book Solving Ordinary Differential Equations 1 Nonstiff Problems scaling sci Atol |y0i| Rtoli Whereas EmbeddedRungeKuttaIntegrator uses sci Atoli Note Gragg Bulirsch Stoer integrator uses good implementation sci Atol |y0i| Rtoli performs call method initializeStep method initializeStep error leads wrong step size h used perform Euler step time unvisible user space application Euler step wrong step size h much bigger makes exception occur satellite hits ground fix bug one use algorithm rescale method GraggBulirschStoerIntegrator exemple final double scale new double y0 length vecAbsoluteTolerance null int 0 scale length final double yi Math max Math abs y0 Math abs y0 scale scalAbsoluteTolerance scalRelativeTolerance yi else int 0 scale length final double yi Math max Math abs y0 Math abs y0 scale vecAbsoluteTolerance vecRelativeTolerance yi hNew initializeStep equations forward getOrder scale stepStart yDotK 0 yTmp yDotK 1 Sorry length message looking forward hearing soon Vincent Morand,space application using DOP detected seems bad parameter call method initializeStep class AdaptiveStepsizeIntegrator DormandPrinceIntegrator subclass EmbeddedRungeKuttaIntegrator perform call initializeStep beginning method integrate problem comes array scale used parameter call initializeStep Following theory described Hairer book Solving Ordinary Differential Equations  Nonstiff Problems scaling sci Atol |yi| Rtoli Whereas EmbeddedRungeKuttaIntegrator uses sci Atoli Note Gragg Bulirsch Stoer integrator uses good implementation sci Atol |yi| Rtoli performs call method initializeStep method initializeStep error leads wrong step size h used perform Euler step time unvisible user space application Euler step wrong step size h much bigger makes exception occur satellite hits ground fix bug one use algorithm rescale method GraggBulirschStoerIntegrator exemple final double scale new double y length vecAbsoluteTolerance null int  scale length final double yi Math max Math abs y Math abs y scale scalAbsoluteTolerance scalRelativeTolerance yi else int  scale length final double yi Math max Math abs y Math abs y scale vecAbsoluteTolerance vecRelativeTolerance yi hNew initializeStep equations forward getOrder scale stepStart yDotK  yTmp yDotK  Sorry length message looking forward hearing soon Vincent Morand,space application using DOP detected seems bad parameter call method initializeStep class AdaptiveStepsizeIntegrator DormandPrinceIntegrator subclass EmbeddedRungeKuttaIntegrator perform call initializeStep beginning method integrate problem comes array scale used parameter call initializeStep Following theory described Hairer book Solving Ordinary Differential Equations Nonstiff Problems scaling sci Atol |yi| Rtoli Whereas EmbeddedRungeKuttaIntegrator uses sci Atoli Note Gragg Bulirsch Stoer integrator uses good implementation sci Atol |yi| Rtoli performs call method initializeStep method initializeStep error leads wrong step size h used perform Euler step time unvisible user space application Euler step wrong step size h much bigger makes exception occur satellite hits ground fix bug one use algorithm rescale method GraggBulirschStoerIntegrator exemple final double scale new double length vecAbsoluteTolerance null int scale length final double yi Math max Math abs Math abs scale scalAbsoluteTolerance scalRelativeTolerance yi else int scale length final double yi Math max Math abs Math abs scale vecAbsoluteTolerance vecRelativeTolerance yi hNew initializeStep equations forward getOrder scale stepStart yDotK yTmp yDotK Sorry length message looking forward hearing soon Vincent Morand,1
0,Math,LevenbergMarquardtOptimizer reports 0 iterations,method LevenbergMarquardtOptimizer getIterations report correct number iterations always returns 0 quick look code shows SimplexOptimizer calls BaseOptimizer incrementEvaluationsCount put test case Notice evaluations count correctly incremented iterations count Test public void testGetIterations setup LevenbergMarquardtOptimizer otim new LevenbergMarquardtOptimizer action otim optimize new MaxEval 100 new Target new double 1 new Weight new double 1 new InitialGuess new double 3 new ModelFunction new MultivariateVectorFunction Override public double value double point throws IllegalArgumentException return new double FastMath pow point 0 4 new ModelFunctionJacobian new MultivariateMatrixFunction Override public double value double point throws IllegalArgumentException return new double 0 25 FastMath pow point 0 3 verify assertThat otim getEvaluations greaterThan 1 assertThat otim getIterations greaterThan 1,method LevenbergMarquardtOptimizer getIterations report correct number iterations always returns  quick look code shows SimplexOptimizer calls BaseOptimizer incrementEvaluationsCount put test case Notice evaluations count correctly incremented iterations count Test public void testGetIterations setup LevenbergMarquardtOptimizer otim new LevenbergMarquardtOptimizer action otim optimize new MaxEval  new Target new double  new Weight new double  new InitialGuess new double  new ModelFunction new MultivariateVectorFunction Override public double value double point throws IllegalArgumentException return new double FastMath pow point   new ModelFunctionJacobian new MultivariateMatrixFunction Override public double value double point throws IllegalArgumentException return new double   FastMath pow point   verify assertThat otim getEvaluations greaterThan  assertThat otim getIterations greaterThan ,method LevenbergMarquardtOptimizer getIterations report correct number iterations always returns quick look code shows SimplexOptimizer calls BaseOptimizer incrementEvaluationsCount put test case Notice evaluations count correctly incremented iterations count Test public void testGetIterations setup LevenbergMarquardtOptimizer otim new LevenbergMarquardtOptimizer action otim optimize new MaxEval new Target new double new Weight new double new InitialGuess new double new ModelFunction new MultivariateVectorFunction Override public double value double point throws IllegalArgumentException return new double FastMath pow point new ModelFunctionJacobian new MultivariateMatrixFunction Override public double value double point throws IllegalArgumentException return new double FastMath pow point verify assertThat otim getEvaluations greaterThan assertThat otim getIterations greaterThan,1
0,Math,expected UnboundedSolutionException,SimplexSolver throws UnboundedSolutionException trying solve minimization linear programming problem number exception thrown depends number variables order see behavior SimplexSolver first try run JUnit test setting final variable ENTITIES COUNT 2 give almost good result set 15 get massive unbounded exceptions First iteration runned predefined set input data Solver gives back appropriate result problem well tested authors mathematicians believe know developed using Matlab 10 unbounded solutions rules creatnig random variables values strange dependence number UnboundedSolutionException exceptions number variables problem problem formulated min 1 0 L every r th subject q r QL 0 x r XL 0 L 0 r 1 R L l 1 l 2 l R vector R rows 1 column Q coefficients matrix MxR X coefficients matrix NxR,SimplexSolver throws UnboundedSolutionException trying solve minimization linear programming problem number exception thrown depends number variables order see behavior SimplexSolver first try run JUnit test setting final variable ENTITIES COUNT  give almost good result set  get massive unbounded exceptions First iteration runned predefined set input data Solver gives back appropriate result problem well tested authors mathematicians believe know developed using Matlab  unbounded solutions rules creatnig random variables values strange dependence number UnboundedSolutionException exceptions number variables problem problem formulated min   L every r th subject q r QL  x r XL  L  r  R L l  l  l R vector R rows  column Q coefficients matrix MxR X coefficients matrix NxR,SimplexSolver throws UnboundedSolutionException trying solve minimization linear programming problem number exception thrown depends number variables order see behavior SimplexSolver first try run JUnit test setting final variable ENTITIES COUNT give almost good result set get massive unbounded exceptions First iteration runned predefined set input data Solver gives back appropriate result problem well tested authors mathematicians believe know developed using Matlab unbounded solutions rules creatnig random variables values strange dependence number UnboundedSolutionException exceptions number variables problem problem formulated min L every r th subject q r QL x r XL L r R L l l l R vector R rows column Q coefficients matrix MxR X coefficients matrix NxR,1
0,Math,Dfp Dfp multiply int x comply general contract FieldElement multiply int n,class org apache commons math3 Dfp method multiply int n limited 0 n 9999 consistent general contract FieldElement multiply int n limitation values n,class org apache commons math Dfp method multiply int n limited  n  consistent general contract FieldElement multiply int n limitation values n,class org apache commons math Dfp method multiply int n limited n consistent general contract FieldElement multiply int n limitation values n,1
0,Math,Fraction specified maxDenominator value close simple fraction throw overflow exception,overflow exception thrown Fraction initialized maxDenominator double close simple fraction example double 0 5000000001 Fraction f new Fraction 10 Patch unit test way,overflow exception thrown Fraction initialized maxDenominator double close simple fraction example double   Fraction f new Fraction  Patch unit test way,overflow exception thrown Fraction initialized maxDenominator double close simple fraction example double Fraction f new Fraction Patch unit test way,1
0,Math,DerivativeStructure atan2 x handle special cases properly,four special cases 0 x give values Math atan2 FastMath atan2 However give NaN value cases,four special cases  x give values Math atan FastMath atan However give NaN value cases,four special cases x give values Math atan FastMath atan However give NaN value cases,1
0,Math,Wide bounds CMAESOptimizer result NaN parameters passed fitness function,give large values lower upper bounds example Double MAX VALUE lower bound optimizer call fitness function parameters set NaN guess due FitnessFunction encode decode generating NaN normalizing denormalizing parameters example difference lower upper bound greater Double MAX VALUE encode could divide infinity infinity,give large values lower upper bounds example Double MAX VALUE lower bound optimizer call fitness function parameters set NaN guess due FitnessFunction encode decode generating NaN normalizing denormalizing parameters example difference lower upper bound greater Double MAX VALUE encode could divide infinity infinity,give large values lower upper bounds example Double MAX VALUE lower bound optimizer call fitness function parameters set NaN guess due FitnessFunction encode decode generating NaN normalizing denormalizing parameters example difference lower upper bound greater Double MAX VALUE encode could divide infinity infinity,1
0,Math,Fraction double int constructor strange behaviour,Fraction constructor Fraction double int takes double value int maximal denominator approximates fraction double value large negative number many digits fractional part maximal denominator big positive integer 100 000s two distinct bugs manifest 1 constructor returns positive Fraction Calling Fraction 33655 1677817278 371880 returns fraction 410517235 243036 wrong sign far away absolute value given value 2 constructor manage reduce Fraction properly Calling Fraction 43979 60679604749 366081 returns fraction 1651878166 256677 reduced 24654898 3831 yet found solution constructor looks like public Fraction double value int maxDenominator throws FractionConversionException value 0 maxDenominator 100 Increasing 100 value max iterations fix problem cases Changing 0 value epsilon maximum allowed error something small work either breaks tests FractionTest problem neccissarily algorithm unable approximate fraction correctly solution FractionConversionException thrown examples would probably best solution improvement approximation algorithm turns hard find bug found trying explore idea axiom based testing http bldl ii uib testing html Attached java test class FractionTestByAxiom junit goes org apache commons math3 fraction shows bugs simplified approach kind testing text file describing value maxDenominator combinations causes one failures never specified documentation Fraction class guarantees completely reduced rational numbers constructed comment inside equals method claims since fractions always lowest terms numerators compared directly equality seems like intention,Fraction constructor Fraction double int takes double value int maximal denominator approximates fraction double value large negative number many digits fractional part maximal denominator big positive integer  s two distinct bugs manifest  constructor returns positive Fraction Calling Fraction    returns fraction   wrong sign far away absolute value given value  constructor manage reduce Fraction properly Calling Fraction    returns fraction   reduced   yet found solution constructor looks like public Fraction double value int maxDenominator throws FractionConversionException value  maxDenominator  Increasing  value max iterations fix problem cases Changing  value epsilon maximum allowed error something small work either breaks tests FractionTest problem neccissarily algorithm unable approximate fraction correctly solution FractionConversionException thrown examples would probably best solution improvement approximation algorithm turns hard find bug found trying explore idea axiom based testing http bldl ii uib testing html Attached java test class FractionTestByAxiom junit goes org apache commons math fraction shows bugs simplified approach kind testing text file describing value maxDenominator combinations causes one failures never specified documentation Fraction class guarantees completely reduced rational numbers constructed comment inside equals method claims since fractions always lowest terms numerators compared directly equality seems like intention,Fraction constructor Fraction double int takes double value int maximal denominator approximates fraction double value large negative number many digits fractional part maximal denominator big positive integer two distinct bugs manifest constructor returns positive Fraction Calling Fraction returns fraction wrong sign far away absolute value given value constructor manage reduce Fraction properly Calling Fraction returns fraction reduced yet found solution constructor looks like public Fraction double value int maxDenominator throws FractionConversionException value maxDenominator Increasing value max iterations fix problem cases Changing value epsilon maximum allowed error something small work either breaks tests FractionTest problem neccissarily algorithm unable approximate fraction correctly solution FractionConversionException thrown examples would probably best solution improvement approximation algorithm turns hard find bug found trying explore idea axiom based testing http bldl ii uib testing html Attached java test class FractionTestByAxiom junit goes org apache commons math fraction shows bugs simplified approach kind testing text file describing value maxDenominator combinations causes one failures never specified documentation Fraction class guarantees completely reduced rational numbers constructed comment inside equals method claims since fractions always lowest terms numerators compared directly equality seems like intention,1
0,Math,DiscreteDistribution sample int may throw exception first element singletons sub class type,Creating array Array newInstance singletons get 0 getClass sampleSize DiscreteDistribution sample int risky exception thrown singleons get 0 type T1 sub class DiscreteDistribution sample returns object type type T1 reproduce List Pair Object Double list new ArrayList Pair Object Double list add new Pair Object Double new Object new Double 0 list add new Pair Object Double new Object new Double 1 new DiscreteDistribution Object list sample 1 Attaching patch,Creating array Array newInstance singletons get  getClass sampleSize DiscreteDistribution sample int risky exception thrown singleons get  type T sub class DiscreteDistribution sample returns object type type T reproduce List Pair Object Double list new ArrayList Pair Object Double list add new Pair Object Double new Object new Double  list add new Pair Object Double new Object new Double  new DiscreteDistribution Object list sample  Attaching patch,Creating array Array newInstance singletons get getClass sampleSize DiscreteDistribution sample int risky exception thrown singleons get type sub class DiscreteDistribution sample returns object type type reproduce List Pair Object Double list new ArrayList Pair Object Double list add new Pair Object Double new Object new Double list add new Pair Object Double new Object new Double new DiscreteDistribution Object list sample Attaching patch,1
0,Math,Correlated random vector generator fails silently faced zero rows covariance matrix,following three matrices basically permutations produce different results sampling multi variate Gaussian help CorrelatedRandomVectorGenerator sample covariances calculated R based 10 000 samples Array2DRowRealMatrix 0 0 0 0 0 0 0 0 0 0 0 0 0 013445532 0 01039469 0 009881156 0 010499559 0 0 0 01039469 0 023006616 0 008196856 0 010732709 0 0 0 009881156 0 008196856 0 019023866 0 009210099 0 0 0 010499559 0 010732709 0 009210099 0 019107243 cov data1 V1 V2 V3 V4 V5 V1 0 0 000000000 0 00000000 0 000000000 0 000000000 V2 0 0 013383931 0 01034401 0 009913271 0 010506733 V3 0 0 010344006 0 02309479 0 008374730 0 010759306 V4 0 0 009913271 0 00837473 0 019005488 0 009187287 V5 0 0 010506733 0 01075931 0 009187287 0 019021483 Array2DRowRealMatrix 0 013445532 0 01039469 0 0 0 009881156 0 010499559 0 01039469 0 023006616 0 0 0 008196856 0 010732709 0 0 0 0 0 0 0 0 0 0 0 009881156 0 008196856 0 0 0 019023866 0 009210099 0 010499559 0 010732709 0 0 0 009210099 0 019107243 cov data2 V1 V2 V3 V4 V5 V1 0 006922905 0 010507692 0 0 005817399 0 010330529 V2 0 010507692 0 023428918 0 0 008273152 0 010735568 V3 0 000000000 0 000000000 0 0 000000000 0 000000000 V4 0 005817399 0 008273152 0 0 004929843 0 009048759 V5 0 010330529 0 010735568 0 0 009048759 0 018683544 Array2DRowRealMatrix 0 013445532 0 01039469 0 009881156 0 010499559 0 01039469 0 023006616 0 008196856 0 010732709 0 009881156 0 008196856 0 019023866 0 009210099 0 010499559 0 010732709 0 009210099 0 019107243 cov data3 V1 V2 V3 V4 V1 0 013445047 0 010478862 0 009955904 0 010529542 V2 0 010478862 0 022910522 0 008610113 0 011046353 V3 0 009955904 0 008610113 0 019250975 0 009464442 V4 0 010529542 0 011046353 0 009464442 0 019260317 traced back RectangularCholeskyDecomposition seem handle second matrix well decompositions order matrices CorrelatedRandomVectorGenerator getRootMatrix Array2DRowRealMatrix 0 0 0 0 0 0 0 0 0 0 0 0759577418122063 0 0876125188474239 0 0 0 0 0 0 0 07764443622513505 0 05132821221460752 0 11976381821791235 0 0 0 0 0 06662930527909404 0 05501661744114585 0 0016662506519307997 0 10749324207653632 0 0 0 13822895138139477 0 0 0 0 0 0 0 0 CorrelatedRandomVectorGenerator getRank 5 CorrelatedRandomVectorGenerator getRootMatrix Array2DRowRealMatrix 0 0759577418122063 0 034512751379448724 0 0 0 07764443622513505 0 13029949164628746 0 0 0 0 0 0 0 0 0 06662930527909404 0 023203936694855674 0 0 0 13822895138139477 0 0 0 0 CorrelatedRandomVectorGenerator getRank 3 CorrelatedRandomVectorGenerator getRootMatrix Array2DRowRealMatrix 0 0759577418122063 0 034512751379448724 0 033913748226348225 0 07303890149947785 0 07764443622513505 0 13029949164628746 0 0 0 0 0 06662930527909404 0 023203936694855674 0 11851573313229945 0 0 0 13822895138139477 0 0 0 0 0 0 CorrelatedRandomVectorGenerator getRank 4 Clearly rank matrices 4 first matrix lead incorrect results second one Unfortunately know enough Cholesky decomposition find flaw implementation could find documentation rectangular variant also links provided javadoc,following three matrices basically permutations produce different results sampling multi variate Gaussian help CorrelatedRandomVectorGenerator sample covariances calculated R based   samples ArrayDRowRealMatrix                                                   cov data V V V V V V          V          V          V          V          ArrayDRowRealMatrix                                                   cov data V V V V V V          V          V          V          V          ArrayDRowRealMatrix                                 cov data V V V V V         V         V         V         traced back RectangularCholeskyDecomposition seem handle second matrix well decompositions order matrices CorrelatedRandomVectorGenerator getRootMatrix ArrayDRowRealMatrix                                                   CorrelatedRandomVectorGenerator getRank  CorrelatedRandomVectorGenerator getRootMatrix ArrayDRowRealMatrix                               CorrelatedRandomVectorGenerator getRank  CorrelatedRandomVectorGenerator getRootMatrix ArrayDRowRealMatrix                                 CorrelatedRandomVectorGenerator getRank  Clearly rank matrices  first matrix lead incorrect results second one Unfortunately know enough Cholesky decomposition find flaw implementation could find documentation rectangular variant also links provided javadoc,following three matrices basically permutations produce different results sampling multi variate Gaussian help CorrelatedRandomVectorGenerator sample covariances calculated R based samples ArrayDRowRealMatrix cov data V V V V V V V V V V ArrayDRowRealMatrix cov data V V V V V V V V V V ArrayDRowRealMatrix cov data V V V V V V V V traced back RectangularCholeskyDecomposition seem handle second matrix well decompositions order matrices CorrelatedRandomVectorGenerator getRootMatrix ArrayDRowRealMatrix CorrelatedRandomVectorGenerator getRank CorrelatedRandomVectorGenerator getRootMatrix ArrayDRowRealMatrix CorrelatedRandomVectorGenerator getRank CorrelatedRandomVectorGenerator getRootMatrix ArrayDRowRealMatrix CorrelatedRandomVectorGenerator getRank Clearly rank matrices first matrix lead incorrect results second one Unfortunately know enough Cholesky decomposition find flaw implementation could find documentation rectangular variant also links provided javadoc,1
0,Math,stat Frequency getPct Object uses getCumPct Comparable instead getPct Comparable,Drop Replacement 1 2 2 0 possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable 2 0 Deprecated public double getPct Object v return getCumPct Comparable v,Drop Replacement     possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable   Deprecated public double getPct Object v return getCumPct Comparable v,Drop Replacement possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable Deprecated public double getPct Object v return getCumPct Comparable v,1
0,Math,ArrayIndexOutOfBoundException EigenDecompositionImpl,following test triggers ArrayIndexOutOfBoundException public void testMath308 double mainTridiagonal 22 330154644539597 46 65485522478641 17 393672330044705 54 46687435351116 80 17800767709437 double secondaryTridiagonal 13 04450406501361 5 977590941539671 2 9040909856707517 7 1570352792841225 reference values computed using routine DSTEMR fortran library LAPACK version 3 2 1 double refEigenValues 14 138204224043099 18 847969733754262 52 536278520113882 53 456697699894512 82 044413207204002 RealVector refEigenVectors new ArrayRealVector new double 0 584677060845929 0 367177264979103 0 721453187784497 0 052971054621812 0 005740715188257 new ArrayRealVector new double 0 713933751051495 0 190582113553930 0 671410443368332 0 056056055955050 0 006541576993581 new ArrayRealVector new double 0 222368839324646 0 514921891363332 0 021377019336614 0 801196801016305 0 207446991247740 new ArrayRealVector new double 0 314647769490148 0 750806415553905 0 167700312025760 0 537092972407375 0 143854968127780 new ArrayRealVector new double 0 000462690386766 0 002118073109055 0 011530080757413 0 252322434584915 0 967572088232592 following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int 0 refEigenValues length assertEquals refEigenValues eigenValues 1 0e 6 refEigenVectors dotProduct decomposition getEigenvector 0 assertEquals 0 refEigenVectors add decomposition getEigenvector getNorm 1 0e 6 else assertEquals 0 refEigenVectors subtract decomposition getEigenvector getNorm 1 0e 6 Running previous method Junit test triggers exception EigenDecompositionImpl instance built first lines stack trace java lang ArrayIndexOutOfBoundsException 1 org apache commons math linear EigenDecompositionImpl computeShiftIncrement EigenDecompositionImpl java 1545 org apache commons math linear EigenDecompositionImpl goodStep EigenDecompositionImpl java 1072 org apache commons math linear EigenDecompositionImpl processGeneralBlock EigenDecompositionImpl java 894 org apache commons math linear EigenDecompositionImpl findEigenvalues EigenDecompositionImpl java 658 org apache commons math linear EigenDecompositionImpl decompose EigenDecompositionImpl java 246 org apache commons math linear EigenDecompositionImpl init EigenDecompositionImpl java 205 org apache commons math linear EigenDecompositionImplTest testMath308 EigenDecompositionImplTest java 136 currently investigating bug simple index translation error original fortran Lapack commons math implementation,following test triggers ArrayIndexOutOfBoundException public void testMath double mainTridiagonal           double secondaryTridiagonal         reference values computed using routine DSTEMR fortran library LAPACK version    double refEigenValues           RealVector refEigenVectors new ArrayRealVector new double           new ArrayRealVector new double           new ArrayRealVector new double           new ArrayRealVector new double           new ArrayRealVector new double           following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int  refEigenValues length assertEquals refEigenValues eigenValues  e  refEigenVectors dotProduct decomposition getEigenvector  assertEquals  refEigenVectors add decomposition getEigenvector getNorm  e  else assertEquals  refEigenVectors subtract decomposition getEigenvector getNorm  e  Running previous method Junit test triggers exception EigenDecompositionImpl instance built first lines stack trace java lang ArrayIndexOutOfBoundsException  org apache commons math linear EigenDecompositionImpl computeShiftIncrement EigenDecompositionImpl java  org apache commons math linear EigenDecompositionImpl goodStep EigenDecompositionImpl java  org apache commons math linear EigenDecompositionImpl processGeneralBlock EigenDecompositionImpl java  org apache commons math linear EigenDecompositionImpl findEigenvalues EigenDecompositionImpl java  org apache commons math linear EigenDecompositionImpl decompose EigenDecompositionImpl java  org apache commons math linear EigenDecompositionImpl init EigenDecompositionImpl java  org apache commons math linear EigenDecompositionImplTest testMath EigenDecompositionImplTest java  currently investigating bug simple index translation error original fortran Lapack commons math implementation,following test triggers ArrayIndexOutOfBoundException public void testMath double mainTridiagonal double secondaryTridiagonal reference values computed using routine DSTEMR fortran library LAPACK version double refEigenValues RealVector refEigenVectors new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int refEigenValues length assertEquals refEigenValues eigenValues e refEigenVectors dotProduct decomposition getEigenvector assertEquals refEigenVectors add decomposition getEigenvector getNorm e else assertEquals refEigenVectors subtract decomposition getEigenvector getNorm e Running previous method Junit test triggers exception EigenDecompositionImpl instance built first lines stack trace java lang ArrayIndexOutOfBoundsException org apache commons math linear EigenDecompositionImpl computeShiftIncrement EigenDecompositionImpl java org apache commons math linear EigenDecompositionImpl goodStep EigenDecompositionImpl java org apache commons math linear EigenDecompositionImpl processGeneralBlock EigenDecompositionImpl java org apache commons math linear EigenDecompositionImpl findEigenvalues EigenDecompositionImpl java org apache commons math linear EigenDecompositionImpl decompose EigenDecompositionImpl java org apache commons math linear EigenDecompositionImpl init EigenDecompositionImpl java org apache commons math linear EigenDecompositionImplTest testMath EigenDecompositionImplTest java currently investigating bug simple index translation error original fortran Lapack commons math implementation,1
0,Math,testing symmetric positive definite matrix CholeskyDecomposition,used matrix double cv 0 40434286 0 09376327 0 30328980 0 04909388 0 09376327 0 10400408 0 07137959 0 04762857 0 30328980 0 07137959 0 30458776 0 04882449 0 04909388 0 04762857 0 04882449 0 07543265 works fine symmetric positive definite tried matrix double cv 0 40434286 0 09376327 0 30328980 0 04909388 0 09376327 0 10400408 0 07137959 0 04762857 0 30328980 0 07137959 0 30458776 0 04882449 0 04909388 0 04762857 0 04882449 0 07543265 throw exception tested matrix R R cholesky decomposition method returns matrix symmetric positive definite Obviously code catching appropriately way opinion use exceptions check conditions best design use exceptions going force use try catch exceptions least provide methods test conditions prior possibility exception,used matrix double cv                                 works fine symmetric positive definite tried matrix double cv                                 throw exception tested matrix R R cholesky decomposition method returns matrix symmetric positive definite Obviously code catching appropriately way opinion use exceptions check conditions best design use exceptions going force use try catch exceptions least provide methods test conditions prior possibility exception,used matrix double cv works fine symmetric positive definite tried matrix double cv throw exception tested matrix R R cholesky decomposition method returns matrix symmetric positive definite Obviously code catching appropriately way opinion use exceptions check conditions best design use exceptions going force use try catch exceptions least provide methods test conditions prior possibility exception,1
0,Math,Brent solver returns wrong value either bracket endpoint root,solve final UnivariateRealFunction f final double min final double max final double initial function returns yMin yMax min max deemed roots respectively instead min max,solve final UnivariateRealFunction f final double min final double max final double initial function returns yMin yMax min max deemed roots respectively instead min max,solve final UnivariateRealFunction f final double min final double max final double initial function returns yMin yMax min max deemed roots respectively instead min max,1
0,Math,Incomplete reinitialization events handling,get bug event handling track 2 events occur step first one accepted resets state reinitialization complete second one becomes unable find way give context rather large tried patch works unfortunately breaks unit tests,get bug event handling track  events occur step first one accepted resets state reinitialization complete second one becomes unable find way give context rather large tried patch works unfortunately breaks unit tests,get bug event handling track events occur step first one accepted resets state reinitialization complete second one becomes unable find way give context rather large tried patch works unfortunately breaks unit tests,1
0,Math,Statistics setVarianceImpl makes getStandardDeviation produce NaN,Invoking SummaryStatistics setVarianceImpl new Variance true false makes getStandardDeviation produce NaN code reproduce int scores 1 2 3 4 SummaryStatistics stats new SummaryStatistics stats setVarianceImpl new Variance false use population variance int scores stats addValue double sd stats getStandardDeviation System println sd workaround suggested Mikkel double sd FastMath sqrt stats getSecondMoment stats getN,Invoking SummaryStatistics setVarianceImpl new Variance true false makes getStandardDeviation produce NaN code reproduce int scores     SummaryStatistics stats new SummaryStatistics stats setVarianceImpl new Variance false use population variance int scores stats addValue double sd stats getStandardDeviation System println sd workaround suggested Mikkel double sd FastMath sqrt stats getSecondMoment stats getN,Invoking SummaryStatistics setVarianceImpl new Variance true false makes getStandardDeviation produce NaN code reproduce int scores SummaryStatistics stats new SummaryStatistics stats setVarianceImpl new Variance false use population variance int scores stats addValue double sd stats getStandardDeviation System println sd workaround suggested Mikkel double sd FastMath sqrt stats getSecondMoment stats getN,1
0,Math,Simplex Solver arrives incorrect solution,reduced problem reported minimal test case attach,reduced problem reported minimal test case attach,reduced problem reported minimal test case attach,1
0,Math,Errors BOBYQAOptimizer numberOfInterpolationPoints greater 2 dim 1,trouble getting BOBYQA minimize function actually non linear least squares fit one change increased number interpolation points seems anything larger 2 dim 1 causes error typically line 1662 interpolationPoints setEntry nfm ipt interpolationPoints getEntry ipt ipt guessing one error translation FORTRAN Changing BOBYQAOptimizerTest follows increasing number interpolation points one cause failures Bruce Index src test java org apache commons math optimization direct BOBYQAOptimizerTest java src test java org apache commons math optimization direct BOBYQAOptimizerTest java revision 1221065 src test java org apache commons math optimization direct BOBYQAOptimizerTest java working copy 258 7 258 7 RealPointValuePair result optim optimize 100000 func goal startPoint final double lB boundaries null null boundaries 0 final double uB boundaries null null boundaries 1 BOBYQAOptimizer optim new BOBYQAOptimizer 2 dim 1 BOBYQAOptimizer optim new BOBYQAOptimizer 2 dim 2 RealPointValuePair result optim optimize maxEvaluations func goal startPoint lB uB System println func getClass getName optim getEvaluations f,trouble getting BOBYQA minimize function actually non linear least squares fit one change increased number interpolation points seems anything larger  dim  causes error typically line  interpolationPoints setEntry nfm ipt interpolationPoints getEntry ipt ipt guessing one error translation FORTRAN Changing BOBYQAOptimizerTest follows increasing number interpolation points one cause failures Bruce Index src test java org apache commons math optimization direct BOBYQAOptimizerTest java src test java org apache commons math optimization direct BOBYQAOptimizerTest java revision  src test java org apache commons math optimization direct BOBYQAOptimizerTest java working copy     RealPointValuePair result optim optimize  func goal startPoint final double lB boundaries null null boundaries  final double uB boundaries null null boundaries  BOBYQAOptimizer optim new BOBYQAOptimizer  dim  BOBYQAOptimizer optim new BOBYQAOptimizer  dim  RealPointValuePair result optim optimize maxEvaluations func goal startPoint lB uB System println func getClass getName optim getEvaluations f,trouble getting BOBYQA minimize function actually non linear least squares fit one change increased number interpolation points seems anything larger dim causes error typically line interpolationPoints setEntry nfm ipt interpolationPoints getEntry ipt ipt guessing one error translation FORTRAN Changing BOBYQAOptimizerTest follows increasing number interpolation points one cause failures Bruce Index src test java org apache commons math optimization direct BOBYQAOptimizerTest java src test java org apache commons math optimization direct BOBYQAOptimizerTest java revision src test java org apache commons math optimization direct BOBYQAOptimizerTest java working copy RealPointValuePair result optim optimize func goal startPoint final double lB boundaries null null boundaries final double uB boundaries null null boundaries BOBYQAOptimizer optim new BOBYQAOptimizer dim BOBYQAOptimizer optim new BOBYQAOptimizer dim RealPointValuePair result optim optimize maxEvaluations func goal startPoint lB uB System println func getClass getName optim getEvaluations f,1
0,Math,BigFraction doubleValue returns Double NaN large numerators denominators,current implementation doubleValue divides numerator doubleValue denominator doubleValue BigInteger doubleValue fails number greater Double MAX VALUE user 308 digit numerator denominator resulting quotient fails even cases result would well inside Double range patch fix figure attach,current implementation doubleValue divides numerator doubleValue denominator doubleValue BigInteger doubleValue fails number greater Double MAX VALUE user  digit numerator denominator resulting quotient fails even cases result would well inside Double range patch fix figure attach,current implementation doubleValue divides numerator doubleValue denominator doubleValue BigInteger doubleValue fails number greater Double MAX VALUE user digit numerator denominator resulting quotient fails even cases result would well inside Double range patch fix figure attach,1
0,Math,inverseCumulativeProbability BinomialDistribution returns wrong value large trials,inverseCumulativeProbability method BinomialDistributionImpl class returns wrong value large trials Following code reproduce problem System println new BinomialDistributionImpl 1000000 0 5 inverseCumulativeProbability 0 5 returns 499525 though 499999 sure fixed cause cumulativeProbability method returns Infinity NaN result checkedCumulativeProbability method work expected,inverseCumulativeProbability method BinomialDistributionImpl class returns wrong value large trials Following code reproduce problem System println new BinomialDistributionImpl    inverseCumulativeProbability   returns  though  sure fixed cause cumulativeProbability method returns Infinity NaN result checkedCumulativeProbability method work expected,inverseCumulativeProbability method BinomialDistributionImpl class returns wrong value large trials Following code reproduce problem System println new BinomialDistributionImpl inverseCumulativeProbability returns though sure fixed cause cumulativeProbability method returns Infinity NaN result checkedCumulativeProbability method work expected,1
0,Math,Fraction comparTo returns 0 differente fractions,two different fractions evaluate double due limited precision compareTo methode returns 0 identical value roughly PI 3 07e 18 Fraction pi1 new Fraction 1068966896 340262731 value roughly PI 1 936e 17 Fraction pi2 new Fraction 411557987 131002976 System println pi1 doubleValue pi2 doubleValue exactly 0 0 due limited IEEE754 precision System println pi1 compareTo pi2 display 0 instead negative value,two different fractions evaluate double due limited precision compareTo methode returns  identical value roughly PI  e  Fraction pi new Fraction   value roughly PI  e  Fraction pi new Fraction   System println pi doubleValue pi doubleValue exactly   due limited IEEE precision System println pi compareTo pi display  instead negative value,two different fractions evaluate double due limited precision compareTo methode returns identical value roughly PI e Fraction pi new Fraction value roughly PI e Fraction pi new Fraction System println pi doubleValue pi doubleValue exactly due limited IEEE precision System println pi compareTo pi display instead negative value,1
0,Math,weight versus sigma AbstractLeastSquares,AbstractLeastSquares residualsWeights contains WEIGHTS assigned observation method getRMS weights multiplicative unlike getChiSquare appears denominator weight really weight observation multiply square residual even computation chi2 corrected getRMS even reduce public double getRMS return Math sqrt getChiSquare rows,AbstractLeastSquares residualsWeights contains WEIGHTS assigned observation method getRMS weights multiplicative unlike getChiSquare appears denominator weight really weight observation multiply square residual even computation chi corrected getRMS even reduce public double getRMS return Math sqrt getChiSquare rows,AbstractLeastSquares residualsWeights contains WEIGHTS assigned observation method getRMS weights multiplicative unlike getChiSquare appears denominator weight really weight observation multiply square residual even computation chi corrected getRMS even reduce public double getRMS return Math sqrt getChiSquare rows,1
0,Math,Miscellaneous issues concerning optimization package,Revision 990792 contains changes triggered following issues MATH 394 MATH 397 MATH 404 issue collects currently still unsatisfactory code necessarily sorted order annoyance BrentOptimizer specific convergence checker must used LevenbergMarquardtOptimizer also specific convergence checks Trying make convergence checking independent optimization algorithm creates problems conceptual practical See BrentOptimizer LevenbergMarquardtOptimizer algorithm passes points convergence checker actual meaning points well different caller optimization algorithm callee convergence checker PowellOptimizer line search BrentOptimizer tolerances depend tolerances within main algorithm Since tolerances come ConvergenceChecker changed time awkward adapt values within line search optimizer without exposing internals BrentOptimizer field enclosing class PowellOptimizer Given numerous changes Javadoc comments might sync although try update Class DirectSearchOptimizer package optimization direct inherits class AbstractScalarOptimizer package optimization general interfaces defined package optimization base implementations abstract class contain boiler plate code package optimization general e g DifferentiableMultivariateVectorialOptimizer BaseAbstractVectorialOptimizer check performed ensure convergence checker set see e g BrentOptimizer PowellOptimizer NPE alternative initialize default checker never used case user intended explicitly sets checker NonLinearConjugateGradientOptimizer Ugly workaround checked ConvergenceException Everywhere trail checked FunctionEvaluationException although never used remains duplicate code multi start loop various MultiStart implementations ConvergenceChecker interface general converged method take number PointValuePair However remains semantic problem One cannot sure list points means thing caller converged within implementation ConvergenceChecker independently set clear whether wise aggregate counter gradient evaluations function evaluation counter LevenbergMarquartdOptimizer example would unfair Currently remove tests referring gradient Jacobian evaluations AbstractLeastSquaresOptimizer LevenbergMarquardtOptimizer occurences OptimizationException replaced unchecked ConvergenceException cases might appropriate one MultiStartUnivariateRealOptimizer classes MultiStartMultivariate similar one randomization firts guess value class search interval think also randomly choose start value within user selected interval Javadoc utility raises warnings see output mvn site figure correct previously existing classes interfaces become specialisation new generics classes might interesting remove order reduce number classes thus limit potential confusion,Revision  contains changes triggered following issues MATH  MATH  MATH  issue collects currently still unsatisfactory code necessarily sorted order annoyance BrentOptimizer specific convergence checker must used LevenbergMarquardtOptimizer also specific convergence checks Trying make convergence checking independent optimization algorithm creates problems conceptual practical See BrentOptimizer LevenbergMarquardtOptimizer algorithm passes points convergence checker actual meaning points well different caller optimization algorithm callee convergence checker PowellOptimizer line search BrentOptimizer tolerances depend tolerances within main algorithm Since tolerances come ConvergenceChecker changed time awkward adapt values within line search optimizer without exposing internals BrentOptimizer field enclosing class PowellOptimizer Given numerous changes Javadoc comments might sync although try update Class DirectSearchOptimizer package optimization direct inherits class AbstractScalarOptimizer package optimization general interfaces defined package optimization base implementations abstract class contain boiler plate code package optimization general e g DifferentiableMultivariateVectorialOptimizer BaseAbstractVectorialOptimizer check performed ensure convergence checker set see e g BrentOptimizer PowellOptimizer NPE alternative initialize default checker never used case user intended explicitly sets checker NonLinearConjugateGradientOptimizer Ugly workaround checked ConvergenceException Everywhere trail checked FunctionEvaluationException although never used remains duplicate code multi start loop various MultiStart implementations ConvergenceChecker interface general converged method take number PointValuePair However remains semantic problem One cannot sure list points means thing caller converged within implementation ConvergenceChecker independently set clear whether wise aggregate counter gradient evaluations function evaluation counter LevenbergMarquartdOptimizer example would unfair Currently remove tests referring gradient Jacobian evaluations AbstractLeastSquaresOptimizer LevenbergMarquardtOptimizer occurences OptimizationException replaced unchecked ConvergenceException cases might appropriate one MultiStartUnivariateRealOptimizer classes MultiStartMultivariate similar one randomization firts guess value class search interval think also randomly choose start value within user selected interval Javadoc utility raises warnings see output mvn site figure correct previously existing classes interfaces become specialisation new generics classes might interesting remove order reduce number classes thus limit potential confusion,Revision contains changes triggered following issues MATH MATH MATH issue collects currently still unsatisfactory code necessarily sorted order annoyance BrentOptimizer specific convergence checker must used LevenbergMarquardtOptimizer also specific convergence checks Trying make convergence checking independent optimization algorithm creates problems conceptual practical See BrentOptimizer LevenbergMarquardtOptimizer algorithm passes points convergence checker actual meaning points well different caller optimization algorithm callee convergence checker PowellOptimizer line search BrentOptimizer tolerances depend tolerances within main algorithm Since tolerances come ConvergenceChecker changed time awkward adapt values within line search optimizer without exposing internals BrentOptimizer field enclosing class PowellOptimizer Given numerous changes Javadoc comments might sync although try update Class DirectSearchOptimizer package optimization direct inherits class AbstractScalarOptimizer package optimization general interfaces defined package optimization base implementations abstract class contain boiler plate code package optimization general e g DifferentiableMultivariateVectorialOptimizer BaseAbstractVectorialOptimizer check performed ensure convergence checker set see e g BrentOptimizer PowellOptimizer NPE alternative initialize default checker never used case user intended explicitly sets checker NonLinearConjugateGradientOptimizer Ugly workaround checked ConvergenceException Everywhere trail checked FunctionEvaluationException although never used remains duplicate code multi start loop various MultiStart implementations ConvergenceChecker interface general converged method take number PointValuePair However remains semantic problem One cannot sure list points means thing caller converged within implementation ConvergenceChecker independently set clear whether wise aggregate counter gradient evaluations function evaluation counter LevenbergMarquartdOptimizer example would unfair Currently remove tests referring gradient Jacobian evaluations AbstractLeastSquaresOptimizer LevenbergMarquardtOptimizer occurences OptimizationException replaced unchecked ConvergenceException cases might appropriate one MultiStartUnivariateRealOptimizer classes MultiStartMultivariate similar one randomization firts guess value class search interval think also randomly choose start value within user selected interval Javadoc utility raises warnings see output mvn site figure correct previously existing classes interfaces become specialisation new generics classes might interesting remove order reduce number classes thus limit potential confusion,1
0,Math,Result multiplying equals complex numbers wrong,Hi bug relates complex numbers methods multiply equals class Complex involved mathematic background 0 1 0i 0 little java program output shows bug import org apache commons math complex public class TestProg public static void main String args ComplexFormat f new ComplexFormat Complex c1 new Complex 0 1 Complex c2 new Complex 1 0 Complex res c1 multiply c2 Complex comp new Complex 0 1 System println res f format res System println comp f format comp System println res comp res equals comp res 0 1i comp 0 1i res comp false think equals return true problem could either multiply method gives 0 1i instead 0 1i think thats right equals method modified Good Luck Dieter,Hi bug relates complex numbers methods multiply equals class Complex involved mathematic background   i  little java program output shows bug import org apache commons math complex public class TestProg public static void main String args ComplexFormat f new ComplexFormat Complex c new Complex   Complex c new Complex   Complex res c multiply c Complex comp new Complex   System println res f format res System println comp f format comp System println res comp res equals comp res  i comp  i res comp false think equals return true problem could either multiply method gives  i instead  i think thats right equals method modified Good Luck Dieter,Hi bug relates complex numbers methods multiply equals class Complex involved mathematic background little java program output shows bug import org apache commons math complex public class TestProg public static void main String args ComplexFormat f new ComplexFormat Complex c new Complex Complex c new Complex Complex res c multiply c Complex comp new Complex System println res f format res System println comp f format comp System println res comp res equals comp res comp res comp false think equals return true problem could either multiply method gives instead think thats right equals method modified Good Luck Dieter,1
0,Math,AbstractEstimator getCovariances guessParametersErrors crash bound parameters,two methods getCovariances guessParametersErrors org apache commons math estimation AbstractEstimator crash ArrayOutOfBounds exception parameters bound reason Jacobian calculated unbound parameters code loop parameters line 166 final int cols problem getAllParameters length replaced final int cols problem getUnboundParameters length similar changes could done guessParametersErrors dissadvantage bug fix returned user array smaller size number parameters Alternatively logic code writes zeros elements covariance matrix corresponding bound parameters,two methods getCovariances guessParametersErrors org apache commons math estimation AbstractEstimator crash ArrayOutOfBounds exception parameters bound reason Jacobian calculated unbound parameters code loop parameters line  final int cols problem getAllParameters length replaced final int cols problem getUnboundParameters length similar changes could done guessParametersErrors dissadvantage bug fix returned user array smaller size number parameters Alternatively logic code writes zeros elements covariance matrix corresponding bound parameters,two methods getCovariances guessParametersErrors org apache commons math estimation AbstractEstimator crash ArrayOutOfBounds exception parameters bound reason Jacobian calculated unbound parameters code loop parameters line final int cols problem getAllParameters length replaced final int cols problem getUnboundParameters length similar changes could done guessParametersErrors dissadvantage bug fix returned user array smaller size number parameters Alternatively logic code writes zeros elements covariance matrix corresponding bound parameters,1
0,Math,class Dfp toDouble method return inf whan Dfp value 0 zero,found bug toDouble method Dfp class Dfp value 0 zero toDouble method returns negative infini double value returned exposant equal 0xFFF significand equal 0 IEEE754 inf equal zero exposant significand must equal zero simple test case import org apache commons math dfp DfpField public class test param args public static void main String args DfpField field new DfpField 100 System println toDouble value getZero field getZero toDouble \ntoDouble value newDfp 0 0 field newDfp 0 0 toDouble May simplest way fix test zero equality begin toDouble method able return correctly signed zero,found bug toDouble method Dfp class Dfp value  zero toDouble method returns negative infini double value returned exposant equal xFFF significand equal  IEEE inf equal zero exposant significand must equal zero simple test case import org apache commons math dfp DfpField public class test param args public static void main String args DfpField field new DfpField  System println toDouble value getZero field getZero toDouble \ntoDouble value newDfp   field newDfp   toDouble May simplest way fix test zero equality begin toDouble method able return correctly signed zero,found bug toDouble method Dfp class Dfp value zero toDouble method returns negative infini double value returned exposant equal xFFF significand equal IEEE inf equal zero exposant significand must equal zero simple test case import org apache commons math dfp DfpField public class test param args public static void main String args DfpField field new DfpField System println toDouble value getZero field getZero toDouble \ntoDouble value newDfp field newDfp toDouble May simplest way fix test zero equality begin toDouble method able return correctly signed zero,1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line 640 RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line  RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line RealMatrixImpl java read double new double nRows instead double new double v length,1
0,Math,Complex Add Subtract handle NaN arguments differently javadoc contracts,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back 1 1,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back  ,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back,1
0,Math,Mann Whitney U Test Suffers Integer Overflow Large Data Sets,performing Mann Whitney U Test large data sets attached test uses two 1500 element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,performing Mann Whitney U Test large data sets attached test uses two  element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,performing Mann Whitney U Test large data sets attached test uses two element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,1
0,Math,math Complex Tanh big numbers,Hi Complex java tanh computed following formula tanh bi sinh 2a cosh 2a cos 2b sin 2b cosh 2a cos 2b problem finding soon big number sinh 2a cosh 2a infinity method tanh returns real part NaN infinity infinity return 1 0 appropiate add something FastMath library real 20 0 return createComplex 1 0 0 0 real 20 0 return createComplex 1 0 0 0 Best regards JBB,Hi Complex java tanh computed following formula tanh bi sinh a cosh a cos b sin b cosh a cos b problem finding soon big number sinh a cosh a infinity method tanh returns real part NaN infinity infinity return   appropiate add something FastMath library real   return createComplex     real   return createComplex     Best regards JBB,Hi Complex java tanh computed following formula tanh bi sinh cosh cos b sin b cosh cos b problem finding soon big number sinh cosh infinity method tanh returns real part NaN infinity infinity return appropiate add something FastMath library real return createComplex real return createComplex Best regards JBB,1
0,Math,large first step embedded Runge Kutta integrators Dormand Prince 8 5 3,Adaptive step size integrators compute first step size provided embedded Runge Kutta type step size checked integration range integration range extremely short step size may evaluate function range fact tries afterward go back fails stop Gragg Bulirsch Stoer integrators problem step size checked truncated needed,Adaptive step size integrators compute first step size provided embedded Runge Kutta type step size checked integration range integration range extremely short step size may evaluate function range fact tries afterward go back fails stop Gragg Bulirsch Stoer integrators problem step size checked truncated needed,Adaptive step size integrators compute first step size provided embedded Runge Kutta type step size checked integration range integration range extremely short step size may evaluate function range fact tries afterward go back fails stop Gragg Bulirsch Stoer integrators problem step size checked truncated needed,1
0,Math,math Function math fraction ProperFractionFormat parse String ParsePosition return illogical result,Hello find illogical returned result function Fraction parse String source ParsePostion pos class ProperFractionFormat Fraction Package Commons Math library Please see following code segment details ProperFractionFormat properFormat new ProperFractionFormat result null String source 1 1 2 ParsePosition pos new ParsePosition 0 Test 1 fail public void testParseNegative String source 1 2 3 ParsePosition pos new ParsePosition 0 Fraction actual properFormat parse source pos assertNull actual Test2 success public void testParseNegative String source 1 2 3 ParsePosition pos new ParsePosition 0 Fraction actual properFormat parse source pos return Fraction 1 3 assertEquals 1 source getNumerator assertEquals 3 source getDenominator Note Similarly passed following inputs input 2 source 1 2 3 pos 0 input 3 source 1 2 3 pos 0 Function Fraction parse String ParsePosition returned Fraction 1 3 means result Fraction numerator 1 denominator 3 3 inputs think function handle parsing numberator denominator properly incase input string provide invalid numerator denominator Thank,Hello find illogical returned result function Fraction parse String source ParsePostion pos class ProperFractionFormat Fraction Package Commons Math library Please see following code segment details ProperFractionFormat properFormat new ProperFractionFormat result null String source    ParsePosition pos new ParsePosition  Test  fail public void testParseNegative String source    ParsePosition pos new ParsePosition  Fraction actual properFormat parse source pos assertNull actual Test success public void testParseNegative String source    ParsePosition pos new ParsePosition  Fraction actual properFormat parse source pos return Fraction   assertEquals  source getNumerator assertEquals  source getDenominator Note Similarly passed following inputs input  source    pos  input  source    pos  Function Fraction parse String ParsePosition returned Fraction   means result Fraction numerator  denominator   inputs think function handle parsing numberator denominator properly incase input string provide invalid numerator denominator Thank,Hello find illogical returned result function Fraction parse String source ParsePostion pos class ProperFractionFormat Fraction Package Commons Math library Please see following code segment details ProperFractionFormat properFormat new ProperFractionFormat result null String source ParsePosition pos new ParsePosition Test fail public void testParseNegative String source ParsePosition pos new ParsePosition Fraction actual properFormat parse source pos assertNull actual Test success public void testParseNegative String source ParsePosition pos new ParsePosition Fraction actual properFormat parse source pos return Fraction assertEquals source getNumerator assertEquals source getDenominator Note Similarly passed following inputs input source pos input source pos Function Fraction parse String ParsePosition returned Fraction means result Fraction numerator denominator inputs think function handle parsing numberator denominator properly incase input string provide invalid numerator denominator Thank,1
0,Math,MathUtils gcd Integer MIN VALUE 0 throw Exception instead returning Integer MIN VALUE,gcd method throw Exception gcd Integer MIN VALUE 0 like gcd Integer MIN VALUE Integer MIN VALUE method return nonnegative results,gcd method throw Exception gcd Integer MIN VALUE  like gcd Integer MIN VALUE Integer MIN VALUE method return nonnegative results,gcd method throw Exception gcd Integer MIN VALUE like gcd Integer MIN VALUE Integer MIN VALUE method return nonnegative results,1
0,Math,numerical problems rotation creation,building rotation following vector pairs leads NaN u1 4921140 837095533 2 1512094250440013E7 890093 279426377 u2 2 7238580938724895E9 2 169664921341876E9 6 749688708885301E10 v1 1 0 0 v2 0 0 1 constructor first changes v1 v2 pair v1 v2 ensuring following scalar products hold v1 |v1 u1|u1 v2 |v2 u2|u2 u1 |u2 v1 |v2 v1 v2 pair computed compute cross product k v1 u1 v2 u2 scalar product c k | u1 u2 construction c positive null quaternion axis want build q k 2 sqrt c c null vectors aligned dealt later algorithm However numerical problems vector way computations done shown following comparisons showing result get Java code result get manual computation formulas enhanced precision commons math k 38514476 5 84 1168590144 high precision k 38514410 36093388 0 374075245201180409222711 1168590152 10599715208 becomes worse computing c vectors almost orthogonal hence inducing additional cancellations get commons math c 1 2397173627587605E20 high precision c 558382746168463196 7079627 lost significant digits cancellations even sign wrong,building rotation following vector pairs leads NaN u    E   u  E  E  E v    v    constructor first changes v v pair v v ensuring following scalar products hold v |v u|u v |v u|u u |u v |v v v pair computed compute cross product k v u v u scalar product c k | u u construction c positive null quaternion axis want build q k  sqrt c c null vectors aligned dealt later algorithm However numerical problems vector way computations done shown following comparisons showing result get Java code result get manual computation formulas enhanced precision commons math k     high precision k       becomes worse computing c vectors almost orthogonal hence inducing additional cancellations get commons math c  E high precision c   lost significant digits cancellations even sign wrong,building rotation following vector pairs leads NaN u E u E E E v v constructor first changes v v pair v v ensuring following scalar products hold v |v u|u v |v u|u u |u v |v v v pair computed compute cross product k v u v u scalar product c k | u u construction c positive null quaternion axis want build q k sqrt c c null vectors aligned dealt later algorithm However numerical problems vector way computations done shown following comparisons showing result get Java code result get manual computation formulas enhanced precision commons math k high precision k becomes worse computing c vectors almost orthogonal hence inducing additional cancellations get commons math c E high precision c lost significant digits cancellations even sign wrong,1
0,Math,java lang StringIndexOutOfBoundsException ComplexFormat parse String source ParsePosition pos,parse String source ParsePosition pos method ComplexFormat class check whether imaginary character set produces StringIndexOutOfBoundsException substring method line 375 ComplexFormat parse imaginary character int n getImaginaryCharacter length startIndex pos getIndex int endIndex startIndex n source substring startIndex endIndex compareTo getImaginaryCharacter 0 encoutered exception typing JTextFied ComplexFormat set look AbstractFormatter user types imaginary part complex number first gets exception Solution setting n length imaginary character check source contains proposal int n 0 source contains getImaginaryCharacter n getImaginaryCharacter length F,parse String source ParsePosition pos method ComplexFormat class check whether imaginary character set produces StringIndexOutOfBoundsException substring method line  ComplexFormat parse imaginary character int n getImaginaryCharacter length startIndex pos getIndex int endIndex startIndex n source substring startIndex endIndex compareTo getImaginaryCharacter  encoutered exception typing JTextFied ComplexFormat set look AbstractFormatter user types imaginary part complex number first gets exception Solution setting n length imaginary character check source contains proposal int n  source contains getImaginaryCharacter n getImaginaryCharacter length F,parse String source ParsePosition pos method ComplexFormat class check whether imaginary character set produces StringIndexOutOfBoundsException substring method line ComplexFormat parse imaginary character int n getImaginaryCharacter length startIndex pos getIndex int endIndex startIndex n source substring startIndex endIndex compareTo getImaginaryCharacter encoutered exception typing JTextFied ComplexFormat set look AbstractFormatter user types imaginary part complex number first gets exception Solution setting n length imaginary character check source contains proposal int n source contains getImaginaryCharacter n getImaginaryCharacter length F,1
0,Math,Vector3D crossProduct sensitive numerical cancellation,Cross product implementation uses naive formulas y1 z2 y2 z1 formulas fail vectors almost colinear like following example Vector3D v1 new Vector3D 9070467121 0 4535233560 0 1 Vector3D v2 new Vector3D 9070467123 0 4535233561 0 1 System println Vector3D crossProduct v1 v2 previous code displays 1 2 0 instead correct answer 1 2 1,Cross product implementation uses naive formulas y z y z formulas fail vectors almost colinear like following example VectorD v new VectorD      VectorD v new VectorD      System println VectorD crossProduct v v previous code displays    instead correct answer   ,Cross product implementation uses naive formulas z z formulas fail vectors almost colinear like following example VectorD v new VectorD VectorD v new VectorD System println VectorD crossProduct v v previous code displays instead correct answer,1
0,Math,BrentSolver throws IllegalArgumentException,getting exception java lang IllegalArgumentException Function values endpoints different signs Endpoints 100000 0 1 7976931348623157E308 Values 0 0 101945 04630982173 org apache commons math analysis BrentSolver solve BrentSolver java 99 org apache commons math analysis BrentSolver solve BrentSolver java 62 exception thrown values 0 0 101945 04630982173 0 0 positive According Brent Worden algorithm stop return 0 root instead throwing exception problem comes method public double solve double min double max throws MaxIterationsExceededException FunctionEvaluationException clearResult verifyInterval min max double yMin f value min double yMax f value max Verify bracketing yMin yMax 0 throw new IllegalArgumentException Function values endpoints different signs Endpoints min max Values yMin yMax solve using first endpoint initial guess return solve min yMin max yMax min yMin One way fix would add code assignment yMin yMax yMin 0 || yMax 0 return 0,getting exception java lang IllegalArgumentException Function values endpoints different signs Endpoints    E Values     org apache commons math analysis BrentSolver solve BrentSolver java  org apache commons math analysis BrentSolver solve BrentSolver java  exception thrown values       positive According Brent Worden algorithm stop return  root instead throwing exception problem comes method public double solve double min double max throws MaxIterationsExceededException FunctionEvaluationException clearResult verifyInterval min max double yMin f value min double yMax f value max Verify bracketing yMin yMax  throw new IllegalArgumentException Function values endpoints different signs Endpoints min max Values yMin yMax solve using first endpoint initial guess return solve min yMin max yMax min yMin One way fix would add code assignment yMin yMax yMin  || yMax  return ,getting exception java lang IllegalArgumentException Function values endpoints different signs Endpoints E Values org apache commons math analysis BrentSolver solve BrentSolver java org apache commons math analysis BrentSolver solve BrentSolver java exception thrown values positive According Brent Worden algorithm stop return root instead throwing exception problem comes method public double solve double min double max throws MaxIterationsExceededException FunctionEvaluationException clearResult verifyInterval min max double yMin f value min double yMax f value max Verify bracketing yMin yMax throw new IllegalArgumentException Function values endpoints different signs Endpoints min max Values yMin yMax solve using first endpoint initial guess return solve min yMin max yMax min yMin One way fix would add code assignment yMin yMax yMin || yMax return,1
0,Math,NaN equals methods,MathUtils equals methods return true argument NaN Unless mistaken contradicts IEEE standard nobody objects going make changes,MathUtils equals methods return true argument NaN Unless mistaken contradicts IEEE standard nobody objects going make changes,MathUtils equals methods return true argument NaN Unless mistaken contradicts IEEE standard nobody objects going make changes,1
0,Math,Inconsistent result Levenberg Marquardt,Levenberg Marquardt method doOptimize returns VectorialPointValuePair However class holds optimum point vector objective function cost residuals value returns doOptimize always corresponds point leads residuals cost,Levenberg Marquardt method doOptimize returns VectorialPointValuePair However class holds optimum point vector objective function cost residuals value returns doOptimize always corresponds point leads residuals cost,Levenberg Marquardt method doOptimize returns VectorialPointValuePair However class holds optimum point vector objective function cost residuals value returns doOptimize always corresponds point leads residuals cost,1
0,Math,Bugs Frequency API,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return 0 object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ 0 System println f getPct OBJ 0 0 Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return 0 Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return  object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ  System println f getPct OBJ   Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return  Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ System println f getPct OBJ Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return Exception applying instanceof fix would also cause fail,1
0,Math,Division zero,class Complex division zero always returns NaN think return NaN numerator also ZERO otherwise result INF See,class Complex division zero always returns NaN think return NaN numerator also ZERO otherwise result INF See,class Complex division zero always returns NaN think return NaN numerator also ZERO otherwise result INF See,1
0,Math,NPE KMeansPlusPlusClusterer unittest,running unittest facing NPE java lang NullPointerException org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java 91 unittest package org fao fisheries chronicles calcuation cluster import static org junit Assert assertEquals import static org junit Assert assertTrue import java util Arrays import java util List import java util Random import org apache commons math stat clustering Cluster import org apache commons math stat clustering EuclideanIntegerPoint import org apache commons math stat clustering KMeansPlusPlusClusterer import org fao fisheries chronicles input CsvImportProcess import org fao fisheries chronicles input Top200Csv import org junit Test public class ClusterAnalysisTest Test public void testPerformClusterAnalysis2 KMeansPlusPlusClusterer EuclideanIntegerPoint transformer new KMeansPlusPlusClusterer EuclideanIntegerPoint new Random 1746432956321l EuclideanIntegerPoint points new EuclideanIntegerPoint new EuclideanIntegerPoint new int 1959 325100 new EuclideanIntegerPoint new int 1960 373200 List Cluster EuclideanIntegerPoint clusters transformer cluster Arrays asList points 1 1 assertEquals 1 clusters size,running unittest facing NPE java lang NullPointerException org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java  unittest package org fao fisheries chronicles calcuation cluster import static org junit Assert assertEquals import static org junit Assert assertTrue import java util Arrays import java util List import java util Random import org apache commons math stat clustering Cluster import org apache commons math stat clustering EuclideanIntegerPoint import org apache commons math stat clustering KMeansPlusPlusClusterer import org fao fisheries chronicles input CsvImportProcess import org fao fisheries chronicles input TopCsv import org junit Test public class ClusterAnalysisTest Test public void testPerformClusterAnalysis KMeansPlusPlusClusterer EuclideanIntegerPoint transformer new KMeansPlusPlusClusterer EuclideanIntegerPoint new Random l EuclideanIntegerPoint points new EuclideanIntegerPoint new EuclideanIntegerPoint new int   new EuclideanIntegerPoint new int   List Cluster EuclideanIntegerPoint clusters transformer cluster Arrays asList points   assertEquals  clusters size,running unittest facing NPE java lang NullPointerException org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java unittest package org fao fisheries chronicles calcuation cluster import static org junit Assert assertEquals import static org junit Assert assertTrue import java util Arrays import java util List import java util Random import org apache commons math stat clustering Cluster import org apache commons math stat clustering EuclideanIntegerPoint import org apache commons math stat clustering KMeansPlusPlusClusterer import org fao fisheries chronicles input CsvImportProcess import org fao fisheries chronicles input TopCsv import org junit Test public class ClusterAnalysisTest Test public void testPerformClusterAnalysis KMeansPlusPlusClusterer EuclideanIntegerPoint transformer new KMeansPlusPlusClusterer EuclideanIntegerPoint new Random l EuclideanIntegerPoint points new EuclideanIntegerPoint new EuclideanIntegerPoint new int new EuclideanIntegerPoint new int List Cluster EuclideanIntegerPoint clusters transformer cluster Arrays asList points assertEquals clusters size,1
0,Math,One Variance evaluate methods work correctly,method org apache commons math stat descriptive moment Variance evaluate double values double weights double mean int begin int length work properly Looks loke ignores length parameter grabs whole dataset Similar method Mean class seems work check methods taking part array may problem Workaround shrink arrays use method without length,method org apache commons math stat descriptive moment Variance evaluate double values double weights double mean int begin int length work properly Looks loke ignores length parameter grabs whole dataset Similar method Mean class seems work check methods taking part array may problem Workaround shrink arrays use method without length,method org apache commons math stat descriptive moment Variance evaluate double values double weights double mean int begin int length work properly Looks loke ignores length parameter grabs whole dataset Similar method Mean class seems work check methods taking part array may problem Workaround shrink arrays use method without length,1
0,Math,SimplexSolver working expected,guess could wrong SimplexSolver always return optimal solution satisfies constraints Consider LP max 0 8 x0 0 2 x1 0 7 x2 0 3 x3 0 6 x4 0 4 x5 r1 x0 x2 x4 23 0 r2 x1 x3 x5 23 0 r3 x0 10 0 r4 x2 8 0 r5 x4 5 0 LPSolve returns 25 8 x0 10 0 x1 0 0 x2 8 0 x3 0 0 x4 5 0 x5 23 0 LP expressed Apache commons math LinearObjectiveFunction f new LinearObjectiveFunction new double 0 8 0 2 0 7 0 3 0 6 0 4 0 Collection LinearConstraint constraints new ArrayList LinearConstraint constraints add new LinearConstraint new double 1 0 1 0 1 0 Relationship EQ 23 0 constraints add new LinearConstraint new double 0 1 0 1 0 1 Relationship EQ 23 0 constraints add new LinearConstraint new double 1 0 0 0 0 0 Relationship GEQ 10 0 constraints add new LinearConstraint new double 0 0 1 0 0 0 Relationship GEQ 8 0 constraints add new LinearConstraint new double 0 0 0 0 1 0 Relationship GEQ 5 0 RealPointValuePair solution new SimplexSolver optimize f constraints GoalType MAXIMIZE true returns 22 20 x0 15 0 x1 23 0 x2 8 0 x3 0 0 x4 0 0 x5 0 0 possible SimplexSolver buggy way returned value 22 20 instead 25 8 last constraint x4 5 0 satisfied using interface wrongly,guess could wrong SimplexSolver always return optimal solution satisfies constraints Consider LP max   x   x   x   x   x   x r x x x   r x x x   r x   r x   r x   LPSolve returns   x   x   x   x   x   x   LP expressed Apache commons math LinearObjectiveFunction f new LinearObjectiveFunction new double              Collection LinearConstraint constraints new ArrayList LinearConstraint constraints add new LinearConstraint new double       Relationship EQ   constraints add new LinearConstraint new double       Relationship EQ   constraints add new LinearConstraint new double       Relationship GEQ   constraints add new LinearConstraint new double       Relationship GEQ   constraints add new LinearConstraint new double       Relationship GEQ   RealPointValuePair solution new SimplexSolver optimize f constraints GoalType MAXIMIZE true returns   x   x   x   x   x   x   possible SimplexSolver buggy way returned value   instead   last constraint x   satisfied using interface wrongly,guess could wrong SimplexSolver always return optimal solution satisfies constraints Consider LP max x x x x x x r x x x r x x x r x r x r x LPSolve returns x x x x x x LP expressed Apache commons math LinearObjectiveFunction f new LinearObjectiveFunction new double Collection LinearConstraint constraints new ArrayList LinearConstraint constraints add new LinearConstraint new double Relationship EQ constraints add new LinearConstraint new double Relationship EQ constraints add new LinearConstraint new double Relationship GEQ constraints add new LinearConstraint new double Relationship GEQ constraints add new LinearConstraint new double Relationship GEQ RealPointValuePair solution new SimplexSolver optimize f constraints GoalType MAXIMIZE true returns x x x x x x possible SimplexSolver buggy way returned value instead last constraint x satisfied using interface wrongly,1
0,Math,getLInfNorm uses wrong formula ArrayRealVector OpenMapRealVector different ways,L infinity norm finite dimensional vector max absolute value entries current implementation ArrayRealVector typo public double getLInfNorm double max 0 double data max Math max max Math abs return max sadly unit test assuring us correct behavior effectively regression test test correctness Worse implementation OpenMapRealVector even positive semi definite public double getLInfNorm double max 0 Iterator iter entries iterator iter hasNext iter advance max iter value return max would suggest method moved AbstractRealVector superclass implemented using sparseIterator public double getLInfNorm double norm 0 Iterator Entry sparseIterator Entry e hasNext e next null norm Math max norm Math abs e getValue return norm Unit tests negative valued vectors would helpful check kind thing future,L infinity norm finite dimensional vector max absolute value entries current implementation ArrayRealVector typo public double getLInfNorm double max  double data max Math max max Math abs return max sadly unit test assuring us correct behavior effectively regression test test correctness Worse implementation OpenMapRealVector even positive semi definite public double getLInfNorm double max  Iterator iter entries iterator iter hasNext iter advance max iter value return max would suggest method moved AbstractRealVector superclass implemented using sparseIterator public double getLInfNorm double norm  Iterator Entry sparseIterator Entry e hasNext e next null norm Math max norm Math abs e getValue return norm Unit tests negative valued vectors would helpful check kind thing future,L infinity norm finite dimensional vector max absolute value entries current implementation ArrayRealVector typo public double getLInfNorm double max double data max Math max max Math abs return max sadly unit test assuring us correct behavior effectively regression test test correctness Worse implementation OpenMapRealVector even positive semi definite public double getLInfNorm double max Iterator iter entries iterator iter hasNext iter advance max iter value return max would suggest method moved AbstractRealVector superclass implemented using sparseIterator public double getLInfNorm double norm Iterator Entry sparseIterator Entry e hasNext e next null norm Math max norm Math abs e getValue return norm Unit tests negative valued vectors would helpful check kind thing future,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Math,MultiDirectional optimzation loops forver started correct solution,MultiDirectional iterateSimplex loops forever starting point correct solution see attached test case testMultiDirectionalCorrectStart example,MultiDirectional iterateSimplex loops forever starting point correct solution see attached test case testMultiDirectionalCorrectStart example,MultiDirectional iterateSimplex loops forever starting point correct solution see attached test case testMultiDirectionalCorrectStart example,1
0,Math,BrentOptimizer always reporting best point,BrentOptimizer package c optimization univariate check point going return indeed best one encountered Indeed last evaluated point might slightly worse one last,BrentOptimizer package c optimization univariate check point going return indeed best one encountered Indeed last evaluated point might slightly worse one last,BrentOptimizer package c optimization univariate check point going return indeed best one encountered Indeed last evaluated point might slightly worse one last,1
0,Math,BrentOptimizer always reporting best point,BrentOptimizer package c optimization univariate check point going return indeed best one encountered Indeed last evaluated point might slightly worse one last,BrentOptimizer package c optimization univariate check point going return indeed best one encountered Indeed last evaluated point might slightly worse one last,BrentOptimizer package c optimization univariate check point going return indeed best one encountered Indeed last evaluated point might slightly worse one last,1
0,Math,NPE calling SubLine intersection non intersecting lines,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,1
0,Math,FastMath pow deviates Math pow negative finite base values exponent 2 52 2 53,reported Jeff Hain pow double double Math pow 1 0 5 000000000000001E15 1 0 FastMath pow 1 0 5 000000000000001E15 1 0 due considering power even integer 2 52 need test 2 53 replace TWO POWER 52 || TWO POWER 52 2 TWO POWER 52 || 2 TWO POWER 52 solves,reported Jeff Hain pow double double Math pow    E   FastMath pow    E   due considering power even integer   need test   replace TWO POWER  || TWO POWER   TWO POWER  ||  TWO POWER  solves,reported Jeff Hain pow double double Math pow E FastMath pow E due considering power even integer need test replace TWO POWER || TWO POWER TWO POWER || TWO POWER solves,1
0,Math,ArrayIndexOutOfBoundsException MathArrays linearCombination,MathArrays linearCombination passed arguments length 1 throws ArrayOutOfBoundsException caused line double prodHighNext prodHigh 1 linearCombination check length arguments fall back simple multiplication length 1,MathArrays linearCombination passed arguments length  throws ArrayOutOfBoundsException caused line double prodHighNext prodHigh  linearCombination check length arguments fall back simple multiplication length ,MathArrays linearCombination passed arguments length throws ArrayOutOfBoundsException caused line double prodHighNext prodHigh linearCombination check length arguments fall back simple multiplication length,1
0,Math,GammaDistribution cloning broken,Serializing GammaDistribution deserializing result cloned distribution produces samples Cause GammaDistribution inherits AbstractRealDistribution implements Serializable AbstractRealDistribution random Well19937c instance inherits AbstractWell AbstractWell implements Serializable AbstractWell inherits BitsStreamGenerator Serializable private field nextGaussian Solution Make BitStreamGenerator implement Serializable well probably affects distributions well,Serializing GammaDistribution deserializing result cloned distribution produces samples Cause GammaDistribution inherits AbstractRealDistribution implements Serializable AbstractRealDistribution random Wellc instance inherits AbstractWell AbstractWell implements Serializable AbstractWell inherits BitsStreamGenerator Serializable private field nextGaussian Solution Make BitStreamGenerator implement Serializable well probably affects distributions well,Serializing GammaDistribution deserializing result cloned distribution produces samples Cause GammaDistribution inherits AbstractRealDistribution implements Serializable AbstractRealDistribution random Wellc instance inherits AbstractWell AbstractWell implements Serializable AbstractWell inherits BitsStreamGenerator Serializable private field nextGaussian Solution Make BitStreamGenerator implement Serializable well probably affects distributions well,1
0,Math,bug inverseCumulativeProbability Normal Distribution,version Revision 617953 Date 2008 02 02 22 54 00 0700 Sat 02 Feb 2008 public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision 506600 Date 2007 02 12 12 35 59 0700 Mon 12 Feb 2007 public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution 0 1 double result normal inverseCumulativeProbability 0 9772498680518209 gives exception return approx 2 0000 normal inverseCumulativeProbability 0 977249868051820 works fine also give errors 0 9986501019683698 return 3 0000 0 9999683287581673 return 4 0000 org apache commons math MathException Number iterations 1 maximum iterations 2 147 483 647 initial 1 lower bound 0 upper bound 179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final value 0 final b value 2 f 0 477 f b 0 org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java 103 org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java 145,version Revision  Date        Sat  Feb  public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision  Date        Mon  Feb  public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution   double result normal inverseCumulativeProbability   gives exception return approx   normal inverseCumulativeProbability   works fine also give errors   return     return   org apache commons math MathException Number iterations  maximum iterations     initial  lower bound  upper bound                                                                                                        final value  final b value  f   f b  org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java  org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java ,version Revision Date Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision Date Mon Feb public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution double result normal inverseCumulativeProbability gives exception return approx normal inverseCumulativeProbability works fine also give errors return return org apache commons math MathException Number iterations maximum iterations initial lower bound upper bound final value final b value f f b org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java,1
0,Math,ODE integrator goes past specified end integration range,End integration range ODE solving handled event cases numerical accuracy events detection leads error events location following test case shows end event handled properly integration cover 60s range fact covers 160s range twice specified range public void testMissedEvent throws IntegratorException DerivativeException final double t0 1878250320 0000029 final double 1878250379 9999986 FirstOrderDifferentialEquations ode new FirstOrderDifferentialEquations public int getDimension return 1 public void computeDerivatives double double double yDot throws DerivativeException yDot 0 0 1 0e 6 DormandPrince853Integrator integrator new DormandPrince853Integrator 0 0 100 0 1 0e 10 1 0e 10 double 1 0 integrator setInitialStepSize 60 0 double finalT integrator integrate ode t0 Assert assertEquals finalT 1 0e 6,End integration range ODE solving handled event cases numerical accuracy events detection leads error events location following test case shows end event handled properly integration cover s range fact covers s range twice specified range public void testMissedEvent throws IntegratorException DerivativeException final double t   final double   FirstOrderDifferentialEquations ode new FirstOrderDifferentialEquations public int getDimension return  public void computeDerivatives double double double yDot throws DerivativeException yDot    e  DormandPrinceIntegrator integrator new DormandPrinceIntegrator      e   e  double   integrator setInitialStepSize   double finalT integrator integrate ode t Assert assertEquals finalT  e ,End integration range ODE solving handled event cases numerical accuracy events detection leads error events location following test case shows end event handled properly integration cover range fact covers range twice specified range public void testMissedEvent throws IntegratorException DerivativeException final double final double FirstOrderDifferentialEquations ode new FirstOrderDifferentialEquations public int getDimension return public void computeDerivatives double double double yDot throws DerivativeException yDot e DormandPrinceIntegrator integrator new DormandPrinceIntegrator e e double integrator setInitialStepSize double finalT integrator integrate ode Assert assertEquals finalT e,1
0,Math,NaN singular value SVD,following jython code Start code org apache commons math linear import Alist 1 0 2 0 3 0 2 0 3 0 4 0 3 0 5 0 7 0 Array2DRowRealMatrix Alist decomp SingularValueDecompositionImpl print decomp getSingularValues End code prints array 11 218599757513008 0 3781791648535976 nan last singular value something close 0 since matrix rank deficient use result getSolver solve system end bunch NaNs solution assumed would get back least squares solution SVD implementation require matrix full rank would expect exception thrown constructor one methods,following jython code Start code org apache commons math linear import Alist                   ArrayDRowRealMatrix Alist decomp SingularValueDecompositionImpl print decomp getSingularValues End code prints array     nan last singular value something close  since matrix rank deficient use result getSolver solve system end bunch NaNs solution assumed would get back least squares solution SVD implementation require matrix full rank would expect exception thrown constructor one methods,following jython code Start code org apache commons math linear import Alist ArrayDRowRealMatrix Alist decomp SingularValueDecompositionImpl print decomp getSingularValues End code prints array nan last singular value something close since matrix rank deficient use result getSolver solve system end bunch NaNs solution assumed would get back least squares solution SVD implementation require matrix full rank would expect exception thrown constructor one methods,1
0,Math,SimplexSolver working expected 2,SimplexSolver find optimal solution Program Lpsolve Objective function max 7 3 b Constraints R1 3 5 c 0 R2 2 5 0 R3 2 b 5 c 0 R4 3 b 5 0 R5 3 2 b 5 R6 2 3 b 5 Variable bounds 1 b 1 Results correct 1 b 1 value 10 Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double 7 3 0 0 0 Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double 1 0 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 0 1 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 3 0 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 2 0 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 2 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 3 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 3 2 0 0 Relationship LEQ 5 podmienky add new LinearConstraint new double 2 3 0 0 Relationship LEQ 5 SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect 1 b 0 5 value 8 5 P used latest software repository including MATH 286 fix,SimplexSolver find optimal solution Program Lpsolve Objective function max   b Constraints R   c  R    R  b  c  R  b   R   b  R   b  Variable bounds  b  Results correct  b  value  Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double      Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect  b   value   P used latest software repository including MATH  fix,SimplexSolver find optimal solution Program Lpsolve Objective function max b Constraints R c R R b c R b R b R b Variable bounds b Results correct b value Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect b value P used latest software repository including MATH fix,1
0,Math,MathRuntimeException simple ebeMultiply OpenMapRealVector,following piece code import org apache commons math linear OpenMapRealVector import org apache commons math linear RealVector public class DemoBugOpenMapRealVector public static void main String args final RealVector u new OpenMapRealVector 3 1E 6 u setEntry 0 1 u setEntry 1 0 u setEntry 2 2 final RealVector v new OpenMapRealVector 3 1E 6 v setEntry 0 0 v setEntry 1 3 v setEntry 2 0 System println u System println v System println u ebeMultiply v raises exception org apache commons math linear OpenMapRealVector 7170a9b6 Exception thread main org apache commons math MathRuntimeException 6 map modified iterating org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java 373 org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java 564 org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java 372 org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java 1 DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java 17,following piece code import org apache commons math linear OpenMapRealVector import org apache commons math linear RealVector public class DemoBugOpenMapRealVector public static void main String args final RealVector u new OpenMapRealVector  E  u setEntry   u setEntry   u setEntry   final RealVector v new OpenMapRealVector  E  v setEntry   v setEntry   v setEntry   System println u System println v System println u ebeMultiply v raises exception org apache commons math linear OpenMapRealVector ab Exception thread main org apache commons math MathRuntimeException  map modified iterating org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java  org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java  org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java  org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java  DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java ,following piece code import org apache commons math linear OpenMapRealVector import org apache commons math linear RealVector public class DemoBugOpenMapRealVector public static void main String args final RealVector u new OpenMapRealVector E u setEntry u setEntry u setEntry final RealVector v new OpenMapRealVector E v setEntry v setEntry v setEntry System println u System println v System println u ebeMultiply v raises exception org apache commons math linear OpenMapRealVector ab Exception thread main org apache commons math MathRuntimeException map modified iterating org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java,1
0,Math,BracketingNthOrderBrentSolver exceeds maxIterationCount updating always boundary,cases aging feature BracketingNthOrderBrentSolver fails attempts balance bracketing points targeting non zero value instead real root However chosen target close zero inverse polynomial approximation always side thus always updates bracket real used case large program bracket point xA 12500 0 yA 3 7e 16 agingA 0 really good estimate zero one side root xB 12500 03 yB 7 0e 5 agingB 97 shows bracketing interval completely unbalanced never succeed rebalance always updates xA yA never updates xB yB,cases aging feature BracketingNthOrderBrentSolver fails attempts balance bracketing points targeting non zero value instead real root However chosen target close zero inverse polynomial approximation always side thus always updates bracket real used case large program bracket point xA   yA  e  agingA  really good estimate zero one side root xB   yB  e  agingB  shows bracketing interval completely unbalanced never succeed rebalance always updates xA yA never updates xB yB,cases aging feature BracketingNthOrderBrentSolver fails attempts balance bracketing points targeting non zero value instead real root However chosen target close zero inverse polynomial approximation always side thus always updates bracket real used case large program bracket point xA yA e agingA really good estimate zero one side root xB yB e agingB shows bracketing interval completely unbalanced never succeed rebalance always updates xA yA never updates xB yB,1
0,Math,Division zero,class Complex division zero always returns NaN think return NaN numerator also ZERO otherwise result INF See,class Complex division zero always returns NaN think return NaN numerator also ZERO otherwise result INF See,class Complex division zero always returns NaN think return NaN numerator also ZERO otherwise result INF See,1
0,Math,ODE integration last event pair close event may detected,events follows previous one closely may ignored occurrence bug depends side bracketing interval selected example consider switching function increasing around first event around 90 reaches maximum decreasing around second event around 135 integration step spans 67 5 112 5 switching function values start end step opposite signs first event detected solver find event really occurs 90 0 therefore truncate step 90 0 next step start first step ends e start 90 0 Let say step spans 90 0 153 0 switching function switches step solver first event converged value slightly 90 0 say 89 9999999 switch detected g 89 9999999 g 153 0 negative bug introduced r781157 2009 06 02 special handling events close step start added,events follows previous one closely may ignored occurrence bug depends side bracketing interval selected example consider switching function increasing around first event around  reaches maximum decreasing around second event around  integration step spans     switching function values start end step opposite signs first event detected solver find event really occurs   therefore truncate step   next step start first step ends e start   Let say step spans     switching function switches step solver first event converged value slightly   say   switch detected g   g   negative bug introduced r    special handling events close step start added,events follows previous one closely may ignored occurrence bug depends side bracketing interval selected example consider switching function increasing around first event around reaches maximum decreasing around second event around integration step spans switching function values start end step opposite signs first event detected solver find event really occurs therefore truncate step next step start first step ends e start Let say step spans switching function switches step solver first event converged value slightly say switch detected g g negative bug introduced r special handling events close step start added,1
0,Math,HypergeometricDistribution sample suffers integer overflow,Hi application broke ported commons math 2 2 3 2 looks like HypergeometricDistribution sample method work well used large integer values – example code return sample 0 50 usually returns 50 import org apache commons math3 distribution HypergeometricDistribution public class Foo public static void main String args HypergeometricDistribution new HypergeometricDistribution 43130568 42976365 50 System printf n getSupportLowerBound getSupportUpperBound Prints 0 50 System printf n sample Prints 50 debugger traced far integer overflow HypergeometricDistribution getNumericalMean – instead return double getSampleSize getNumberOfSuccesses double getPopulationSize could return getSampleSize double getNumberOfSuccesses double getPopulationSize seemed fix based quick test,Hi application broke ported commons math     looks like HypergeometricDistribution sample method work well used large integer values – example code return sample   usually returns  import org apache commons math distribution HypergeometricDistribution public class Foo public static void main String args HypergeometricDistribution new HypergeometricDistribution    System printf n getSupportLowerBound getSupportUpperBound Prints   System printf n sample Prints  debugger traced far integer overflow HypergeometricDistribution getNumericalMean – instead return double getSampleSize getNumberOfSuccesses double getPopulationSize could return getSampleSize double getNumberOfSuccesses double getPopulationSize seemed fix based quick test,Hi application broke ported commons math looks like HypergeometricDistribution sample method work well used large integer values – example code return sample usually returns import org apache commons math distribution HypergeometricDistribution public class Foo public static void main String args HypergeometricDistribution new HypergeometricDistribution System printf n getSupportLowerBound getSupportUpperBound Prints System printf n sample Prints debugger traced far integer overflow HypergeometricDistribution getNumericalMean – instead return double getSampleSize getNumberOfSuccesses double getPopulationSize could return getSampleSize double getNumberOfSuccesses double getPopulationSize seemed fix based quick test,1
0,Math,new multivariate vector optimizers cannot used large number weights,using Weigth class pass large number weights multivariate vector optimizers nxn full matrix created copied n elements vector used exhausts memory n large happens example using curve fitters even simple curve fitters like polynomial ones low degree large number points encountered curve fitting 41200 points created matrix 1 7 billion elements,using Weigth class pass large number weights multivariate vector optimizers nxn full matrix created copied n elements vector used exhausts memory n large happens example using curve fitters even simple curve fitters like polynomial ones low degree large number points encountered curve fitting  points created matrix   billion elements,using Weigth class pass large number weights multivariate vector optimizers nxn full matrix created copied n elements vector used exhausts memory n large happens example using curve fitters even simple curve fitters like polynomial ones low degree large number points encountered curve fitting points created matrix billion elements,1
0,Math,Complex ZERO reciprocal returns NaN return INF,Complex ZERO reciprocal returns NaN return INF Class org apache commons math3 complex Complex Method reciprocal version Id Complex java 1416643 2012 12 03 19 37 14Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java       Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java Z tn,1
0,Math,new multivariate vector optimizers cannot used large number weights,using Weigth class pass large number weights multivariate vector optimizers nxn full matrix created copied n elements vector used exhausts memory n large happens example using curve fitters even simple curve fitters like polynomial ones low degree large number points encountered curve fitting 41200 points created matrix 1 7 billion elements,using Weigth class pass large number weights multivariate vector optimizers nxn full matrix created copied n elements vector used exhausts memory n large happens example using curve fitters even simple curve fitters like polynomial ones low degree large number points encountered curve fitting  points created matrix   billion elements,using Weigth class pass large number weights multivariate vector optimizers nxn full matrix created copied n elements vector used exhausts memory n large happens example using curve fitters even simple curve fitters like polynomial ones low degree large number points encountered curve fitting points created matrix billion elements,1
0,Math,Fix deprecate isSupportXxxInclusive RealDistribution interface,conclusion 1 never implemented deprecate properties RealDistribution interface since removal wait 4 0 agree precise definition fix code match mean time definition propose isSupportXxxInclusive means density function applied upper lower bound support returned getSupportXxxBound finite e infinite NaN value returned 1 http markmail org message dxuxh7eybl7xejde,conclusion  never implemented deprecate properties RealDistribution interface since removal wait   agree precise definition fix code match mean time definition propose isSupportXxxInclusive means density function applied upper lower bound support returned getSupportXxxBound finite e infinite NaN value returned  http markmail org message dxuxheyblxejde,conclusion never implemented deprecate properties RealDistribution interface since removal wait agree precise definition fix code match mean time definition propose isSupportXxxInclusive means density function applied upper lower bound support returned getSupportXxxBound finite e infinite NaN value returned http markmail org message dxuxheyblxejde,1
0,Math,HarmonicFitter ParameterGuesser sometimes fails return sensible values,inner class ParameterGuesser HarmonicFitter package c optimization fitting fails compute usable guess amplitude parameter,inner class ParameterGuesser HarmonicFitter package c optimization fitting fails compute usable guess amplitude parameter,inner class ParameterGuesser HarmonicFitter package c optimization fitting fails compute usable guess amplitude parameter,1
0,Time,Errors creating parsing dates specific time zones,results 572 time zones 130 fail 30 throw exceptions failures interesting query DateTimeZone get time zone ids get time zone like America Atka take id create date time time zone id America Adak like multiple list time zones Joda time sync,results  time zones  fail  throw exceptions failures interesting query DateTimeZone get time zone ids get time zone like America Atka take id create date time time zone id America Adak like multiple list time zones Joda time sync,results time zones fail throw exceptions failures interesting query DateTimeZone get time zone ids get time zone like America Atka take id create date time time zone id America Adak like multiple list time zones Joda time sync,1
0,Time,GJChronology rejects valid Julian dates,2nd statement fails org joda time IllegalFieldValueException Value 29 dayOfMonth must range 1 28 Given left cutover date default October 15 1582 1500 02 29 valid date GJChronology,nd statement fails org joda time IllegalFieldValueException Value  dayOfMonth must range   Given left cutover date default October      valid date GJChronology,nd statement fails org joda time IllegalFieldValueException Value dayOfMonth must range Given left cutover date default October valid date GJChronology,1
0,Time,Different behaviour PeriodFormatter,hour day set ambiguous hour daylight standard time transition given time zone result inconsistent different time zones Shoul hour set daylight hour standard hour time zones find anything documents behavior test code returns different results different time zones last assertion fails Australia time zone cutover,hour day set ambiguous hour daylight standard time transition given time zone result inconsistent different time zones Shoul hour set daylight hour standard hour time zones find anything documents behavior test code returns different results different time zones last assertion fails Australia time zone cutover,hour day set ambiguous hour daylight standard time transition given time zone result inconsistent different time zones Shoul hour set daylight hour standard hour time zones find anything documents behavior test code returns different results different time zones last assertion fails Australia time zone cutover,1
0,Time,Ensure max min valid offset,DateTimeZone apply max min value offset However parse method limited 23 59 Make 23 59 59 999 maximum,DateTimeZone apply max min value offset However parse method limited   Make     maximum,DateTimeZone apply max min value offset However parse method limited Make maximum,1
0,Time,NPE DateTimeZoneBuilder,DateTimeZone build duplicate named recurring saving time first thread goes Ok warning message generated identifier automatically generated PrecalculatedZone create second thread NPE generated ZoneInfoCompiler verbose cause cVerbose ThreadLocal incorrectly initialized ZoneInfoCompiler initialize cVerbose first thread subsequent ones NPE caused autoboxing better approach could remove initialization test null,DateTimeZone build duplicate named recurring saving time first thread goes Ok warning message generated identifier automatically generated PrecalculatedZone create second thread NPE generated ZoneInfoCompiler verbose cause cVerbose ThreadLocal incorrectly initialized ZoneInfoCompiler initialize cVerbose first thread subsequent ones NPE caused autoboxing better approach could remove initialization test null,DateTimeZone build duplicate named recurring saving time first thread goes Ok warning message generated identifier automatically generated PrecalculatedZone create second thread NPE generated ZoneInfoCompiler verbose cause cVerbose ThreadLocal incorrectly initialized ZoneInfoCompiler initialize cVerbose first thread subsequent ones NPE caused autoboxing better approach could remove initialization test null,1
0,Time,DateTimeFormat parseInto sometimes miscalculates year 2 2,following code added org joda time format TestDateTimeFormatter breaks input mutable date time millis appear mishandled year parse changed 1999,following code added org joda time format TestDateTimeFormatter breaks input mutable date time millis appear mishandled year parse changed ,following code added org joda time format TestDateTimeFormatter breaks input mutable date time millis appear mishandled year parse changed,1
0,Time,DateTimeFormatter parseInto broken year format,Joda Time 2 0 default year set 2000 Feb 29 could parsed correctly However parseInto overwrites given instant year 2000 whatever iDefaultYear set correct behavior would seem use given instant year instead iDefaultYear mean Feb 29 might parseable instant year leap year case caller asked sense,Joda Time   default year set  Feb  could parsed correctly However parseInto overwrites given instant year  whatever iDefaultYear set correct behavior would seem use given instant year instead iDefaultYear mean Feb  might parseable instant year leap year case caller asked sense,Joda Time default year set Feb could parsed correctly However parseInto overwrites given instant year whatever iDefaultYear set correct behavior would seem use given instant year instead iDefaultYear mean Feb might parseable instant year leap year case caller asked sense,1
0,Time,Questionable behaviour GJChronology dates pass 1BC,expect following test pass However never provided 0 year thought job framework skip non existent year 0 return 1 BC,expect following test pass However never provided  year thought job framework skip non existent year  return  BC,expect following test pass However never provided year thought job framework skip non existent year return BC,1
0,Time,Bug withLaterOffsetAtOverlap method,last two brackets see withLaterOffsetAtOverlap undoing withEarlierOffsetAtOverlap even working,last two brackets see withLaterOffsetAtOverlap undoing withEarlierOffsetAtOverlap even working,last two brackets see withLaterOffsetAtOverlap undoing withEarlierOffsetAtOverlap even working,1
0,Time,Partial fails NPE,Fails yearOfCentury year yearOfEra Probably weekyear null range duration type,Fails yearOfCentury year yearOfEra Probably weekyear null range duration type,Fails yearOfCentury year yearOfEra Probably weekyear null range duration type,1
0,Time,Days daysBetween throw exception MonthDay 29 February,way avoid happening understand fiddling around leap year bound get issues,way avoid happening understand fiddling around leap year bound get issues,way avoid happening understand fiddling around leap year bound get issues,1
0,Time,withHourOfDay sets hour inconsistantly DST transition,hour day set ambiguous hour daylight standard time transition given time zone result inconsistent different time zones Shoul hour set daylight hour standard hour time zones find anything documents behavior test code returns different results different time zones last assertion fails Australia time zone cutover,hour day set ambiguous hour daylight standard time transition given time zone result inconsistent different time zones Shoul hour set daylight hour standard hour time zones find anything documents behavior test code returns different results different time zones last assertion fails Australia time zone cutover,hour day set ambiguous hour daylight standard time transition given time zone result inconsistent different time zones Shoul hour set daylight hour standard hour time zones find anything documents behavior test code returns different results different time zones last assertion fails Australia time zone cutover,1
0,Time,DateTimeZone forOffsetHoursMinutes cannot handle negative offset 1 hour,DateTimeZone forOffsetHoursMinutes h cannot handle negative offset 1 hour like 0 30 due argument range checking used forOffsetMillis instead probably mentioned documentation negative minutes accepted,DateTimeZone forOffsetHoursMinutes h cannot handle negative offset  hour like   due argument range checking used forOffsetMillis instead probably mentioned documentation negative minutes accepted,DateTimeZone forOffsetHoursMinutes h cannot handle negative offset hour like due argument range checking used forOffsetMillis instead probably mentioned documentation negative minutes accepted,1
0,Time,Incorrect date parsed week month used together,print 2011 01 03 printing 2010 01 04,print    printing   ,print printing,1
0,Time,Incorrect mapping MET time zone,timezone mapped Asia Tehran DateTimeZone middle europena time,timezone mapped Asia Tehran DateTimeZone middle europena time,timezone mapped Asia Tehran DateTimeZone middle europena time,1
0,Time,Constructing invalid Partials,Partials constructed invoking constructor Partial DateTimeFieldType int merging together set partials using constructed calling Partial DateTimeFieldType int However work cases suppose Partials allow constructed either case right also related issue probably stems fact Partial invalid,Partials constructed invoking constructor Partial DateTimeFieldType int merging together set partials using constructed calling Partial DateTimeFieldType int However work cases suppose Partials allow constructed either case right also related issue probably stems fact Partial invalid,Partials constructed invoking constructor Partial DateTimeFieldType int merging together set partials using constructed calling Partial DateTimeFieldType int However work cases suppose Partials allow constructed either case right also related issue probably stems fact Partial invalid,1
0,Time,possibly bug org joda time field FieldUtils safeMultiply,seems currently written joda time 2 1 jar org joda time field FieldUtils safeMultiply long val1 int scalar detect overflow long val1 Long MIN VALUE int scalar 1 attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,seems currently written joda time   jar org joda time field FieldUtils safeMultiply long val int scalar detect overflow long val Long MIN VALUE int scalar  attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,seems currently written joda time jar org joda time field FieldUtils safeMultiply long val int scalar detect overflow long val Long MIN VALUE int scalar attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,1
0,Time,addDays 0 changes value MutableDateTime,Upon DST transition summer winter time zone adding amount zero days mutable date time object changes value object methods addMonths addYears show problem addSeconds addMinutes addHours ok tested version 2 3 However repeat test Joda 1 5 2 invocation addDays 0 change date value,Upon DST transition summer winter time zone adding amount zero days mutable date time object changes value object methods addMonths addYears show problem addSeconds addMinutes addHours ok tested version   However repeat test Joda    invocation addDays  change date value,Upon DST transition summer winter time zone adding amount zero days mutable date time object changes value object methods addMonths addYears show problem addSeconds addMinutes addHours ok tested version However repeat test Joda invocation addDays change date value,1
0,Time,Check Calendar ERA LocalDate fromCalendarFields,None,None,None,1
0,Time,Partial fails NPE,Fails yearOfCentury year yearOfEra Probably weekyear null range duration type,Fails yearOfCentury year yearOfEra Probably weekyear null range duration type,Fails yearOfCentury year yearOfEra Probably weekyear null range duration type,1
0,Time,Negative millis display incorrectly Period toString,last line produce PT 0 100S instead PT0 100S,last line produce PT  S instead PT S,last line produce PT instead PT,1
0,Time,none standard PeriodType without year throws exception,tried get Period months weeks following code throws following exception Even removing year component withYearsRemoved throws exception,tried get Period months weeks following code throws following exception Even removing year component withYearsRemoved throws exception,tried get Period months weeks following code throws following exception Even removing year component withYearsRemoved throws exception,1
0,Time,Unable add days MonthDay set ISO leap date,possible add days MonthDay set ISO leap date February 29th even bizarre given exact error message thrown,possible add days MonthDay set ISO leap date February th even bizarre given exact error message thrown,possible add days MonthDay set ISO leap date February th even bizarre given exact error message thrown,1
0,Time,Duration toPeriod fixed time zones,question concerning conversion Duration Period sure bug different way basis problem using Duration toPeriod uses chronology default time zone conversion cause different results timezone DST one without reproduced easily test joda code Duration toPeriod uses period constructor takes chronology null passed chronology default time zone used leads behavior javadoc toPeriod states precise fields hours minutes seconds millis converted fixed timezone days weeks also precise stated javadoc toPeriod Chronology chrono app need consistent behavior regardless default time zone extra hours put hours bucket Since Duration supposed time zone independent length time think chronology manipulation get work,question concerning conversion Duration Period sure bug different way basis problem using Duration toPeriod uses chronology default time zone conversion cause different results timezone DST one without reproduced easily test joda code Duration toPeriod uses period constructor takes chronology null passed chronology default time zone used leads behavior javadoc toPeriod states precise fields hours minutes seconds millis converted fixed timezone days weeks also precise stated javadoc toPeriod Chronology chrono app need consistent behavior regardless default time zone extra hours put hours bucket Since Duration supposed time zone independent length time think chronology manipulation get work,question concerning conversion Duration Period sure bug different way basis problem using Duration toPeriod uses chronology default time zone conversion cause different results timezone DST one without reproduced easily test joda code Duration toPeriod uses period constructor takes chronology null passed chronology default time zone used leads behavior javadoc toPeriod states precise fields hours minutes seconds millis converted fixed timezone days weeks also precise stated javadoc toPeriod Chronology chrono app need consistent behavior regardless default time zone extra hours put hours bucket Since Duration supposed time zone independent length time think chronology manipulation get work,1
0,Time,DateTimeZone getOffsetFromLocal error DST transition,may failure understanding comments DateTimeZone getOffsetFromLocal lead believe ambiguous local time given offset corresponding later two possible UTC instants returned e greater offset appear tally experience fall 2009 America Los Angeles changed 7 8 2am wall time November 11 Thus 2am became 1am 1 30am ambiguous would therefore expect constructing DateTime November 11th 1 30am would give instant corresponding later value e 9 30am UTC,may failure understanding comments DateTimeZone getOffsetFromLocal lead believe ambiguous local time given offset corresponding later two possible UTC instants returned e greater offset appear tally experience fall  America Los Angeles changed   am wall time November  Thus am became am  am ambiguous would therefore expect constructing DateTime November th  am would give instant corresponding later value e  am UTC,may failure understanding comments DateTimeZone getOffsetFromLocal lead believe ambiguous local time given offset corresponding later two possible UTC instants returned e greater offset appear tally experience fall America Los Angeles changed wall time November Thus became ambiguous would therefore expect constructing DateTime November th would give instant corresponding later value e UTC,1
0,Lang,StrBuilder replaceAll StrBuilder deleteAll throw ArrayIndexOutOfBoundsException,StrBuilder replaceAll StrBuilder deleteAll thrown ArrayIndexOutOfBoundsException couple additions StrBuilderTest class demonstrate problem StrBuilder deleteAll added testDeleteAll String sb new StrBuilder \n BLAH \nDo stuff\neven stuff\n BLAH \n sb deleteAll \n BLAH assertEquals \nDo stuff\neven stuff\n sb toString causes following error java lang ArrayIndexOutOfBoundsException java lang System arraycopy Native Method org apache commons lang text StrBuilder deleteImpl StrBuilder java 1114 org apache commons lang text StrBuilder deleteAll StrBuilder java 1188 org apache commons lang text StrBuilderTest testDeleteAll String StrBuilderTest java 606 sun reflect NativeMethodAccessorImpl invoke0 Native Method sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 39 sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 java lang reflect Method invoke Method java 585 junit framework TestCase runTest TestCase java 154 junit framework TestCase runBare TestCase java 127 junit framework TestResult 1 protect TestResult java 106 junit framework TestResult runProtected TestResult java 124 junit framework TestResult run TestResult java 109 junit framework TestCase run TestCase java 118 junit framework TestSuite runTest TestSuite java 208 junit framework TestSuite run TestSuite java 203 org eclipse jdt internal junit runner junit3 JUnit3TestReference run JUnit3TestReference java 128 org eclipse jdt internal junit runner TestExecution run TestExecution java 38 org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java 460 org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java 673 org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java 386 org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java 196 StrBuilder replaceAll added testReplaceAll String String sb new StrBuilder \n BLAH \nDo stuff\neven stuff\n BLAH \n sb replaceAll \n BLAH assertEquals \nDo stuff\neven stuff\n sb toString causes exception java lang ArrayIndexOutOfBoundsException java lang System arraycopy Native Method org apache commons lang text StrBuilder replaceImpl StrBuilder java 1256 org apache commons lang text StrBuilder replaceAll StrBuilder java 1339 org apache commons lang text StrBuilderTest testReplaceAll String String StrBuilderTest java 763 sun reflect NativeMethodAccessorImpl invoke0 Native Method sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 39 sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 25 java lang reflect Method invoke Method java 585 junit framework TestCase runTest TestCase java 154 junit framework TestCase runBare TestCase java 127 junit framework TestResult 1 protect TestResult java 106 junit framework TestResult runProtected TestResult java 124 junit framework TestResult run TestResult java 109 junit framework TestCase run TestCase java 118 junit framework TestSuite runTest TestSuite java 208 junit framework TestSuite run TestSuite java 203 org eclipse jdt internal junit runner junit3 JUnit3TestReference run JUnit3TestReference java 128 org eclipse jdt internal junit runner TestExecution run TestExecution java 38 org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java 460 org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java 673 org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java 386 org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java 196,StrBuilder replaceAll StrBuilder deleteAll thrown ArrayIndexOutOfBoundsException couple additions StrBuilderTest class demonstrate problem StrBuilder deleteAll added testDeleteAll String sb new StrBuilder \n BLAH \nDo stuff\neven stuff\n BLAH \n sb deleteAll \n BLAH assertEquals \nDo stuff\neven stuff\n sb toString causes following error java lang ArrayIndexOutOfBoundsException java lang System arraycopy Native Method org apache commons lang text StrBuilder deleteImpl StrBuilder java  org apache commons lang text StrBuilder deleteAll StrBuilder java  org apache commons lang text StrBuilderTest testDeleteAll String StrBuilderTest java  sun reflect NativeMethodAccessorImpl invoke Native Method sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java  sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java  java lang reflect Method invoke Method java  junit framework TestCase runTest TestCase java  junit framework TestCase runBare TestCase java  junit framework TestResult  protect TestResult java  junit framework TestResult runProtected TestResult java  junit framework TestResult run TestResult java  junit framework TestCase run TestCase java  junit framework TestSuite runTest TestSuite java  junit framework TestSuite run TestSuite java  org eclipse jdt internal junit runner junit JUnitTestReference run JUnitTestReference java  org eclipse jdt internal junit runner TestExecution run TestExecution java  org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java  org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java  org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java  org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java  StrBuilder replaceAll added testReplaceAll String String sb new StrBuilder \n BLAH \nDo stuff\neven stuff\n BLAH \n sb replaceAll \n BLAH assertEquals \nDo stuff\neven stuff\n sb toString causes exception java lang ArrayIndexOutOfBoundsException java lang System arraycopy Native Method org apache commons lang text StrBuilder replaceImpl StrBuilder java  org apache commons lang text StrBuilder replaceAll StrBuilder java  org apache commons lang text StrBuilderTest testReplaceAll String String StrBuilderTest java  sun reflect NativeMethodAccessorImpl invoke Native Method sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java  sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java  java lang reflect Method invoke Method java  junit framework TestCase runTest TestCase java  junit framework TestCase runBare TestCase java  junit framework TestResult  protect TestResult java  junit framework TestResult runProtected TestResult java  junit framework TestResult run TestResult java  junit framework TestCase run TestCase java  junit framework TestSuite runTest TestSuite java  junit framework TestSuite run TestSuite java  org eclipse jdt internal junit runner junit JUnitTestReference run JUnitTestReference java  org eclipse jdt internal junit runner TestExecution run TestExecution java  org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java  org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java  org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java  org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java ,StrBuilder replaceAll StrBuilder deleteAll thrown ArrayIndexOutOfBoundsException couple additions StrBuilderTest class demonstrate problem StrBuilder deleteAll added testDeleteAll String sb new StrBuilder \n BLAH \nDo stuff\neven stuff\n BLAH \n sb deleteAll \n BLAH assertEquals \nDo stuff\neven stuff\n sb toString causes following error java lang ArrayIndexOutOfBoundsException java lang System arraycopy Native Method org apache commons lang text StrBuilder deleteImpl StrBuilder java org apache commons lang text StrBuilder deleteAll StrBuilder java org apache commons lang text StrBuilderTest testDeleteAll String StrBuilderTest java sun reflect NativeMethodAccessorImpl invoke Native Method sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java java lang reflect Method invoke Method java junit framework TestCase runTest TestCase java junit framework TestCase runBare TestCase java junit framework TestResult protect TestResult java junit framework TestResult runProtected TestResult java junit framework TestResult run TestResult java junit framework TestCase run TestCase java junit framework TestSuite runTest TestSuite java junit framework TestSuite run TestSuite java org eclipse jdt internal junit runner junit JUnitTestReference run JUnitTestReference java org eclipse jdt internal junit runner TestExecution run TestExecution java org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java StrBuilder replaceAll added testReplaceAll String String sb new StrBuilder \n BLAH \nDo stuff\neven stuff\n BLAH \n sb replaceAll \n BLAH assertEquals \nDo stuff\neven stuff\n sb toString causes exception java lang ArrayIndexOutOfBoundsException java lang System arraycopy Native Method org apache commons lang text StrBuilder replaceImpl StrBuilder java org apache commons lang text StrBuilder replaceAll StrBuilder java org apache commons lang text StrBuilderTest testReplaceAll String String StrBuilderTest java sun reflect NativeMethodAccessorImpl invoke Native Method sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java java lang reflect Method invoke Method java junit framework TestCase runTest TestCase java junit framework TestCase runBare TestCase java junit framework TestResult protect TestResult java junit framework TestResult runProtected TestResult java junit framework TestResult run TestResult java junit framework TestCase run TestCase java junit framework TestSuite runTest TestSuite java junit framework TestSuite run TestSuite java org eclipse jdt internal junit runner junit JUnitTestReference run JUnitTestReference java org eclipse jdt internal junit runner TestExecution run TestExecution java org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java,1
0,Lang,Bug method appendFixedWidthPadRight class StrBuilder causes ArrayIndexOutOfBoundsException,bug method appendFixedWidthPadRight class StrBuilder public StrBuilder appendFixedWidthPadRight Object obj int width char padChar width 0 ensureCapacity size width String str obj null getNullText obj toString int strLen str length strLen width str getChars 0 strLen buffer size BUG str getChars 0 width buffer size else int padLen width strLen str getChars 0 strLen buffer size int 0 padLen buffer size strLen padChar size width return causing ArrayIndexOutOfBoundsException method unusable strLen width counterpart method appendFixedWidthPadLeft seems ok,bug method appendFixedWidthPadRight class StrBuilder public StrBuilder appendFixedWidthPadRight Object obj int width char padChar width  ensureCapacity size width String str obj null getNullText obj toString int strLen str length strLen width str getChars  strLen buffer size BUG str getChars  width buffer size else int padLen width strLen str getChars  strLen buffer size int  padLen buffer size strLen padChar size width return causing ArrayIndexOutOfBoundsException method unusable strLen width counterpart method appendFixedWidthPadLeft seems ok,bug method appendFixedWidthPadRight class StrBuilder public StrBuilder appendFixedWidthPadRight Object obj int width char padChar width ensureCapacity size width String str obj null getNullText obj toString int strLen str length strLen width str getChars strLen buffer size BUG str getChars width buffer size else int padLen width strLen str getChars strLen buffer size int padLen buffer size strLen padChar size width return causing ArrayIndexOutOfBoundsException method unusable strLen width counterpart method appendFixedWidthPadLeft seems ok,1
0,Lang,FastDateFormat getDateInstance getDateTimeInstance assume Locale getDefault change,FastDateFormat getDateInstance getDateTimeInstance methods create HashMap key various items including locale locale null made part key stored object created using current default locale Locale changed subsequently wrong locale applied Patch test case follow,FastDateFormat getDateInstance getDateTimeInstance methods create HashMap key various items including locale locale null made part key stored object created using current default locale Locale changed subsequently wrong locale applied Patch test case follow,FastDateFormat getDateInstance getDateTimeInstance methods create HashMap key various items including locale locale null made part key stored object created using current default locale Locale changed subsequently wrong locale applied Patch test case follow,1
0,Lang,NullPointerException isAvailableLocale Locale,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,1
0,Lang,Use ThreadLocals ToStringStyle HashCodeBuilder trigger memory leaks container environments,thread local org apache commons lang3 builder ToStringStyle created never removed API provided remove webapp use LANG triggers loading class reference chain created cause memory leak web application reload See http markmail org thread uetw2fdrsqgbh2cv info,thread local org apache commons lang builder ToStringStyle created never removed API provided remove webapp use LANG triggers loading class reference chain created cause memory leak web application reload See http markmail org thread uetwfdrsqgbhcv info,thread local org apache commons lang builder ToStringStyle created never removed API provided remove webapp use LANG triggers loading class reference chain created cause memory leak web application reload See http markmail org thread uetwfdrsqgbhcv info,1
0,Lang,ArrayUtils add array element create unexpected ClassCastException,ArrayUtils add array element create unexpected ClassCastException example following code compiles without warning String sa ArrayUtils add stringArray aString works fine provided least one parameters non null However parameters null add method returns Object array hence Exception parameters null possible determine correct array type return seems disallowed think method ought changed throw IllegalParameterException parameters null,ArrayUtils add array element create unexpected ClassCastException example following code compiles without warning String sa ArrayUtils add stringArray aString works fine provided least one parameters non null However parameters null add method returns Object array hence Exception parameters null possible determine correct array type return seems disallowed think method ought changed throw IllegalParameterException parameters null,ArrayUtils add array element create unexpected ClassCastException example following code compiles without warning String sa ArrayUtils add stringArray aString works fine provided least one parameters non null However parameters null add method returns Object array hence Exception parameters null possible determine correct array type return seems disallowed think method ought changed throw IllegalParameterException parameters null,1
0,Lang,FastDateFormat mRules transient serializable,Reported FindBugs Either need make Rule interface Serializable make mRules transient add deserializing code kick init,Reported FindBugs Either need make Rule interface Serializable make mRules transient add deserializing code kick init,Reported FindBugs Either need make Rule interface Serializable make mRules transient add deserializing code kick init,1
0,Lang,BooleanUtils toBoolean invalid drop thru case statement causes StringIndexOutOfBoundsException,method BooleanUtils toBoolean case statement case 3 drops case 4 cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case 3 return false Patch follow source unit test,method BooleanUtils toBoolean case statement case  drops case  cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case  return false Patch follow source unit test,method BooleanUtils toBoolean case statement case drops case cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case return false Patch follow source unit test,1
0,Lang,NumberUtils createNumber throws NumberFormatException one digit long,NumberUtils createNumber throws NumberFormatException parsing 1l 2l etc works fine try parse 01l 02l condition isDigits numeric substring 1 line 455 return false numeric substring 1 empty string 1l,NumberUtils createNumber throws NumberFormatException parsing l l etc works fine try parse l l condition isDigits numeric substring  line  return false numeric substring  empty string l,NumberUtils createNumber throws NumberFormatException parsing l l etc works fine try parse l l condition isDigits numeric substring line return false numeric substring empty string l,1
0,Lang,StrBuilder contains usages thisBuf length use size,fixing LANG 294 noticed two places StrBuilder reference thisBuf length unless mistaken,fixing LANG  noticed two places StrBuilder reference thisBuf length unless mistaken,fixing LANG noticed two places StrBuilder reference thisBuf length unless mistaken,1
0,Lang,Use ThreadLocals ToStringStyle HashCodeBuilder trigger memory leaks container environments,thread local org apache commons lang3 builder ToStringStyle created never removed API provided remove webapp use LANG triggers loading class reference chain created cause memory leak web application reload See http markmail org thread uetw2fdrsqgbh2cv info,thread local org apache commons lang builder ToStringStyle created never removed API provided remove webapp use LANG triggers loading class reference chain created cause memory leak web application reload See http markmail org thread uetwfdrsqgbhcv info,thread local org apache commons lang builder ToStringStyle created never removed API provided remove webapp use LANG triggers loading class reference chain created cause memory leak web application reload See http markmail org thread uetwfdrsqgbhcv info,1
0,Lang,ClassUtils toClass Object throws NPE null array element,see summary,see summary,see summary,1
0,Lang,StringUtils join throws NPE toString returns null one objects collection,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,1
0,Lang,FastDateFormat formats year differently SimpleDateFormat Java 7,Starting Java 7 SimpleDateFormat format year pattern YYY 2003 instead 03 former Java releases According Javadoc pattern always formatted number therefore new behavior seems bug fix JDK FastDateFormat adjusted behave,Starting Java  SimpleDateFormat format year pattern YYY  instead  former Java releases According Javadoc pattern always formatted number therefore new behavior seems bug fix JDK FastDateFormat adjusted behave,Starting Java SimpleDateFormat format year pattern YYY instead former Java releases According Javadoc pattern always formatted number therefore new behavior seems bug fix JDK FastDateFormat adjusted behave,1
0,Lang,NumberUtils createNumber throws StringIndexOutOfBoundsException argument containing e E passed,NumberUtils createNumber throws StringIndexOutOfBoundsException instead NumberFormatException String containing possible exponent indicators passed One example String 1eE,NumberUtils createNumber throws StringIndexOutOfBoundsException instead NumberFormatException String containing possible exponent indicators passed One example String eE,NumberUtils createNumber throws StringIndexOutOfBoundsException instead NumberFormatException String containing possible exponent indicators passed One example String eE,1
0,Lang,FastDateParser handle unterminated quotes correctly,FDP handled unterminated quotes way SimpleDateFormat example Format Date d3 fail parse format date actually works format parsed Pattern \p IsNd,FDP handled unterminated quotes way SimpleDateFormat example Format Date d fail parse format date actually works format parsed Pattern \p IsNd,FDP handled unterminated quotes way SimpleDateFormat example Format Date fail parse format date actually works format parsed Pattern \p IsNd,1
0,Lang,RandomStringUtils throws confusing IAE end start,RandomUtils invokes Random nextInt n end start end start Random throws java lang IllegalArgumentException n must positive confusing identify source problem,RandomUtils invokes Random nextInt n end start end start Random throws java lang IllegalArgumentException n must positive confusing identify source problem,RandomUtils invokes Random nextInt n end start end start Random throws java lang IllegalArgumentException n must positive confusing identify source problem,1
0,Lang,NumberUtils createNumber bad behaviour leading,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,1
0,Lang,SystemUtils getJavaVersionAsFloat throws StringIndexOutOfBoundsException Android runtime Dalvik VM,replicated Android emulator quite easily Stack trace org apache commons lang builder ToStringBuilder clinit ToStringBuilder java 98 E AndroidRuntime 1681 17 E AndroidRuntime 1681 Caused java lang ExceptionInInitializerError E AndroidRuntime 1681 org apache commons lang builder ToStringStyle MultiLineToStringStyle init ToStringStyle java 2276 E AndroidRuntime 1681 org apache commons lang builder ToStringStyle clinit ToStringStyle java 94 E AndroidRuntime 1681 18 E AndroidRuntime 1681 Caused java lang StringIndexOutOfBoundsException E AndroidRuntime 1681 java lang String substring String java 1571 E AndroidRuntime 1681 org apache commons lang SystemUtils getJavaVersionAsFloat SystemUtils java 1153 E AndroidRuntime 1681 org apache commons lang SystemUtils clinit SystemUtils java 818,replicated Android emulator quite easily Stack trace org apache commons lang builder ToStringBuilder clinit ToStringBuilder java  E AndroidRuntime   E AndroidRuntime  Caused java lang ExceptionInInitializerError E AndroidRuntime  org apache commons lang builder ToStringStyle MultiLineToStringStyle init ToStringStyle java  E AndroidRuntime  org apache commons lang builder ToStringStyle clinit ToStringStyle java  E AndroidRuntime   E AndroidRuntime  Caused java lang StringIndexOutOfBoundsException E AndroidRuntime  java lang String substring String java  E AndroidRuntime  org apache commons lang SystemUtils getJavaVersionAsFloat SystemUtils java  E AndroidRuntime  org apache commons lang SystemUtils clinit SystemUtils java ,replicated Android emulator quite easily Stack trace org apache commons lang builder ToStringBuilder clinit ToStringBuilder java E AndroidRuntime E AndroidRuntime Caused java lang ExceptionInInitializerError E AndroidRuntime org apache commons lang builder ToStringStyle MultiLineToStringStyle init ToStringStyle java E AndroidRuntime org apache commons lang builder ToStringStyle clinit ToStringStyle java E AndroidRuntime E AndroidRuntime Caused java lang StringIndexOutOfBoundsException E AndroidRuntime java lang String substring String java E AndroidRuntime org apache commons lang SystemUtils getJavaVersionAsFloat SystemUtils java E AndroidRuntime org apache commons lang SystemUtils clinit SystemUtils java,1
0,Lang,NumberUtils handle upper case hex 0X 0X,NumberUtils createNumber work equally 0x1234 0X1234 currently 0X1234 generates NumberFormatException Integer decode handles upper lower case hex,NumberUtils createNumber work equally x X currently X generates NumberFormatException Integer decode handles upper lower case hex,NumberUtils createNumber work equally x X currently X generates NumberFormatException Integer decode handles upper lower case hex,1
0,Lang,StringEscapeUtils escapeHtml incorrectly converts unicode characters U 00FFFF 2 characters,Characters represented 2 characters internaly java incorrectly converted function following test displays problem quite nicely import org apache commons lang public class J2 public static void main String args throws Exception utf8 representation character COUNTING ROD UNIT DIGIT THREE unicode codepoint U 1D362 byte data new byte byte 0xF0 byte 0x9D byte 0x8D byte 0xA2 output 55348 57186 119650 System println StringEscapeUtils escapeHtml new String data UTF8 quick fix feel free drop email want patch,Characters represented  characters internaly java incorrectly converted function following test displays problem quite nicely import org apache commons lang public class J public static void main String args throws Exception utf representation character COUNTING ROD UNIT DIGIT THREE unicode codepoint U D byte data new byte byte xF byte xD byte xD byte xA output    System println StringEscapeUtils escapeHtml new String data UTF quick fix feel free drop email want patch,Characters represented characters internaly java incorrectly converted function following test displays problem quite nicely import org apache commons lang public class J public static void main String args throws Exception utf representation character COUNTING ROD UNIT DIGIT THREE unicode codepoint U byte data new byte byte xF byte xD byte xD byte xA output System println StringEscapeUtils escapeHtml new String data UTF quick fix feel free drop email want patch,1
0,Lang,WordUtils abbreviate bug lower greater str length,WordUtils abbreviate upper adjusted length string lower lower never adjusted length string lower greater str lengt upper str substring 0 upper throw StringIndexOutOfBoundsException fix adjust lower length string,WordUtils abbreviate upper adjusted length string lower lower never adjusted length string lower greater str lengt upper str substring  upper throw StringIndexOutOfBoundsException fix adjust lower length string,WordUtils abbreviate upper adjusted length string lower lower never adjusted length string lower greater str lengt upper str substring upper throw StringIndexOutOfBoundsException fix adjust lower length string,1
0,Lang,StringIndexOutOfBoundsException CharSequenceTranslator,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uD83D\uDE30 surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uD83D\uDE30 StringEscapeUtils escapeCsv \uD83D\uDE30 get exception shown java lang StringIndexOutOfBoundsException String index range 2 java lang String charAt String java 658 java lang Character codePointAt Character java 4668 org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java 95 org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java 59 org apache commons lang3 StringEscapeUtils escapeCsv StringEscapeUtils java 556 Patch attached method affected public final void translate CharSequence input Writer throws IOException,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uDD\uDE surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE get exception shown java lang StringIndexOutOfBoundsException String index range  java lang String charAt String java  java lang Character codePointAt Character java  org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java  org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java  org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java  Patch attached method affected public final void translate CharSequence input Writer throws IOException,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uDD\uDE surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE get exception shown java lang StringIndexOutOfBoundsException String index range java lang String charAt String java java lang Character codePointAt Character java org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java Patch attached method affected public final void translate CharSequence input Writer throws IOException,1
0,Lang,StringEscapeUtils escapeXML process UTF 16 supplementary characters,Supplementary characters UTF 16 whose code points 0xffff require 1 Java char encoded explained http java sun com developer technicalArticles Intl Supplementary Currently StringEscapeUtils escapeXML aware coding scheme treats char one character always right possible solution class Entities would public void escape Writer writer String str throws IOException int len str length int 0 len int code str codePointAt String entityName entityName code entityName null writer write writer write entityName writer write else code 0x7F writer write writer write code writer write else writer write char code code 0xffff Besides fixing escapeXML also affect HTML escaping functions guess good thing please remember tested escapeXML,Supplementary characters UTF  whose code points xffff require  Java char encoded explained http java sun com developer technicalArticles Intl Supplementary Currently StringEscapeUtils escapeXML aware coding scheme treats char one character always right possible solution class Entities would public void escape Writer writer String str throws IOException int len str length int  len int code str codePointAt String entityName entityName code entityName null writer write writer write entityName writer write else code xF writer write writer write code writer write else writer write char code code xffff Besides fixing escapeXML also affect HTML escaping functions guess good thing please remember tested escapeXML,Supplementary characters UTF whose code points xffff require Java char encoded explained http java sun com developer technicalArticles Intl Supplementary Currently StringEscapeUtils escapeXML aware coding scheme treats char one character always right possible solution class Entities would public void escape Writer writer String str throws IOException int len str length int len int code str codePointAt String entityName entityName code entityName null writer write writer write entityName writer write else code xF writer write writer write code writer write else writer write char code code xffff Besides fixing escapeXML also affect HTML escaping functions guess good thing please remember tested escapeXML,1
0,Lang,StringEscapeUtils escapeXml input outputs wrong results input contains characters Supplementary Planes,Hello use StringEscapeUtils escapeXml input escape special characters XML method outputs wrong results input contains characters Supplementary Planes String str1 \uD842\uDFB7 String str2 StringEscapeUtils escapeXml str1 value str2 must equal one str1 str1 contain characters escaped However str2 diffrent str1 System println URLEncoder encode str1 UTF 16BE D8 42 DF B7A System println URLEncoder encode str2 UTF 16BE D8 42 DF B7 FF FD cause problem loop translate input character character wrong CharSequenceTranslator translate CharSequence input Writer loop counter moves 0 Character codePointCount input 0 input length move 0 input length,Hello use StringEscapeUtils escapeXml input escape special characters XML method outputs wrong results input contains characters Supplementary Planes String str \uD\uDFB String str StringEscapeUtils escapeXml str value str must equal one str str contain characters escaped However str diffrent str System println URLEncoder encode str UTF BE D  DF BA System println URLEncoder encode str UTF BE D  DF B FF FD cause problem loop translate input character character wrong CharSequenceTranslator translate CharSequence input Writer loop counter moves  Character codePointCount input  input length move  input length,Hello use StringEscapeUtils escapeXml input escape special characters XML method outputs wrong results input contains characters Supplementary Planes String str \uD\uDFB String str StringEscapeUtils escapeXml str value str must equal one str str contain characters escaped However str diffrent str System println URLEncoder encode str UTF DF BA System println URLEncoder encode str UTF DF B FF FD cause problem loop translate input character character wrong CharSequenceTranslator translate CharSequence input Writer loop counter moves Character codePointCount input input length move input length,1
0,Lang,NumberUtils handle Long Hex numbers,NumberUtils createLong handle hex numbers createInteger handles hex octal seems odd NumberUtils createNumber assumes hex numbers Integer handle bigger Hex numbers trivial fix createLong use Long decode instead valueOf clear done originally decode method added Integer Long Java 1 2 Fixing createNumber also fairly easy hex string 8 digits use Long allow leading zeros Integer length check trivial,NumberUtils createLong handle hex numbers createInteger handles hex octal seems odd NumberUtils createNumber assumes hex numbers Integer handle bigger Hex numbers trivial fix createLong use Long decode instead valueOf clear done originally decode method added Integer Long Java   Fixing createNumber also fairly easy hex string  digits use Long allow leading zeros Integer length check trivial,NumberUtils createLong handle hex numbers createInteger handles hex octal seems odd NumberUtils createNumber assumes hex numbers Integer handle bigger Hex numbers trivial fix createLong use Long decode instead valueOf clear done originally decode method added Integer Long Java Fixing createNumber also fairly easy hex string digits use Long allow leading zeros Integer length check trivial,1
0,Lang,FastDateParser handle white space properly,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,1
0,Lang,StringIndexOutOfBoundsException calling unescapeHtml4 03,calling unescapeHtml4 String 03 String contains characters Exception thrown Exception thread main java lang StringIndexOutOfBoundsException String index range 4 java lang String charAt String java 686 org apache commons lang3 text translate NumericEntityUnescaper translate NumericEntityUnescaper java 49 org apache commons lang3 text translate AggregateTranslator translate AggregateTranslator java 53 org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java 88 org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java 60 org apache commons lang3 StringEscapeUtils unescapeHtml4 StringEscapeUtils java 351,calling unescapeHtml String  String contains characters Exception thrown Exception thread main java lang StringIndexOutOfBoundsException String index range  java lang String charAt String java  org apache commons lang text translate NumericEntityUnescaper translate NumericEntityUnescaper java  org apache commons lang text translate AggregateTranslator translate AggregateTranslator java  org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java  org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java  org apache commons lang StringEscapeUtils unescapeHtml StringEscapeUtils java ,calling unescapeHtml String String contains characters Exception thrown Exception thread main java lang StringIndexOutOfBoundsException String index range java lang String charAt String java org apache commons lang text translate NumericEntityUnescaper translate NumericEntityUnescaper java org apache commons lang text translate AggregateTranslator translate AggregateTranslator java org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java org apache commons lang StringEscapeUtils unescapeHtml StringEscapeUtils java,1
0,Lang,FastDateFormat format outputs incorrect week year locale respected,FastDateFormat apparently respect locale sent creation outputting week year e g ww format seems use settings system locale firstDayOfWeek minimalDaysInFirstWeek depending year may result incorrect week number output simple test program demonstrate problem comparing SimpleDateFormat gets week number right import java util Calendar import java util Date import java util Locale import java text SimpleDateFormat import org apache commons lang time FastDateFormat public class FastDateFormatWeekBugDemo public static void main String args Locale setDefault new Locale en US Locale locale new Locale sv SE Calendar cal Calendar getInstance setting locale change outcome cal set 2010 0 1 12 0 0 Date cal getTime System println Target date FastDateFormat fdf FastDateFormat getInstance EEEE week ww locale SimpleDateFormat sdf new SimpleDateFormat EEEE week ww locale System println FastDateFormat fdf format output FastDateFormat fredag week 01 System println SimpleDateFormat sdf format output SimpleDateFormat fredag week 53 sv SE passed Locale setDefault instead en US FastDateFormat SimpleDateFormat output correct week number,FastDateFormat apparently respect locale sent creation outputting week year e g ww format seems use settings system locale firstDayOfWeek minimalDaysInFirstWeek depending year may result incorrect week number output simple test program demonstrate problem comparing SimpleDateFormat gets week number right import java util Calendar import java util Date import java util Locale import java text SimpleDateFormat import org apache commons lang time FastDateFormat public class FastDateFormatWeekBugDemo public static void main String args Locale setDefault new Locale en US Locale locale new Locale sv SE Calendar cal Calendar getInstance setting locale change outcome cal set       Date cal getTime System println Target date FastDateFormat fdf FastDateFormat getInstance EEEE week ww locale SimpleDateFormat sdf new SimpleDateFormat EEEE week ww locale System println FastDateFormat fdf format output FastDateFormat fredag week  System println SimpleDateFormat sdf format output SimpleDateFormat fredag week  sv SE passed Locale setDefault instead en US FastDateFormat SimpleDateFormat output correct week number,FastDateFormat apparently respect locale sent creation outputting week year e g ww format seems use settings system locale firstDayOfWeek minimalDaysInFirstWeek depending year may result incorrect week number output simple test program demonstrate problem comparing SimpleDateFormat gets week number right import java util Calendar import java util Date import java util Locale import java text SimpleDateFormat import org apache commons lang time FastDateFormat public class FastDateFormatWeekBugDemo public static void main String args Locale setDefault new Locale en US Locale locale new Locale sv SE Calendar cal Calendar getInstance setting locale change outcome cal set Date cal getTime System println Target date FastDateFormat fdf FastDateFormat getInstance EEEE week ww locale SimpleDateFormat sdf new SimpleDateFormat EEEE week ww locale System println FastDateFormat fdf format output FastDateFormat fredag week System println SimpleDateFormat sdf format output SimpleDateFormat fredag week sv SE passed Locale setDefault instead en US FastDateFormat SimpleDateFormat output correct week number,1
0,Lang,FastDateFormat z pattern respect timezone Calendar instances passed format,work LANG 462 introduced time zone formatting bug FastDateFormat commons lang3 problem seen snippet Always prints timezone name machine default timezone ignoring TZ set calendar even though printed time respects calendar TZ Calendar myCal Calendar getInstance TimeZone getTimeZone US Central System println FastDateFormat getInstance h mma z format myCal happen US Central print right thing try US Eastern US Pacific etc print time correct timezone timezone name end z pattern always system default timezone regression commons lang 2 x Basically forced time zone code removed TimeZoneNameRule class stopped respecting Calendar instance timezone instead always uses mTimeZone FastDateFormat instance supposed used formatting timezone less objects Date long removal forced time zone stuff surely right thing mess think fix change TimeZoneNameRule inner class take TimeZone instance rather use TimeZone Calendar instance passed appendTo like TimeZoneNumberRule Presumably efficiency one would use getTimeZoneDisplay package static method quickly retrieve required timezone display name,work LANG  introduced time zone formatting bug FastDateFormat commons lang problem seen snippet Always prints timezone name machine default timezone ignoring TZ set calendar even though printed time respects calendar TZ Calendar myCal Calendar getInstance TimeZone getTimeZone US Central System println FastDateFormat getInstance h mma z format myCal happen US Central print right thing try US Eastern US Pacific etc print time correct timezone timezone name end z pattern always system default timezone regression commons lang  x Basically forced time zone code removed TimeZoneNameRule class stopped respecting Calendar instance timezone instead always uses mTimeZone FastDateFormat instance supposed used formatting timezone less objects Date long removal forced time zone stuff surely right thing mess think fix change TimeZoneNameRule inner class take TimeZone instance rather use TimeZone Calendar instance passed appendTo like TimeZoneNumberRule Presumably efficiency one would use getTimeZoneDisplay package static method quickly retrieve required timezone display name,work LANG introduced time zone formatting bug FastDateFormat commons lang problem seen snippet Always prints timezone name machine default timezone ignoring TZ set calendar even though printed time respects calendar TZ Calendar myCal Calendar getInstance TimeZone getTimeZone US Central System println FastDateFormat getInstance h mma z format myCal happen US Central print right thing try US Eastern US Pacific etc print time correct timezone timezone name end z pattern always system default timezone regression commons lang x Basically forced time zone code removed TimeZoneNameRule class stopped respecting Calendar instance timezone instead always uses mTimeZone FastDateFormat instance supposed used formatting timezone less objects Date long removal forced time zone stuff surely right thing mess think fix change TimeZoneNameRule inner class take TimeZone instance rather use TimeZone Calendar instance passed appendTo like TimeZoneNumberRule Presumably efficiency one would use getTimeZoneDisplay package static method quickly retrieve required timezone display name,1
0,Lang,DateUtils isSameLocalTime work correct,Hi think found bug DateUtils class method isSameLocalTime Example Calendar Calendar getInstance setTimeInMillis 1297364400000L Calendar b Calendar getInstance b setTimeInMillis 1297321200000L Assert assertFalse DateUtils isSameLocalTime b method compares cal1 get Calendar HOUR cal2 get Calendar HOUR think cal1 get Calendar HOUR DAY cal2 get Calendar HOUR DAY,Hi think found bug DateUtils class method isSameLocalTime Example Calendar Calendar getInstance setTimeInMillis L Calendar b Calendar getInstance b setTimeInMillis L Assert assertFalse DateUtils isSameLocalTime b method compares cal get Calendar HOUR cal get Calendar HOUR think cal get Calendar HOUR DAY cal get Calendar HOUR DAY,Hi think found bug DateUtils class method isSameLocalTime Example Calendar Calendar getInstance setTimeInMillis L Calendar b Calendar getInstance b setTimeInMillis L Assert assertFalse DateUtils isSameLocalTime b method compares cal get Calendar HOUR cal get Calendar HOUR think cal get Calendar HOUR DAY cal get Calendar HOUR DAY,1
0,Lang,NumberUtils createNumber thows StringIndexOutOfBoundsException l passed,Seems similar LANG 300 except place digit front l L throws StringIndexOutOfBoundsException instead,Seems similar LANG  except place digit front l L throws StringIndexOutOfBoundsException instead,Seems similar LANG except place digit front l L throws StringIndexOutOfBoundsException instead,1
0,Lang,ExtendedMessageFormat OutOfMemory custom format registry pattern containing single quotes,using ExtendedMessageFormat custom format registry pattern conatining single quotes OutOfMemoryError occur Example cause error ExtendedMessageFormatTest java private static Map String Object formatRegistry new HashMap String Object static formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory public static void main String args ExtendedMessageFormat mf new ExtendedMessageFormat dummy test formatRegistry String formattedPattern mf format new String great System println formattedPattern following change starting line 421 2 4 release seems fix problem ExtendedMessageFormat java CURRENT Broken escapingOn c start QUOTE return appendTo null null appendTo append QUOTE WORKING escapingOn c start QUOTE next pos return appendTo null null appendTo append QUOTE,using ExtendedMessageFormat custom format registry pattern conatining single quotes OutOfMemoryError occur Example cause error ExtendedMessageFormatTest java private static Map String Object formatRegistry new HashMap String Object static formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory public static void main String args ExtendedMessageFormat mf new ExtendedMessageFormat dummy test formatRegistry String formattedPattern mf format new String great System println formattedPattern following change starting line    release seems fix problem ExtendedMessageFormat java CURRENT Broken escapingOn c start QUOTE return appendTo null null appendTo append QUOTE WORKING escapingOn c start QUOTE next pos return appendTo null null appendTo append QUOTE,using ExtendedMessageFormat custom format registry pattern conatining single quotes OutOfMemoryError occur Example cause error ExtendedMessageFormatTest java private static Map String Object formatRegistry new HashMap String Object static formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory public static void main String args ExtendedMessageFormat mf new ExtendedMessageFormat dummy test formatRegistry String formattedPattern mf format new String great System println formattedPattern following change starting line release seems fix problem ExtendedMessageFormat java CURRENT Broken escapingOn c start QUOTE return appendTo null null appendTo append QUOTE WORKING escapingOn c start QUOTE next pos return appendTo null null appendTo append QUOTE,1
0,Lang,DateFormatUtils format correctly change Calendar TimeZone certain situations,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z commonly constructed cal new GregorianCalendar 2009 9 16 8 42 16 unit test work time zone constructing GMT 8 rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime   T   Z commonly constructed cal new GregorianCalendar       unit test work time zone constructing GMT  rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime   T   Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime Z commonly constructed cal new GregorianCalendar unit test work time zone constructing GMT rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,1
0,Lang,NumberUtils isNumber Return True Valid Number Trailing Decimal Place,NumberUtils isNumber return true valid number ending trailing decimal place e g 2 considered number new BigDecimal 2 works fine could done adding code line 1444 chars e || chars E block chars hasDecPoint || hasExp two decimal points dec exponent return false return foundDigit single trailing decimal point non exponent ok,NumberUtils isNumber return true valid number ending trailing decimal place e g  considered number new BigDecimal  works fine could done adding code line  chars e || chars E block chars hasDecPoint || hasExp two decimal points dec exponent return false return foundDigit single trailing decimal point non exponent ok,NumberUtils isNumber return true valid number ending trailing decimal place e g considered number new BigDecimal works fine could done adding code line chars e || chars E block chars hasDecPoint || hasExp two decimal points dec exponent return false return foundDigit single trailing decimal point non exponent ok,1
0,Lang,StringUtils methods handle Unicode 2 0 supplementary characters correctly,StringUtils containsAny methods incorrectly matches Unicode 2 0 supplementary characters example define test fixture Unicode character U 20000 U 20000 written Java source \uD840\uDC00 private static final String CharU20000 \uD840\uDC00 private static final String CharU20001 \uD840\uDC01 see Unicode supplementary characters correctly implemented JRE call assertEquals 1 CharU20000 indexOf CharU20001 broken assertEquals false StringUtils containsAny CharU20000 CharU20001 assertEquals false StringUtils containsAny CharU20001 CharU20000 fine assertEquals true StringUtils contains CharU20000 CharU20001 CharU20000 assertEquals true StringUtils contains CharU20000 CharU20001 CharU20001 assertEquals true StringUtils contains CharU20000 CharU20000 assertEquals false StringUtils contains CharU20000 CharU20001 method calls JRE perform match want know http java sun com developer technicalArticles Intl Supplementary,StringUtils containsAny methods incorrectly matches Unicode   supplementary characters example define test fixture Unicode character U  U  written Java source \uD\uDC private static final String CharU \uD\uDC private static final String CharU \uD\uDC see Unicode supplementary characters correctly implemented JRE call assertEquals  CharU indexOf CharU broken assertEquals false StringUtils containsAny CharU CharU assertEquals false StringUtils containsAny CharU CharU fine assertEquals true StringUtils contains CharU CharU CharU assertEquals true StringUtils contains CharU CharU CharU assertEquals true StringUtils contains CharU CharU assertEquals false StringUtils contains CharU CharU method calls JRE perform match want know http java sun com developer technicalArticles Intl Supplementary,StringUtils containsAny methods incorrectly matches Unicode supplementary characters example define test fixture Unicode character U U written Java source \uD\uDC private static final String CharU \uD\uDC private static final String CharU \uD\uDC see Unicode supplementary characters correctly implemented JRE call assertEquals CharU indexOf CharU broken assertEquals false StringUtils containsAny CharU CharU assertEquals false StringUtils containsAny CharU CharU fine assertEquals true StringUtils contains CharU CharU CharU assertEquals true StringUtils contains CharU CharU CharU assertEquals true StringUtils contains CharU CharU assertEquals false StringUtils contains CharU CharU method calls JRE perform match want know http java sun com developer technicalArticles Intl Supplementary,1
0,Lang,lang DateUtils truncate method buggy dealing DST switching hours,Try truncate 2004 10 31 01 00 00 MDT hour actually get 2004 10 31 01 00 00 MST one hour input hour truncate 2004 10 31 01 00 00 MDT Date oct31 01MDT new Date 1099206000000L Date result DateUtils truncate oct31 01MDT Calendar HOUR DAY assertEquals oct31 01MDT result,Try truncate       MDT hour actually get       MST one hour input hour truncate       MDT Date oct MDT new Date L Date result DateUtils truncate oct MDT Calendar HOUR DAY assertEquals oct MDT result,Try truncate MDT hour actually get MST one hour input hour truncate MDT Date oct MDT new Date L Date result DateUtils truncate oct MDT Calendar HOUR DAY assertEquals oct MDT result,1
0,Lang,unescapeXml 12345678 12345678,Following test EntitiesTest java fails public void testNumberOverflow throws Exception doTestUnescapeEntity 12345678 12345678 doTestUnescapeEntity x 12345678 x 12345678 doTestUnescapeEntity x12345678 x12345678 doTestUnescapeEntity x x12345678 x x12345678 Maximim value char 0xFFFF 12345678 invalid entity reference left,Following test EntitiesTest java fails public void testNumberOverflow throws Exception doTestUnescapeEntity   doTestUnescapeEntity x  x  doTestUnescapeEntity x x doTestUnescapeEntity x x x x Maximim value char xFFFF  invalid entity reference left,Following test EntitiesTest java fails public void testNumberOverflow throws Exception doTestUnescapeEntity doTestUnescapeEntity x x doTestUnescapeEntity x x doTestUnescapeEntity x x x x Maximim value char xFFFF invalid entity reference left,1
0,Lang,LocaleUtils toLocale rejects strings language variant,LocaleUtils toLocale throws exception strings containing language variant country code example fr POSIX string produced JDK instanciating Locale empty string country new Locale fr POSIX toString According javadoc Locale class variant allowed language code country code Commons Configuration handles case PropertyConverter toLocale method like replace implementation one provided LocaleUtils tests fail due case,LocaleUtils toLocale throws exception strings containing language variant country code example fr POSIX string produced JDK instanciating Locale empty string country new Locale fr POSIX toString According javadoc Locale class variant allowed language code country code Commons Configuration handles case PropertyConverter toLocale method like replace implementation one provided LocaleUtils tests fail due case,LocaleUtils toLocale throws exception strings containing language variant country code example fr POSIX string produced JDK instanciating Locale empty string country new Locale fr POSIX toString According javadoc Locale class variant allowed language code country code Commons Configuration handles case PropertyConverter toLocale method like replace implementation one provided LocaleUtils tests fail due case,1
0,Lang,Dates round behaves incorrectly minutes seconds,Get unexpected output rounding minutes seconds public void testRound Calendar testCalendar Calendar getInstance TimeZone getTimeZone GMT testCalendar set 2007 6 2 8 9 50 Date date testCalendar getTime System println round date System println round DateUtils round date Calendar MINUTE 2 1 produces round Mon Jul 02 03 09 50 CDT 2007 round Mon Jul 02 03 10 00 CDT 2007 – would expect 2 2 2 3 produces round Mon Jul 02 03 09 50 CDT 2007 round Mon Jul 02 03 01 00 CDT 2007 – appears wrong,Get unexpected output rounding minutes seconds public void testRound Calendar testCalendar Calendar getInstance TimeZone getTimeZone GMT testCalendar set       Date date testCalendar getTime System println round date System println round DateUtils round date Calendar MINUTE   produces round Mon Jul     CDT  round Mon Jul     CDT  – would expect     produces round Mon Jul     CDT  round Mon Jul     CDT  – appears wrong,Get unexpected output rounding minutes seconds public void testRound Calendar testCalendar Calendar getInstance TimeZone getTimeZone GMT testCalendar set Date date testCalendar getTime System println round date System println round DateUtils round date Calendar MINUTE produces round Mon Jul CDT round Mon Jul CDT – would expect produces round Mon Jul CDT round Mon Jul CDT – appears wrong,1
0,Lang,StringUtils methods handle Unicode 2 0 supplementary characters correctly,StringUtils containsAny methods incorrectly matches Unicode 2 0 supplementary characters example define test fixture Unicode character U 20000 U 20000 written Java source \uD840\uDC00 private static final String CharU20000 \uD840\uDC00 private static final String CharU20001 \uD840\uDC01 see Unicode supplementary characters correctly implemented JRE call assertEquals 1 CharU20000 indexOf CharU20001 broken assertEquals false StringUtils containsAny CharU20000 CharU20001 assertEquals false StringUtils containsAny CharU20001 CharU20000 fine assertEquals true StringUtils contains CharU20000 CharU20001 CharU20000 assertEquals true StringUtils contains CharU20000 CharU20001 CharU20001 assertEquals true StringUtils contains CharU20000 CharU20000 assertEquals false StringUtils contains CharU20000 CharU20001 method calls JRE perform match want know http java sun com developer technicalArticles Intl Supplementary,StringUtils containsAny methods incorrectly matches Unicode   supplementary characters example define test fixture Unicode character U  U  written Java source \uD\uDC private static final String CharU \uD\uDC private static final String CharU \uD\uDC see Unicode supplementary characters correctly implemented JRE call assertEquals  CharU indexOf CharU broken assertEquals false StringUtils containsAny CharU CharU assertEquals false StringUtils containsAny CharU CharU fine assertEquals true StringUtils contains CharU CharU CharU assertEquals true StringUtils contains CharU CharU CharU assertEquals true StringUtils contains CharU CharU assertEquals false StringUtils contains CharU CharU method calls JRE perform match want know http java sun com developer technicalArticles Intl Supplementary,StringUtils containsAny methods incorrectly matches Unicode supplementary characters example define test fixture Unicode character U U written Java source \uD\uDC private static final String CharU \uD\uDC private static final String CharU \uD\uDC see Unicode supplementary characters correctly implemented JRE call assertEquals CharU indexOf CharU broken assertEquals false StringUtils containsAny CharU CharU assertEquals false StringUtils containsAny CharU CharU fine assertEquals true StringUtils contains CharU CharU CharU assertEquals true StringUtils contains CharU CharU CharU assertEquals true StringUtils contains CharU CharU assertEquals false StringUtils contains CharU CharU method calls JRE perform match want know http java sun com developer technicalArticles Intl Supplementary,1
0,Lang,ArrayUtils addAll array1 array2 handle mixed types well,ArrayUtils addAll array1 array2 handle mixed array types well stack trace Number st ArrayUtils addAll new Integer 1 new Long 2L starts java lang ArrayStoreException java lang System arraycopy Native Method org apache commons lang3 ArrayUtils addAll ArrayUtils java 2962 obvious would lot clearer method threw IlegalArgumentException similar,ArrayUtils addAll array array handle mixed array types well stack trace Number st ArrayUtils addAll new Integer  new Long L starts java lang ArrayStoreException java lang System arraycopy Native Method org apache commons lang ArrayUtils addAll ArrayUtils java  obvious would lot clearer method threw IlegalArgumentException similar,ArrayUtils addAll array array handle mixed array types well stack trace Number st ArrayUtils addAll new Integer new Long L starts java lang ArrayStoreException java lang System arraycopy Native Method org apache commons lang ArrayUtils addAll ArrayUtils java obvious would lot clearer method threw IlegalArgumentException similar,1
0,Lang,StringUtils replaceEach Bug Missing Documentation,following Test Case replaceEach fails null pointer exception expected StringUtils methods null friendly use case stuff Values replacementList want check whether null admit use case perfect unclear happens replace outlined three expectations test case course one met decided none possible propose update documentation happens null passed replacement string import static org junit Assert assertEquals import org apache commons lang StringUtils import org junit Test public class StringUtilsTest Test public void replaceEach String original Hello World String searchList Hello World String replacementList Greetings null String result StringUtils replaceEach original searchList replacementList assertEquals Greetings result perhaps ok well assertEquals Greetings World result even assertEquals Greetings null result,following Test Case replaceEach fails null pointer exception expected StringUtils methods null friendly use case stuff Values replacementList want check whether null admit use case perfect unclear happens replace outlined three expectations test case course one met decided none possible propose update documentation happens null passed replacement string import static org junit Assert assertEquals import org apache commons lang StringUtils import org junit Test public class StringUtilsTest Test public void replaceEach String original Hello World String searchList Hello World String replacementList Greetings null String result StringUtils replaceEach original searchList replacementList assertEquals Greetings result perhaps ok well assertEquals Greetings World result even assertEquals Greetings null result,following Test Case replaceEach fails null pointer exception expected StringUtils methods null friendly use case stuff Values replacementList want check whether null admit use case perfect unclear happens replace outlined three expectations test case course one met decided none possible propose update documentation happens null passed replacement string import static org junit Assert assertEquals import org apache commons lang StringUtils import org junit Test public class StringUtilsTest Test public void replaceEach String original Hello World String searchList Hello World String replacementList Greetings null String result StringUtils replaceEach original searchList replacementList assertEquals Greetings result perhaps ok well assertEquals Greetings World result even assertEquals Greetings null result,1
0,Lang,StringEscapeUtils escapeJavaScript method escape \ make IE render page uncorrectly,Javascripts including IE parse scripts uncorrectly actually escaped \ example document getElementById test value script alert \ aaa\ script expression make IE render page uncorrect document getElementById test value script alert \ aaa\ \ script Btw Spring JavascriptEscape behavor correct Try run codes find difference String script alert aaa script String str org springframework web util JavaScriptUtils javaScriptEscape System println Spring JS Escape str str org apache commons lang StringEscapeUtils escapeJavaScript System println Apache Common Lang JS Escape str,Javascripts including IE parse scripts uncorrectly actually escaped \ example document getElementById test value script alert \ aaa\ script expression make IE render page uncorrect document getElementById test value script alert \ aaa\ \ script Btw Spring JavascriptEscape behavor correct Try run codes find difference String script alert aaa script String str org springframework web util JavaScriptUtils javaScriptEscape System println Spring JS Escape str str org apache commons lang StringEscapeUtils escapeJavaScript System println Apache Common Lang JS Escape str,Javascripts including IE parse scripts uncorrectly actually escaped \ example document getElementById test value script alert \ aaa\ script expression make IE render page uncorrect document getElementById test value script alert \ aaa\ \ script Btw Spring JavascriptEscape behavor correct Try run codes find difference String script alert aaa script String str org springframework web util JavaScriptUtils javaScriptEscape System println Spring JS Escape str str org apache commons lang StringEscapeUtils escapeJavaScript System println Apache Common Lang JS Escape str,1
0,Lang,StopWatch suspend acts split followed stop,opinion bug suspend acts split followed stop see StopWatch sw new StopWatch sw start Thread sleep 1000 sw suspend Time 1 ok System println sw getTime Thread sleep 2000 Time 1 ok System println sw getTime sw resume Thread sleep 3000 sw suspend Time 2 ok System println sw getTime Thread sleep 4000 Time 2 ok System println sw getTime Thread sleep 5000 sw stop Time 2 Time 3 ok System println sw getTime suspend resume like pause time counter continue following stop call increase time counter,opinion bug suspend acts split followed stop see StopWatch sw new StopWatch sw start Thread sleep  sw suspend Time  ok System println sw getTime Thread sleep  Time  ok System println sw getTime sw resume Thread sleep  sw suspend Time  ok System println sw getTime Thread sleep  Time  ok System println sw getTime Thread sleep  sw stop Time  Time  ok System println sw getTime suspend resume like pause time counter continue following stop call increase time counter,opinion bug suspend acts split followed stop see StopWatch sw new StopWatch sw start Thread sleep sw suspend Time ok System println sw getTime Thread sleep Time ok System println sw getTime sw resume Thread sleep sw suspend Time ok System println sw getTime Thread sleep Time ok System println sw getTime Thread sleep sw stop Time Time ok System println sw getTime suspend resume like pause time counter continue following stop call increase time counter,1
0,Lang,DurationFormatUtils returns wrong result,DurationFormatUtils returns wrong result oddly Date set Dec 31 2005 following code result String 2 way tested 2 1 2 2 Calendar cal Calendar getInstance cal set Calendar MONTH Calendar DECEMBER cal set Calendar DAY MONTH 31 cal set Calendar YEAR 2005 cal set Calendar HOUR DAY 0 cal set Calendar MINUTE 0 cal set Calendar SECOND 0 cal set Calendar MILLISECOND 0 String result DurationFormatUtils formatPeriod cal getTimeInMillis System currentTimeMillis MM System println result,DurationFormatUtils returns wrong result oddly Date set Dec   following code result String  way tested     Calendar cal Calendar getInstance cal set Calendar MONTH Calendar DECEMBER cal set Calendar DAY MONTH  cal set Calendar YEAR  cal set Calendar HOUR DAY  cal set Calendar MINUTE  cal set Calendar SECOND  cal set Calendar MILLISECOND  String result DurationFormatUtils formatPeriod cal getTimeInMillis System currentTimeMillis MM System println result,DurationFormatUtils returns wrong result oddly Date set Dec following code result String way tested Calendar cal Calendar getInstance cal set Calendar MONTH Calendar DECEMBER cal set Calendar DAY MONTH cal set Calendar YEAR cal set Calendar HOUR DAY cal set Calendar MINUTE cal set Calendar SECOND cal set Calendar MILLISECOND String result DurationFormatUtils formatPeriod cal getTimeInMillis System currentTimeMillis MM System println result,1
0,Lang,ValuedEnum compareTo Object typesafe easily could,int org apache commons lang enums ValuedEnum compareTo Object typesafe int values return 0 even two totally different sub classes ValuedEnum,int org apache commons lang enums ValuedEnum compareTo Object typesafe int values return  even two totally different sub classes ValuedEnum,int org apache commons lang enums ValuedEnum compareTo Object typesafe int values return even two totally different sub classes ValuedEnum,1
0,Lang,StringEscapeUtils escapeJava String escapes characters,Commons Lang 2 4 StringEscapeUtils escapeJava String escapes characters valid escapable character Java strings tried Java escape unescape methods see similar problem Java escapable characters escaped escapeJava String bug may appeared unintended side effect fix LANG 363 Also javadoc escapeJava little included sentence describing differences Java Javascript strings respect escaping rules following JUnit3 test demonstrating bug import junit framework TestCase import org apache commons lang StringEscapeUtils public class StringEscapeUtilsTest extends TestCase public void testEscapeJavaWithSlash final String input String slash final String expected input final String actual StringEscapeUtils escapeJava input 2 4 StringEscapeUtils escapeJava String escapes characters valid character escape Java string assertEquals expected actual,Commons Lang   StringEscapeUtils escapeJava String escapes characters valid escapable character Java strings tried Java escape unescape methods see similar problem Java escapable characters escaped escapeJava String bug may appeared unintended side effect fix LANG  Also javadoc escapeJava little included sentence describing differences Java Javascript strings respect escaping rules following JUnit test demonstrating bug import junit framework TestCase import org apache commons lang StringEscapeUtils public class StringEscapeUtilsTest extends TestCase public void testEscapeJavaWithSlash final String input String slash final String expected input final String actual StringEscapeUtils escapeJava input   StringEscapeUtils escapeJava String escapes characters valid character escape Java string assertEquals expected actual,Commons Lang StringEscapeUtils escapeJava String escapes characters valid escapable character Java strings tried Java escape unescape methods see similar problem Java escapable characters escaped escapeJava String bug may appeared unintended side effect fix LANG Also javadoc escapeJava little included sentence describing differences Java Javascript strings respect escaping rules following JUnit test demonstrating bug import junit framework TestCase import org apache commons lang StringEscapeUtils public class StringEscapeUtilsTest extends TestCase public void testEscapeJavaWithSlash final String input String slash final String expected input final String actual StringEscapeUtils escapeJava input StringEscapeUtils escapeJava String escapes characters valid character escape Java string assertEquals expected actual,1
0,Lang,ClassUtils getShortClassName work array seems add semicolon end,semicolon introduced class name end arrays String sArray new String 2 sArray 0 mark sArray 1 cool String simpleString chris assertEquals String ClassUtils getShortClassName simpleString null assertEquals String ClassUtils getShortClassName sArray null,semicolon introduced class name end arrays String sArray new String  sArray  mark sArray  cool String simpleString chris assertEquals String ClassUtils getShortClassName simpleString null assertEquals String ClassUtils getShortClassName sArray null,semicolon introduced class name end arrays String sArray new String sArray mark sArray cool String simpleString chris assertEquals String ClassUtils getShortClassName simpleString null assertEquals String ClassUtils getShortClassName sArray null,1
0,Lang,EqualsBuilder compare BigDecimals correctly,comparing BigDecimal comparing made using equals compareTo appropriate case BigDecimal,comparing BigDecimal comparing made using equals compareTo appropriate case BigDecimal,comparing BigDecimal comparing made using equals compareTo appropriate case BigDecimal,1
0,Lang,NumberUtils isNumber String right String 1 1L,1 1L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint, L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint,L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint,1
0,Lang,text ExtendedMessageFormat override java text MessageFormat equals Object,Findbugs Bug org apache commons lang3 text ExtendedMessageFormat override java text MessageFormat equals Object Pattern id EQ DOESNT OVERRIDE EQUALS type Eq category STYLE class extends class defines equals method adds fields define equals method Thus equality instances class ignore identity subclass added fields sure intended need override equals method Even need override equals method consider overriding anyway document fact equals method subclass return result invoking super equals,Findbugs Bug org apache commons lang text ExtendedMessageFormat override java text MessageFormat equals Object Pattern id EQ DOESNT OVERRIDE EQUALS type Eq category STYLE class extends class defines equals method adds fields define equals method Thus equality instances class ignore identity subclass added fields sure intended need override equals method Even need override equals method consider overriding anyway document fact equals method subclass return result invoking super equals,Findbugs Bug org apache commons lang text ExtendedMessageFormat override java text MessageFormat equals Object Pattern id EQ DOESNT OVERRIDE EQUALS type Eq category STYLE class extends class defines equals method adds fields define equals method Thus equality instances class ignore identity subclass added fields sure intended need override equals method Even need override equals method consider overriding anyway document fact equals method subclass return result invoking super equals,1
0,Lang,LookupTranslator accepts CharSequence input fails work implementations String,core org apache commons lang3 text translate HashMap CharSequence CharSequence lookupMap Javadoc CharSequence emphasis mine interface refine general contracts equals hashCode methods result comparing two objects implement CharSequence therefore general undefined object may implemented different class guarantee class capable testing instances equality therefore inappropriate use arbitrary CharSequence instances elements set keys map current implementation causes code following work expected CharSequence cs1 1 2 CharSequence cs2 CharBuffer wrap 1 2 toCharArray System println StringEscapeUtils ESCAPE HTML4 translate cs1 System println StringEscapeUtils ESCAPE HTML4 translate cs2 gives following results identical 1 lt 2 1 2 problem minimum CharBuffer equals even documented Javadoc char buffer equal type object lookup CharBuffer Map always fail compared String implementations contains obvious work around instead use something along lines either following System println StringEscapeUtils ESCAPE HTML4 translate cs2 toString System println StringEscapeUtils escapeHtml4 cs2 toString forces everything back String However practical working large sets data would require significant heap allocations garbage collection concerns actually trying use translate method outputs Writer simplified examples omit Another option considering use custom CharSequence wrapper around char implements hashCode equals work implemented String However interesting due symmetric assumption interesting String equals currently implemented using instanceof even though String final,core org apache commons lang text translate HashMap CharSequence CharSequence lookupMap Javadoc CharSequence emphasis mine interface refine general contracts equals hashCode methods result comparing two objects implement CharSequence therefore general undefined object may implemented different class guarantee class capable testing instances equality therefore inappropriate use arbitrary CharSequence instances elements set keys map current implementation causes code following work expected CharSequence cs   CharSequence cs CharBuffer wrap   toCharArray System println StringEscapeUtils ESCAPE HTML translate cs System println StringEscapeUtils ESCAPE HTML translate cs gives following results identical  lt    problem minimum CharBuffer equals even documented Javadoc char buffer equal type object lookup CharBuffer Map always fail compared String implementations contains obvious work around instead use something along lines either following System println StringEscapeUtils ESCAPE HTML translate cs toString System println StringEscapeUtils escapeHtml cs toString forces everything back String However practical working large sets data would require significant heap allocations garbage collection concerns actually trying use translate method outputs Writer simplified examples omit Another option considering use custom CharSequence wrapper around char implements hashCode equals work implemented String However interesting due symmetric assumption interesting String equals currently implemented using instanceof even though String final,core org apache commons lang text translate HashMap CharSequence CharSequence lookupMap Javadoc CharSequence emphasis mine interface refine general contracts equals hashCode methods result comparing two objects implement CharSequence therefore general undefined object may implemented different class guarantee class capable testing instances equality therefore inappropriate use arbitrary CharSequence instances elements set keys map current implementation causes code following work expected CharSequence cs CharSequence cs CharBuffer wrap toCharArray System println StringEscapeUtils ESCAPE HTML translate cs System println StringEscapeUtils ESCAPE HTML translate cs gives following results identical lt problem minimum CharBuffer equals even documented Javadoc char buffer equal type object lookup CharBuffer Map always fail compared String implementations contains obvious work around instead use something along lines either following System println StringEscapeUtils ESCAPE HTML translate cs toString System println StringEscapeUtils escapeHtml cs toString forces everything back String However practical working large sets data would require significant heap allocations garbage collection concerns actually trying use translate method outputs Writer simplified examples omit Another option considering use custom CharSequence wrapper around char implements hashCode equals work implemented String However interesting due symmetric assumption interesting String equals currently implemented using instanceof even though String final,1
0,Lang,TypeUtils getTypeArguments misses type arguments partially assigned classes,failing test code add TypeUtilsTest testGetTypeArguments typeVarAssigns TypeUtils getTypeArguments class class Assert assertEquals 2 typeVarAssigns size Assert assertEquals String class typeVarAssigns get class getTypeParameters 0 Assert assertEquals class getTypeParameters 0 typeVarAssigns get class getTypeParameters 1 pass based public interface K V public class implements String case fails current code ignores class due specifying type variables obviously incorrect report extrapolated offline report received Hen,failing test code add TypeUtilsTest testGetTypeArguments typeVarAssigns TypeUtils getTypeArguments class class Assert assertEquals  typeVarAssigns size Assert assertEquals String class typeVarAssigns get class getTypeParameters  Assert assertEquals class getTypeParameters  typeVarAssigns get class getTypeParameters  pass based public interface K V public class implements String case fails current code ignores class due specifying type variables obviously incorrect report extrapolated offline report received Hen,failing test code add TypeUtilsTest testGetTypeArguments typeVarAssigns TypeUtils getTypeArguments class class Assert assertEquals typeVarAssigns size Assert assertEquals String class typeVarAssigns get class getTypeParameters Assert assertEquals class getTypeParameters typeVarAssigns get class getTypeParameters pass based public interface K V public class implements String case fails current code ignores class due specifying type variables obviously incorrect report extrapolated offline report received Hen,1
0,Lang,Method createNumber NumberUtils work floating point numbers Float,Method createNumber NumberUtils trying parse string floating point number always first Float cause send string number need Double even BigDecimal number truncate accommodate Float without exception thrown fact returning ever neither Double BigDecimal,Method createNumber NumberUtils trying parse string floating point number always first Float cause send string number need Double even BigDecimal number truncate accommodate Float without exception thrown fact returning ever neither Double BigDecimal,Method createNumber NumberUtils trying parse string floating point number always first Float cause send string number need Double even BigDecimal number truncate accommodate Float without exception thrown fact returning ever neither Double BigDecimal,1
0,Lang,RandomStringUtils random count 0 0 false false universe random always throws java lang ArrayIndexOutOfBoundsException,commons lang 2 6 line 250 ch chars random nextInt gap start line code takes random int fetch char chars array regardless size Besides start useless Fixed version would ch chars random nextInt gap chars length user pass 0 end array null empty line ends exception,commons lang   line  ch chars random nextInt gap start line code takes random int fetch char chars array regardless size Besides start useless Fixed version would ch chars random nextInt gap chars length user pass  end array null empty line ends exception,commons lang line ch chars random nextInt gap start line code takes random int fetch char chars array regardless size Besides start useless Fixed version would ch chars random nextInt gap chars length user pass end array null empty line ends exception,1
0,Lang,infinite loop Fraction reduce numerator 0,Summary pretty much says,Summary pretty much says,Summary pretty much says,1
0,Lang,Fix case insensitive string handling,String Case locale sensitive usually intended case insensitive comparisions Please see Common Bug 3 details,String Case locale sensitive usually intended case insensitive comparisions Please see Common Bug  details,String Case locale sensitive usually intended case insensitive comparisions Please see Common Bug details,1
0,Lang,StrBuilder appendFixedWidth handle nulls,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,1
0,Lang,SerializationUtils throws ClassNotFoundException cloning primitive classes,serializable object contains reference primitive class e g int class int class SerializationUtils throw ClassNotFoundException trying clone object import org apache commons lang3 SerializationUtils import org junit Test public class SerializationUtilsTest Test public void primitiveTypeClassSerialization Class primitiveType int class Class clone SerializationUtils clone primitiveType assertEquals primitiveType clone problem already reported java bug http bugs sun com view bug bug id 4171142 ObjectInputStream fixed since java version 1 4 SerializationUtils problem arises SerializationUtils internally use ClassLoaderAwareObjectInputStream overrides ObjectInputStream resoleClass method without delegating super method case ClassNotFoundException understand intention ClassLoaderAwareObjectInputStream implementation also implement fallback original implementation example protected Class resolveClass ObjectStreamClass desc throws IOException ClassNotFoundException String name desc getName try return Class forName name false classLoader catch ClassNotFoundException ex try return Class forName name false Thread currentThread getContextClassLoader catch Exception e return super resolveClass desc code ObjectInputStream fixed java bug protected Class resolveClass ObjectStreamClass desc throws IOException ClassNotFoundException String name desc getName try return Class forName name false latestUserDefinedLoader catch ClassNotFoundException ex Class cl Class primClasses get name cl null return cl else throw ex,serializable object contains reference primitive class e g int class int class SerializationUtils throw ClassNotFoundException trying clone object import org apache commons lang SerializationUtils import org junit Test public class SerializationUtilsTest Test public void primitiveTypeClassSerialization Class primitiveType int class Class clone SerializationUtils clone primitiveType assertEquals primitiveType clone problem already reported java bug http bugs sun com view bug bug id  ObjectInputStream fixed since java version   SerializationUtils problem arises SerializationUtils internally use ClassLoaderAwareObjectInputStream overrides ObjectInputStream resoleClass method without delegating super method case ClassNotFoundException understand intention ClassLoaderAwareObjectInputStream implementation also implement fallback original implementation example protected Class resolveClass ObjectStreamClass desc throws IOException ClassNotFoundException String name desc getName try return Class forName name false classLoader catch ClassNotFoundException ex try return Class forName name false Thread currentThread getContextClassLoader catch Exception e return super resolveClass desc code ObjectInputStream fixed java bug protected Class resolveClass ObjectStreamClass desc throws IOException ClassNotFoundException String name desc getName try return Class forName name false latestUserDefinedLoader catch ClassNotFoundException ex Class cl Class primClasses get name cl null return cl else throw ex,serializable object contains reference primitive class e g int class int class SerializationUtils throw ClassNotFoundException trying clone object import org apache commons lang SerializationUtils import org junit Test public class SerializationUtilsTest Test public void primitiveTypeClassSerialization Class primitiveType int class Class clone SerializationUtils clone primitiveType assertEquals primitiveType clone problem already reported java bug http bugs sun com view bug bug id ObjectInputStream fixed since java version SerializationUtils problem arises SerializationUtils internally use ClassLoaderAwareObjectInputStream overrides ObjectInputStream resoleClass method without delegating super method case ClassNotFoundException understand intention ClassLoaderAwareObjectInputStream implementation also implement fallback original implementation example protected Class resolveClass ObjectStreamClass desc throws IOException ClassNotFoundException String name desc getName try return Class forName name false classLoader catch ClassNotFoundException ex try return Class forName name false Thread currentThread getContextClassLoader catch Exception e return super resolveClass desc code ObjectInputStream fixed java bug protected Class resolveClass ObjectStreamClass desc throws IOException ClassNotFoundException String name desc getName try return Class forName name false latestUserDefinedLoader catch ClassNotFoundException ex Class cl Class primClasses get name cl null return cl else throw ex,1
0,Lang,LocaleUtils toLocale parse strings starting underscore,Hi Javadocs Locale toString states language missing string begin underbar handled LocaleUtils toLocale method meant inversion method Locale toString fix ticket 328 handle well case fr P found fixing first bug attaching patch problems,Hi Javadocs Locale toString states language missing string begin underbar handled LocaleUtils toLocale method meant inversion method Locale toString fix ticket  handle well case fr P found fixing first bug attaching patch problems,Hi Javadocs Locale toString states language missing string begin underbar handled LocaleUtils toLocale method meant inversion method Locale toString fix ticket handle well case fr P found fixing first bug attaching patch problems,1
0,Lang,StringUtils equals relies undefined behavior,Since java lang CharSequence class first introduced 1 4 JavaDoc block contained following note interface refine general contracts equals hashCode methods result comparing two objects implement CharSequence therefore general undefined object may implemented different class guarantee class capable testing instances equality signature StringUtils equals method changed equals String String equals CharSequence CharSequence R920543 implementation still relied calling CharSequence equals Object even though general result undefined One example equals Object returns false even though CharSequences two objects represent equal sequences one object instance javax lang model element Name object String,Since java lang CharSequence class first introduced   JavaDoc block contained following note interface refine general contracts equals hashCode methods result comparing two objects implement CharSequence therefore general undefined object may implemented different class guarantee class capable testing instances equality signature StringUtils equals method changed equals String String equals CharSequence CharSequence R implementation still relied calling CharSequence equals Object even though general result undefined One example equals Object returns false even though CharSequences two objects represent equal sequences one object instance javax lang model element Name object String,Since java lang CharSequence class first introduced JavaDoc block contained following note interface refine general contracts equals hashCode methods result comparing two objects implement CharSequence therefore general undefined object may implemented different class guarantee class capable testing instances equality signature StringUtils equals method changed equals String String equals CharSequence CharSequence R implementation still relied calling CharSequence equals Object even though general result undefined One example equals Object returns false even though CharSequences two objects represent equal sequences one object instance javax lang model element Name object String,1
0,Lang,org apache commons lang3 math Fraction reduce Integer MIN VALUE 2 k,greatestCommonDivisor method class Fraction find gcd Integer MIN VALUE 2 k case triggered taking Integer MIN VALUE numerator Note case taking Integer MIN VALUE denominator handled explicitly getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int f Fraction getReducedFraction Integer MIN VALUE 2 assertEquals Integer MIN VALUE 2 f getNumerator assertEquals 1 f getDenominator public void testReduce f Fraction getFraction Integer MIN VALUE 2 result f reduce assertEquals Integer MIN VALUE 2 result getNumerator assertEquals 1 result getDenominator,greatestCommonDivisor method class Fraction find gcd Integer MIN VALUE  k case triggered taking Integer MIN VALUE numerator Note case taking Integer MIN VALUE denominator handled explicitly getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int f Fraction getReducedFraction Integer MIN VALUE  assertEquals Integer MIN VALUE  f getNumerator assertEquals  f getDenominator public void testReduce f Fraction getFraction Integer MIN VALUE  result f reduce assertEquals Integer MIN VALUE  result getNumerator assertEquals  result getDenominator,greatestCommonDivisor method class Fraction find gcd Integer MIN VALUE k case triggered taking Integer MIN VALUE numerator Note case taking Integer MIN VALUE denominator handled explicitly getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int f Fraction getReducedFraction Integer MIN VALUE assertEquals Integer MIN VALUE f getNumerator assertEquals f getDenominator public void testReduce f Fraction getFraction Integer MIN VALUE result f reduce assertEquals Integer MIN VALUE result getNumerator assertEquals result getDenominator,1
0,Mockito,Mockito create mock public class extends package private class,Even implemented think mockito throw normal exception time creation variant first creation returns wrong working mock invokes real method instead stubbed second creation throws exception really connected problem Everything works fine mock package private parent,Even implemented think mockito throw normal exception time creation variant first creation returns wrong working mock invokes real method instead stubbed second creation throws exception really connected problem Everything works fine mock package private parent,Even implemented think mockito throw normal exception time creation variant first creation returns wrong working mock invokes real method instead stubbed second creation throws exception really connected problem Everything works fine mock package private parent,1
0,Mockito,possible NPE exception class cannot mocked via PowerMockito,version 1 10 5 catch block needs guard null proxyInstance,version    catch block needs guard null proxyInstance,version catch block needs guard null proxyInstance,1
0,Mockito,Source files put binary JAR,Source files java put binary mockito core jar stupefies Idea show decompiled file even source jar available,Source files java put binary mockito core jar stupefies Idea show decompiled file even source jar available,Source files java put binary mockito core jar stupefies Idea show decompiled file even source jar available,1
0,Mockito,ArgumentCaptor fromClass return type match parameterized type,ArgumentCaptor fromClass return type match parameterized type e expression ArgumentCaptor fromClass Class type ArgumentCaptor U subtype U type check,ArgumentCaptor fromClass return type match parameterized type e expression ArgumentCaptor fromClass Class type ArgumentCaptor U subtype U type check,ArgumentCaptor fromClass return type match parameterized type e expression ArgumentCaptor fromClass Class type ArgumentCaptor U subtype U type check,1
0,Mockito,Allow convenient spying abstract classes,Mockito easy use test needs provide canned values certain method gets harder canned value sufficient,Mockito easy use test needs provide canned values certain method gets harder canned value sufficient,Mockito easy use test needs provide canned values certain method gets harder canned value sufficient,1
0,Mockito,Return empty value Iterables,expect Iterable mocked default empty Iterable understand initial issue behavior would introduced Mockito 2 beta 8 still returns null Could return null Iterables,expect Iterable mocked default empty Iterable understand initial issue behavior would introduced Mockito  beta  still returns null Could return null Iterables,expect Iterable mocked default empty Iterable understand initial issue behavior would introduced Mockito beta still returns null Could return null Iterables,1
0,Mockito,Exception stubbing thenThrow,create mock stub method throws exception twice first exception thrown upon invoking second stub instruction,create mock stub method throws exception twice first exception thrown upon invoking second stub instruction,create mock stub method throws exception twice first exception thrown upon invoking second stub instruction,1
0,Mockito,Problem spying abstract classes,problem spying abstract classes real implementation calls abstract method,problem spying abstract classes real implementation calls abstract method,problem spying abstract classes real implementation calls abstract method,1
0,Mockito,Fixed DelegatingMethod equals easier extend Mockito custom verification modes,Currently create DelegatingMethod compare using equals show equal equals method expects java lang reflect Method without explicitly stating knock effect evaluation InvocationImpl equals runtime may using DelegatingMethod equals,Currently create DelegatingMethod compare using equals show equal equals method expects java lang reflect Method without explicitly stating knock effect evaluation InvocationImpl equals runtime may using DelegatingMethod equals,Currently create DelegatingMethod compare using equals show equal equals method expects java lang reflect Method without explicitly stating knock effect evaluation InvocationImpl equals runtime may using DelegatingMethod equals,1
0,Mockito,Deep stubbing generic responses call chain working,Deep stubbing throw Exception multiple generics occur call chain instance consider mock myMock1 provides function returns generic also function returns generic Exception message Raw extraction supported null thrown think issue generics possible mocked ReturnsDeepStubsSerializationFallback since GenericMetadataSupport closed point,Deep stubbing throw Exception multiple generics occur call chain instance consider mock myMock provides function returns generic also function returns generic Exception message Raw extraction supported null thrown think issue generics possible mocked ReturnsDeepStubsSerializationFallback since GenericMetadataSupport closed point,Deep stubbing throw Exception multiple generics occur call chain instance consider mock myMock provides function returns generic also function returns generic Exception message Raw extraction supported null thrown think issue generics possible mocked ReturnsDeepStubsSerializationFallback since GenericMetadataSupport closed point,1
0,Mockito,fixed verify call example Captor javadoc,None,None,None,1
0,Mockito,Make org mockito asm signature package optional Import Packages,None,None,None,1
0,Mockito,Argument matcher anyXxx e anyString anyList match nulls,Note function called integer string still mocked function return value return string passed works using anyBoolean methof family,Note function called integer string still mocked function return value return string passed works using anyBoolean methof family,Note function called integer string still mocked function return value return string passed works using anyBoolean methof family,1
0,Mockito,nicer textual printing typed parameters,matchers fail yield toString Mockito prints extra type information However type information awkwardly printed Strings encountered issue working removing hard dependency hamcrest,matchers fail yield toString Mockito prints extra type information However type information awkwardly printed Strings encountered issue working removing hard dependency hamcrest,matchers fail yield toString Mockito prints extra type information However type information awkwardly printed Strings encountered issue working removing hard dependency hamcrest,1
0,Mockito,Mockito 1 10 x timeout verification needs JUnit classes VerifyError NoClassDefFoundError,JUnit classpath mockito version 1 10 x 1 10 1 1 10 19 code using timeout verification supposed related JUnit JVM may fail VerifyError NoClassDefFoundError,JUnit classpath mockito version   x       code using timeout verification supposed related JUnit JVM may fail VerifyError NoClassDefFoundError,JUnit classpath mockito version x code using timeout verification supposed related JUnit JVM may fail VerifyError NoClassDefFoundError,1
0,Mockito,ArgumentCaptor longer working varargs,upgrading 1 10 8 verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var1 target test code test runs fine 1 9 5 1 10 8 Also matter captor Date issue occurs parameter another type Integer,upgrading    verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var target test code test runs fine       Also matter captor Date issue occurs parameter another type Integer,upgrading verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var target test code test runs fine Also matter captor Date issue occurs parameter another type Integer,1
0,Mockito,RETURNS DEEP STUBS automatically tries create serializable mocks,using setting withSettings serializable however type trying mock NotSerializableReturnValue implement Serializable arg constructor,using setting withSettings serializable however type trying mock NotSerializableReturnValue implement Serializable arg constructor,using setting withSettings serializable however type trying mock NotSerializableReturnValue implement Serializable arg constructor,1
0,Mockito,InjectMocks injects mock wrong field,using InjectMocks Android TextViews mock injected wrong field two fields txtGateView txtNextStep class test mocks txtNextStep tried inject field injected wrong quick testing name txtNextView matter changed txtGateView txtGateLabel messed things mock fields works correctly,using InjectMocks Android TextViews mock injected wrong field two fields txtGateView txtNextStep class test mocks txtNextStep tried inject field injected wrong quick testing name txtNextView matter changed txtGateView txtGateLabel messed things mock fields works correctly,using InjectMocks Android TextViews mock injected wrong field two fields txtGateView txtNextStep class test mocks txtNextStep tried inject field injected wrong quick testing name txtNextView matter changed txtGateView txtGateLabel messed things mock fields works correctly,1
0,Mockito,use InjectMocks final fields,trying upgrade mockito version using 1 8 5 newer version problem InjectMocks since 1 9 0 inject final field anymore,trying upgrade mockito version using    newer version problem InjectMocks since    inject final field anymore,trying upgrade mockito version using newer version problem InjectMocks since inject final field anymore,1
0,Mockito,1 10 regression StackOverflowError interface generic type upper bound,None,None,None,1
0,Mockito,Allow convenient spying abstract classes,Mockito easy use test needs provide canned values certain method gets harder canned value sufficient,Mockito easy use test needs provide canned values certain method gets harder canned value sufficient,Mockito easy use test needs provide canned values certain method gets harder canned value sufficient,1
0,Mockito,Generate change list separated types using labels,discussed mailing list instead one big list Improvements change list release divided change types based labels required specify labels considered separately labels excluded like question refactoring also headerForOtherChanges method override default header,discussed mailing list instead one big list Improvements change list release divided change types based labels required specify labels considered separately labels excluded like question refactoring also headerForOtherChanges method override default header,discussed mailing list instead one big list Improvements change list release divided change types based labels required specify labels considered separately labels excluded like question refactoring also headerForOtherChanges method override default header,1
0,Mockito,Make Mockito JUnit rule easier use,Mockito JUnit rule easier use avoiding need pass test instance Make compatible JUnit 4 7 instead 4 9,Mockito JUnit rule easier use avoiding need pass test instance Make compatible JUnit   instead  ,Mockito JUnit rule easier use avoiding need pass test instance Make compatible JUnit instead,1
0,Mockito,Failing tests Windows machine,None,None,None,1
0,Mockito,Failing tests Windows machine,None,None,None,1
0,Mockito,Make Mockito JUnit rule easier use,Mockito JUnit rule easier use avoiding need pass test instance Make compatible JUnit 4 7 instead 4 9,Mockito JUnit rule easier use avoiding need pass test instance Make compatible JUnit   instead  ,Mockito JUnit rule easier use avoiding need pass test instance Make compatible JUnit instead,1
0,Mockito,fix rawtype warnings tests,None,None,None,1
0,Mockito,WrongTypeOfReturnValue abstract class two abstract method,strange behavior method lol called delete one abstract method everything good,strange behavior method lol called delete one abstract method everything good,strange behavior method lol called delete one abstract method everything good,1
0,Mockito,java lang ClassCastException java lang Class cannot cast java lang String,Exception throws verifyZeroInteractions using mock default answer,Exception throws verifyZeroInteractions using mock default answer,Exception throws verifyZeroInteractions using mock default answer,1
0,Mockito,ArgumentCaptor longer working varargs,upgrading 1 10 8 verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var1 target test code test runs fine 1 9 5 1 10 8 Also matter captor Date issue occurs parameter another type Integer,upgrading    verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var target test code test runs fine       Also matter captor Date issue occurs parameter another type Integer,upgrading verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var target test code test runs fine Also matter captor Date issue occurs parameter another type Integer,1
0,Mockito,ArgumentCaptor longer working varargs,upgrading 1 10 8 verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var1 target test code test runs fine 1 9 5 1 10 8 Also matter captor Date issue occurs parameter another type Integer,upgrading    verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var target test code test runs fine       Also matter captor Date issue occurs parameter another type Integer,upgrading verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var target test code test runs fine Also matter captor Date issue occurs parameter another type Integer,1
0,Mockito,ArgumentCaptor longer working varargs,upgrading 1 10 8 verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var1 target test code test runs fine 1 9 5 1 10 8 Also matter captor Date issue occurs parameter another type Integer,upgrading    verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var target test code test runs fine       Also matter captor Date issue occurs parameter another type Integer,upgrading verify passes getValue fails error One piece info came light result creating MCVE test works fine Date element passed bindVariables remove var target test code test runs fine Also matter captor Date issue occurs parameter another type Integer,1
0,Mockito,Mockito method accepts negative timeperiods subsequent verifications always pass,None,None,None,1
0,Mockito,fix proposal 114,None,None,None,1
0,Mockito,Mockito 1 10 x timeout verification needs JUnit classes VerifyError NoClassDefFoundError,JUnit classpath mockito version 1 10 x 1 10 1 1 10 19 code using timeout verification supposed related JUnit JVM may fail VerifyError NoClassDefFoundError,JUnit classpath mockito version   x       code using timeout verification supposed related JUnit JVM may fail VerifyError NoClassDefFoundError,JUnit classpath mockito version x code using timeout verification supposed related JUnit JVM may fail VerifyError NoClassDefFoundError,1
0,Mockito,fix proposal 114,None,None,None,1
0,Mockito,Return deep stubs generic method returns generic type,try mock generic method generic returntype returntype derived generic type method using deep stubs get ClassCastException calling use deep stubs raw Supplier mock pass around works,try mock generic method generic returntype returntype derived generic type method using deep stubs get ClassCastException calling use deep stubs raw Supplier mock pass around works,try mock generic method generic returntype returntype derived generic type method using deep stubs get ClassCastException calling use deep stubs raw Supplier mock pass around works,1
0,Mockito,Null Pointer invoking Whitebox invokeMethod null one params null,None,None,None,1
0,Closure,Break finally block optimized properly,None,None,None,1
0,Chart,Error TimeSeries createCopy method,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart 1 0 7,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart   ,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze gives bad results commons math3 3 0 simple test problem works well commons math 2 2,Methode SimplexSolver optimeze gives bad results commons math   simple test problem works well commons math  ,Methode SimplexSolver optimeze gives bad results commons math simple test problem works well commons math,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Time,possibly bug org joda time field FieldUtils safeMultiply,seems currently written joda time 2 1 jar org joda time field FieldUtils safeMultiply long val1 int scalar detect overflow long val1 Long MIN VALUE int scalar 1 attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,seems currently written joda time   jar org joda time field FieldUtils safeMultiply long val int scalar detect overflow long val Long MIN VALUE int scalar  attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,seems currently written joda time jar org joda time field FieldUtils safeMultiply long val int scalar detect overflow long val Long MIN VALUE int scalar attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,1
0,Lang,NullPointerException isAvailableLocale Locale,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,1
0,Lang,ClassUtils toClass Object throws NPE null array element,see summary,see summary,see summary,1
0,Lang,FastDateFormat format outputs incorrect week year locale respected,FastDateFormat apparently respect locale sent creation outputting week year e g ww format seems use settings system locale firstDayOfWeek minimalDaysInFirstWeek depending year may result incorrect week number output simple test program demonstrate problem comparing SimpleDateFormat gets week number right import java util Calendar import java util Date import java util Locale import java text SimpleDateFormat import org apache commons lang time FastDateFormat public class FastDateFormatWeekBugDemo public static void main String args Locale setDefault new Locale en US Locale locale new Locale sv SE Calendar cal Calendar getInstance setting locale change outcome cal set 2010 0 1 12 0 0 Date cal getTime System println Target date FastDateFormat fdf FastDateFormat getInstance EEEE week ww locale SimpleDateFormat sdf new SimpleDateFormat EEEE week ww locale System println FastDateFormat fdf format output FastDateFormat fredag week 01 System println SimpleDateFormat sdf format output SimpleDateFormat fredag week 53 sv SE passed Locale setDefault instead en US FastDateFormat SimpleDateFormat output correct week number,FastDateFormat apparently respect locale sent creation outputting week year e g ww format seems use settings system locale firstDayOfWeek minimalDaysInFirstWeek depending year may result incorrect week number output simple test program demonstrate problem comparing SimpleDateFormat gets week number right import java util Calendar import java util Date import java util Locale import java text SimpleDateFormat import org apache commons lang time FastDateFormat public class FastDateFormatWeekBugDemo public static void main String args Locale setDefault new Locale en US Locale locale new Locale sv SE Calendar cal Calendar getInstance setting locale change outcome cal set       Date cal getTime System println Target date FastDateFormat fdf FastDateFormat getInstance EEEE week ww locale SimpleDateFormat sdf new SimpleDateFormat EEEE week ww locale System println FastDateFormat fdf format output FastDateFormat fredag week  System println SimpleDateFormat sdf format output SimpleDateFormat fredag week  sv SE passed Locale setDefault instead en US FastDateFormat SimpleDateFormat output correct week number,FastDateFormat apparently respect locale sent creation outputting week year e g ww format seems use settings system locale firstDayOfWeek minimalDaysInFirstWeek depending year may result incorrect week number output simple test program demonstrate problem comparing SimpleDateFormat gets week number right import java util Calendar import java util Date import java util Locale import java text SimpleDateFormat import org apache commons lang time FastDateFormat public class FastDateFormatWeekBugDemo public static void main String args Locale setDefault new Locale en US Locale locale new Locale sv SE Calendar cal Calendar getInstance setting locale change outcome cal set Date cal getTime System println Target date FastDateFormat fdf FastDateFormat getInstance EEEE week ww locale SimpleDateFormat sdf new SimpleDateFormat EEEE week ww locale System println FastDateFormat fdf format output FastDateFormat fredag week System println SimpleDateFormat sdf format output SimpleDateFormat fredag week sv SE passed Locale setDefault instead en US FastDateFormat SimpleDateFormat output correct week number,1
0,Lang,ExtendedMessageFormat OutOfMemory custom format registry pattern containing single quotes,using ExtendedMessageFormat custom format registry pattern conatining single quotes OutOfMemoryError occur Example cause error ExtendedMessageFormatTest java private static Map String Object formatRegistry new HashMap String Object static formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory public static void main String args ExtendedMessageFormat mf new ExtendedMessageFormat dummy test formatRegistry String formattedPattern mf format new String great System println formattedPattern following change starting line 421 2 4 release seems fix problem ExtendedMessageFormat java CURRENT Broken escapingOn c start QUOTE return appendTo null null appendTo append QUOTE WORKING escapingOn c start QUOTE next pos return appendTo null null appendTo append QUOTE,using ExtendedMessageFormat custom format registry pattern conatining single quotes OutOfMemoryError occur Example cause error ExtendedMessageFormatTest java private static Map String Object formatRegistry new HashMap String Object static formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory public static void main String args ExtendedMessageFormat mf new ExtendedMessageFormat dummy test formatRegistry String formattedPattern mf format new String great System println formattedPattern following change starting line    release seems fix problem ExtendedMessageFormat java CURRENT Broken escapingOn c start QUOTE return appendTo null null appendTo append QUOTE WORKING escapingOn c start QUOTE next pos return appendTo null null appendTo append QUOTE,using ExtendedMessageFormat custom format registry pattern conatining single quotes OutOfMemoryError occur Example cause error ExtendedMessageFormatTest java private static Map String Object formatRegistry new HashMap String Object static formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory public static void main String args ExtendedMessageFormat mf new ExtendedMessageFormat dummy test formatRegistry String formattedPattern mf format new String great System println formattedPattern following change starting line release seems fix problem ExtendedMessageFormat java CURRENT Broken escapingOn c start QUOTE return appendTo null null appendTo append QUOTE WORKING escapingOn c start QUOTE next pos return appendTo null null appendTo append QUOTE,1
0,Lang,DateFormatUtils format correctly change Calendar TimeZone certain situations,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z commonly constructed cal new GregorianCalendar 2009 9 16 8 42 16 unit test work time zone constructing GMT 8 rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime   T   Z commonly constructed cal new GregorianCalendar       unit test work time zone constructing GMT  rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime   T   Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime Z commonly constructed cal new GregorianCalendar unit test work time zone constructing GMT rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,1
0,Lang,NumberUtils isNumber String right String 1 1L,1 1L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint, L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint,L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint,1
0,Closure,bug implicit namespaces across modules,None,None,None,1
0,Closure,bug implicit namespaces across modules,None,None,None,1
0,Closure,Dependency sorting closurePass set false longer works,None,None,None,1
0,Closure,Record type invalid property reported function annotation,None,None,None,1
0,Closure,Codepoint U 007f appears raw output,None,None,None,1
0,Closure,Wrong code generated mixing types ternary operator,None,None,None,1
0,Closure,side effects analysis incorrectly removing function calls side effects,None,None,None,1
0,Closure,Break finally block optimized properly,None,None,None,1
0,Closure,Add support manage closure dependencies closure dependencies compilation level WHITESPACE,None,None,None,1
0,Closure,Column indicating caret sometimes error output,None,None,None,1
0,Closure,ClassCastException TypeCheck pass,None,None,None,1
0,Closure,unexpected typed coverage less 100,None,None,None,1
0,Closure,bogus missing return warning,None,None,None,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path1 GeneralPath path2 thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,1
0,Chart,Potential NPE AbstractCategoryItemRender getLegendItems,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,1
0,Chart,Fix MultiplePiePlot,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,1
0,Math,FastMath max 50 0f 50 0f 50 0f 50 0f,FastMath max 50 0f 50 0f 50 0f 50 0f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,FastMath max  f  f  f  f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,FastMath max f f f f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Math,GaussianFitter Unexpectedly Throws NotStrictlyPositiveException,Running following double observations 1 1143831578403364E 29 4 95281403484594E 28 1 1171347211930288E 26 1 7044813962636277E 25 1 9784716574832164E 24 1 8630236407866774E 23 1 4820532905097742E 22 1 0241963854632831E 21 6 275077366673128E 21 3 461808994532493E 20 1 7407124684715706E 19 8 056687953553974E 19 3 460193945992071E 18 1 3883326374011525E 17 5 233894983671116E 17 1 8630791465263745E 16 6 288759227922111E 16 2 0204433920597856E 15 6 198768938576155E 15 1 821419346860626E 14 5 139176445538471E 14 1 3956427429045787E 13 3 655705706448139E 13 9 253753324779779E 13 2 267636001476696E 12 5 3880460095836855E 12 1 2431632654852931E 11 GaussianFitter g new GaussianFitter new LevenbergMarquardtOptimizer int index 0 index 27 index g addObservedPoint index observations index g fit Results org apache commons math exception NotStrictlyPositiveException 1 277 smaller equal minimum 0 org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java 184 org apache commons math analysis function Gaussian Parametric value Gaussian java 129 guessing initial guess sigma,Running following double observations  E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E  GaussianFitter g new GaussianFitter new LevenbergMarquardtOptimizer int index  index  index g addObservedPoint index observations index g fit Results org apache commons math exception NotStrictlyPositiveException   smaller equal minimum  org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java  org apache commons math analysis function Gaussian Parametric value Gaussian java  guessing initial guess sigma,Running following double observations E E E E E E E E E E E E E E E E E E E E E E E E E E E GaussianFitter g new GaussianFitter new LevenbergMarquardtOptimizer int index index index g addObservedPoint index observations index g fit Results org apache commons math exception NotStrictlyPositiveException smaller equal minimum org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java org apache commons math analysis function Gaussian Parametric value Gaussian java guessing initial guess sigma,1
0,Math,ListPopulation Iterator allows remove chromosomes population,Calling iterator method ListPopulation returns iterator protected modifiable list returning iterator wrap unmodifiable list,Calling iterator method ListPopulation returns iterator protected modifiable list returning iterator wrap unmodifiable list,Calling iterator method ListPopulation returns iterator protected modifiable list returning iterator wrap unmodifiable list,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze gives bad results commons math3 3 0 simple test problem works well commons math 2 2,Methode SimplexSolver optimeze gives bad results commons math   simple test problem works well commons math  ,Methode SimplexSolver optimeze gives bad results commons math simple test problem works well commons math,1
0,Math,stat Frequency getPct Object uses getCumPct Comparable instead getPct Comparable,Drop Replacement 1 2 2 0 possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable 2 0 Deprecated public double getPct Object v return getCumPct Comparable v,Drop Replacement     possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable   Deprecated public double getPct Object v return getCumPct Comparable v,Drop Replacement possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable Deprecated public double getPct Object v return getCumPct Comparable v,1
0,Math,BisectionSolver solve final UnivariateRealFunction f double min double max double initial throws NullPointerException,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl 0 0 1 0 0 5 NullPointerException thrown,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl       NullPointerException thrown,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl NullPointerException thrown,1
0,Math,bug inverseCumulativeProbability Normal Distribution,version Revision 617953 Date 2008 02 02 22 54 00 0700 Sat 02 Feb 2008 public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision 506600 Date 2007 02 12 12 35 59 0700 Mon 12 Feb 2007 public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution 0 1 double result normal inverseCumulativeProbability 0 9772498680518209 gives exception return approx 2 0000 normal inverseCumulativeProbability 0 977249868051820 works fine also give errors 0 9986501019683698 return 3 0000 0 9999683287581673 return 4 0000 org apache commons math MathException Number iterations 1 maximum iterations 2 147 483 647 initial 1 lower bound 0 upper bound 179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final value 0 final b value 2 f 0 477 f b 0 org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java 103 org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java 145,version Revision  Date        Sat  Feb  public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision  Date        Mon  Feb  public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution   double result normal inverseCumulativeProbability   gives exception return approx   normal inverseCumulativeProbability   works fine also give errors   return     return   org apache commons math MathException Number iterations  maximum iterations     initial  lower bound  upper bound                                                                                                        final value  final b value  f   f b  org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java  org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java ,version Revision Date Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision Date Mon Feb public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution double result normal inverseCumulativeProbability gives exception return approx normal inverseCumulativeProbability works fine also give errors return return org apache commons math MathException Number iterations maximum iterations initial lower bound upper bound final value final b value f f b org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java,1
0,Math,SimplexSolver working expected 2,SimplexSolver find optimal solution Program Lpsolve Objective function max 7 3 b Constraints R1 3 5 c 0 R2 2 5 0 R3 2 b 5 c 0 R4 3 b 5 0 R5 3 2 b 5 R6 2 3 b 5 Variable bounds 1 b 1 Results correct 1 b 1 value 10 Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double 7 3 0 0 0 Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double 1 0 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 0 1 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 3 0 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 2 0 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 2 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 3 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 3 2 0 0 Relationship LEQ 5 podmienky add new LinearConstraint new double 2 3 0 0 Relationship LEQ 5 SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect 1 b 0 5 value 8 5 P used latest software repository including MATH 286 fix,SimplexSolver find optimal solution Program Lpsolve Objective function max   b Constraints R   c  R    R  b  c  R  b   R   b  R   b  Variable bounds  b  Results correct  b  value  Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double      Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect  b   value   P used latest software repository including MATH  fix,SimplexSolver find optimal solution Program Lpsolve Objective function max b Constraints R c R R b c R b R b R b Variable bounds b Results correct b value Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect b value P used latest software repository including MATH fix,1
0,Math,Complex ZERO reciprocal returns NaN return INF,Complex ZERO reciprocal returns NaN return INF Class org apache commons math3 complex Complex Method reciprocal version Id Complex java 1416643 2012 12 03 19 37 14Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java       Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java Z tn,1
0,Time,NPE DateTimeZoneBuilder,DateTimeZone build duplicate named recurring saving time first thread goes Ok warning message generated identifier automatically generated PrecalculatedZone create second thread NPE generated ZoneInfoCompiler verbose cause cVerbose ThreadLocal incorrectly initialized ZoneInfoCompiler initialize cVerbose first thread subsequent ones NPE caused autoboxing better approach could remove initialization test null,DateTimeZone build duplicate named recurring saving time first thread goes Ok warning message generated identifier automatically generated PrecalculatedZone create second thread NPE generated ZoneInfoCompiler verbose cause cVerbose ThreadLocal incorrectly initialized ZoneInfoCompiler initialize cVerbose first thread subsequent ones NPE caused autoboxing better approach could remove initialization test null,DateTimeZone build duplicate named recurring saving time first thread goes Ok warning message generated identifier automatically generated PrecalculatedZone create second thread NPE generated ZoneInfoCompiler verbose cause cVerbose ThreadLocal incorrectly initialized ZoneInfoCompiler initialize cVerbose first thread subsequent ones NPE caused autoboxing better approach could remove initialization test null,1
0,Time,Inconsistent interpretation ambiguous time DST,inconsistency appears timezone Europe London three DateTime objects represent moment time even ambiguous always returns earlier instant summer time overlap,inconsistency appears timezone Europe London three DateTime objects represent moment time even ambiguous always returns earlier instant summer time overlap,inconsistency appears timezone Europe London three DateTime objects represent moment time even ambiguous always returns earlier instant summer time overlap,1
0,Time,Constructing invalid Partials,Partials constructed invoking constructor Partial DateTimeFieldType int merging together set partials using constructed calling Partial DateTimeFieldType int However work cases suppose Partials allow constructed either case right also related issue probably stems fact Partial invalid,Partials constructed invoking constructor Partial DateTimeFieldType int merging together set partials using constructed calling Partial DateTimeFieldType int However work cases suppose Partials allow constructed either case right also related issue probably stems fact Partial invalid,Partials constructed invoking constructor Partial DateTimeFieldType int merging together set partials using constructed calling Partial DateTimeFieldType int However work cases suppose Partials allow constructed either case right also related issue probably stems fact Partial invalid,1
0,Lang,Bug method appendFixedWidthPadRight class StrBuilder causes ArrayIndexOutOfBoundsException,bug method appendFixedWidthPadRight class StrBuilder public StrBuilder appendFixedWidthPadRight Object obj int width char padChar width 0 ensureCapacity size width String str obj null getNullText obj toString int strLen str length strLen width str getChars 0 strLen buffer size BUG str getChars 0 width buffer size else int padLen width strLen str getChars 0 strLen buffer size int 0 padLen buffer size strLen padChar size width return causing ArrayIndexOutOfBoundsException method unusable strLen width counterpart method appendFixedWidthPadLeft seems ok,bug method appendFixedWidthPadRight class StrBuilder public StrBuilder appendFixedWidthPadRight Object obj int width char padChar width  ensureCapacity size width String str obj null getNullText obj toString int strLen str length strLen width str getChars  strLen buffer size BUG str getChars  width buffer size else int padLen width strLen str getChars  strLen buffer size int  padLen buffer size strLen padChar size width return causing ArrayIndexOutOfBoundsException method unusable strLen width counterpart method appendFixedWidthPadLeft seems ok,bug method appendFixedWidthPadRight class StrBuilder public StrBuilder appendFixedWidthPadRight Object obj int width char padChar width ensureCapacity size width String str obj null getNullText obj toString int strLen str length strLen width str getChars strLen buffer size BUG str getChars width buffer size else int padLen width strLen str getChars strLen buffer size int padLen buffer size strLen padChar size width return causing ArrayIndexOutOfBoundsException method unusable strLen width counterpart method appendFixedWidthPadLeft seems ok,1
0,Lang,NullPointerException isAvailableLocale Locale,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,1
0,Lang,StringIndexOutOfBoundsException CharSequenceTranslator,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uD83D\uDE30 surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uD83D\uDE30 StringEscapeUtils escapeCsv \uD83D\uDE30 get exception shown java lang StringIndexOutOfBoundsException String index range 2 java lang String charAt String java 658 java lang Character codePointAt Character java 4668 org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java 95 org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java 59 org apache commons lang3 StringEscapeUtils escapeCsv StringEscapeUtils java 556 Patch attached method affected public final void translate CharSequence input Writer throws IOException,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uDD\uDE surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE get exception shown java lang StringIndexOutOfBoundsException String index range  java lang String charAt String java  java lang Character codePointAt Character java  org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java  org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java  org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java  Patch attached method affected public final void translate CharSequence input Writer throws IOException,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uDD\uDE surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE get exception shown java lang StringIndexOutOfBoundsException String index range java lang String charAt String java java lang Character codePointAt Character java org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java Patch attached method affected public final void translate CharSequence input Writer throws IOException,1
0,Lang,FastDateParser handle white space properly,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,1
0,Lang,FastDateFormat format outputs incorrect week year locale respected,FastDateFormat apparently respect locale sent creation outputting week year e g ww format seems use settings system locale firstDayOfWeek minimalDaysInFirstWeek depending year may result incorrect week number output simple test program demonstrate problem comparing SimpleDateFormat gets week number right import java util Calendar import java util Date import java util Locale import java text SimpleDateFormat import org apache commons lang time FastDateFormat public class FastDateFormatWeekBugDemo public static void main String args Locale setDefault new Locale en US Locale locale new Locale sv SE Calendar cal Calendar getInstance setting locale change outcome cal set 2010 0 1 12 0 0 Date cal getTime System println Target date FastDateFormat fdf FastDateFormat getInstance EEEE week ww locale SimpleDateFormat sdf new SimpleDateFormat EEEE week ww locale System println FastDateFormat fdf format output FastDateFormat fredag week 01 System println SimpleDateFormat sdf format output SimpleDateFormat fredag week 53 sv SE passed Locale setDefault instead en US FastDateFormat SimpleDateFormat output correct week number,FastDateFormat apparently respect locale sent creation outputting week year e g ww format seems use settings system locale firstDayOfWeek minimalDaysInFirstWeek depending year may result incorrect week number output simple test program demonstrate problem comparing SimpleDateFormat gets week number right import java util Calendar import java util Date import java util Locale import java text SimpleDateFormat import org apache commons lang time FastDateFormat public class FastDateFormatWeekBugDemo public static void main String args Locale setDefault new Locale en US Locale locale new Locale sv SE Calendar cal Calendar getInstance setting locale change outcome cal set       Date cal getTime System println Target date FastDateFormat fdf FastDateFormat getInstance EEEE week ww locale SimpleDateFormat sdf new SimpleDateFormat EEEE week ww locale System println FastDateFormat fdf format output FastDateFormat fredag week  System println SimpleDateFormat sdf format output SimpleDateFormat fredag week  sv SE passed Locale setDefault instead en US FastDateFormat SimpleDateFormat output correct week number,FastDateFormat apparently respect locale sent creation outputting week year e g ww format seems use settings system locale firstDayOfWeek minimalDaysInFirstWeek depending year may result incorrect week number output simple test program demonstrate problem comparing SimpleDateFormat gets week number right import java util Calendar import java util Date import java util Locale import java text SimpleDateFormat import org apache commons lang time FastDateFormat public class FastDateFormatWeekBugDemo public static void main String args Locale setDefault new Locale en US Locale locale new Locale sv SE Calendar cal Calendar getInstance setting locale change outcome cal set Date cal getTime System println Target date FastDateFormat fdf FastDateFormat getInstance EEEE week ww locale SimpleDateFormat sdf new SimpleDateFormat EEEE week ww locale System println FastDateFormat fdf format output FastDateFormat fredag week System println SimpleDateFormat sdf format output SimpleDateFormat fredag week sv SE passed Locale setDefault instead en US FastDateFormat SimpleDateFormat output correct week number,1
0,Mockito,fixed verify call example Captor javadoc,None,None,None,1
0,Mockito,Generate change list separated types using labels,discussed mailing list instead one big list Improvements change list release divided change types based labels required specify labels considered separately labels excluded like question refactoring also headerForOtherChanges method override default header,discussed mailing list instead one big list Improvements change list release divided change types based labels required specify labels considered separately labels excluded like question refactoring also headerForOtherChanges method override default header,discussed mailing list instead one big list Improvements change list release divided change types based labels required specify labels considered separately labels excluded like question refactoring also headerForOtherChanges method override default header,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path1 GeneralPath path2 thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,1
0,Math,weight versus sigma AbstractLeastSquares,AbstractLeastSquares residualsWeights contains WEIGHTS assigned observation method getRMS weights multiplicative unlike getChiSquare appears denominator weight really weight observation multiply square residual even computation chi2 corrected getRMS even reduce public double getRMS return Math sqrt getChiSquare rows,AbstractLeastSquares residualsWeights contains WEIGHTS assigned observation method getRMS weights multiplicative unlike getChiSquare appears denominator weight really weight observation multiply square residual even computation chi corrected getRMS even reduce public double getRMS return Math sqrt getChiSquare rows,AbstractLeastSquares residualsWeights contains WEIGHTS assigned observation method getRMS weights multiplicative unlike getChiSquare appears denominator weight really weight observation multiply square residual even computation chi corrected getRMS even reduce public double getRMS return Math sqrt getChiSquare rows,1
0,Math,Complex Add Subtract handle NaN arguments differently javadoc contracts,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back 1 1,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back  ,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back,1
0,Math,Complex Add Subtract handle NaN arguments differently javadoc contracts,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back 1 1,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back  ,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back,1
0,Math,NaN equals methods,MathUtils equals methods return true argument NaN Unless mistaken contradicts IEEE standard nobody objects going make changes,MathUtils equals methods return true argument NaN Unless mistaken contradicts IEEE standard nobody objects going make changes,MathUtils equals methods return true argument NaN Unless mistaken contradicts IEEE standard nobody objects going make changes,1
0,Math,bug inverseCumulativeProbability Normal Distribution,version Revision 617953 Date 2008 02 02 22 54 00 0700 Sat 02 Feb 2008 public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision 506600 Date 2007 02 12 12 35 59 0700 Mon 12 Feb 2007 public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution 0 1 double result normal inverseCumulativeProbability 0 9772498680518209 gives exception return approx 2 0000 normal inverseCumulativeProbability 0 977249868051820 works fine also give errors 0 9986501019683698 return 3 0000 0 9999683287581673 return 4 0000 org apache commons math MathException Number iterations 1 maximum iterations 2 147 483 647 initial 1 lower bound 0 upper bound 179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final value 0 final b value 2 f 0 477 f b 0 org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java 103 org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java 145,version Revision  Date        Sat  Feb  public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision  Date        Mon  Feb  public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution   double result normal inverseCumulativeProbability   gives exception return approx   normal inverseCumulativeProbability   works fine also give errors   return     return   org apache commons math MathException Number iterations  maximum iterations     initial  lower bound  upper bound                                                                                                        final value  final b value  f   f b  org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java  org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java ,version Revision Date Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision Date Mon Feb public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution double result normal inverseCumulativeProbability gives exception return approx normal inverseCumulativeProbability works fine also give errors return return org apache commons math MathException Number iterations maximum iterations initial lower bound upper bound final value final b value f f b org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java,1
0,Lang,NullPointerException isAvailableLocale Locale,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,1
0,Lang,NullPointerException isAvailableLocale Locale,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,1
0,Lang,NullPointerException isAvailableLocale Locale,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,1
0,Closure,Break finally block optimized properly,None,None,None,1
0,Closure,Erroneous optimization ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Closure,Column indicating caret sometimes error output,None,None,None,1
0,Chart,Error TimeSeries createCopy method,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart 1 0 7,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart   ,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart,1
0,Math,MultivariateNormalDistribution density double returns wrong value dimension odd,reproduce Assert assertEquals 0 398942280401433 new MultivariateNormalDistribution new double 0 new double 1 density new double 0 1e 15,reproduce Assert assertEquals   new MultivariateNormalDistribution new double  new double  density new double  e ,reproduce Assert assertEquals new MultivariateNormalDistribution new double new double density new double e,1
0,Math,Bugs Frequency API,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return 0 object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ 0 System println f getPct OBJ 0 0 Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return 0 Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return  object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ  System println f getPct OBJ   Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return  Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ System println f getPct OBJ Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return Exception applying instanceof fix would also cause fail,1
0,Math,weight versus sigma AbstractLeastSquares,AbstractLeastSquares residualsWeights contains WEIGHTS assigned observation method getRMS weights multiplicative unlike getChiSquare appears denominator weight really weight observation multiply square residual even computation chi2 corrected getRMS even reduce public double getRMS return Math sqrt getChiSquare rows,AbstractLeastSquares residualsWeights contains WEIGHTS assigned observation method getRMS weights multiplicative unlike getChiSquare appears denominator weight really weight observation multiply square residual even computation chi corrected getRMS even reduce public double getRMS return Math sqrt getChiSquare rows,AbstractLeastSquares residualsWeights contains WEIGHTS assigned observation method getRMS weights multiplicative unlike getChiSquare appears denominator weight really weight observation multiply square residual even computation chi corrected getRMS even reduce public double getRMS return Math sqrt getChiSquare rows,1
0,Lang,ClassUtils toClass Object throws NPE null array element,see summary,see summary,see summary,1
0,Lang,NumberUtils createNumber bad behaviour leading,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,1
0,Lang,FastDateParser handle white space properly,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,1
0,Lang,StrBuilder appendFixedWidth handle nulls,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,1
0,Lang,NumberUtils createNumber bad behaviour leading,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,1
0,Lang,FastDateParser handle white space properly,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,1
0,Lang,NumberUtils isNumber String right String 1 1L,1 1L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint, L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint,L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint,1
0,Lang,org apache commons lang3 math Fraction reduce Integer MIN VALUE 2 k,greatestCommonDivisor method class Fraction find gcd Integer MIN VALUE 2 k case triggered taking Integer MIN VALUE numerator Note case taking Integer MIN VALUE denominator handled explicitly getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int f Fraction getReducedFraction Integer MIN VALUE 2 assertEquals Integer MIN VALUE 2 f getNumerator assertEquals 1 f getDenominator public void testReduce f Fraction getFraction Integer MIN VALUE 2 result f reduce assertEquals Integer MIN VALUE 2 result getNumerator assertEquals 1 result getDenominator,greatestCommonDivisor method class Fraction find gcd Integer MIN VALUE  k case triggered taking Integer MIN VALUE numerator Note case taking Integer MIN VALUE denominator handled explicitly getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int f Fraction getReducedFraction Integer MIN VALUE  assertEquals Integer MIN VALUE  f getNumerator assertEquals  f getDenominator public void testReduce f Fraction getFraction Integer MIN VALUE  result f reduce assertEquals Integer MIN VALUE  result getNumerator assertEquals  result getDenominator,greatestCommonDivisor method class Fraction find gcd Integer MIN VALUE k case triggered taking Integer MIN VALUE numerator Note case taking Integer MIN VALUE denominator handled explicitly getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int f Fraction getReducedFraction Integer MIN VALUE assertEquals Integer MIN VALUE f getNumerator assertEquals f getDenominator public void testReduce f Fraction getFraction Integer MIN VALUE result f reduce assertEquals Integer MIN VALUE result getNumerator assertEquals result getDenominator,1
0,Math,HypergeometricDistribution sample suffers integer overflow,Hi application broke ported commons math 2 2 3 2 looks like HypergeometricDistribution sample method work well used large integer values – example code return sample 0 50 usually returns 50 import org apache commons math3 distribution HypergeometricDistribution public class Foo public static void main String args HypergeometricDistribution new HypergeometricDistribution 43130568 42976365 50 System printf n getSupportLowerBound getSupportUpperBound Prints 0 50 System printf n sample Prints 50 debugger traced far integer overflow HypergeometricDistribution getNumericalMean – instead return double getSampleSize getNumberOfSuccesses double getPopulationSize could return getSampleSize double getNumberOfSuccesses double getPopulationSize seemed fix based quick test,Hi application broke ported commons math     looks like HypergeometricDistribution sample method work well used large integer values – example code return sample   usually returns  import org apache commons math distribution HypergeometricDistribution public class Foo public static void main String args HypergeometricDistribution new HypergeometricDistribution    System printf n getSupportLowerBound getSupportUpperBound Prints   System printf n sample Prints  debugger traced far integer overflow HypergeometricDistribution getNumericalMean – instead return double getSampleSize getNumberOfSuccesses double getPopulationSize could return getSampleSize double getNumberOfSuccesses double getPopulationSize seemed fix based quick test,Hi application broke ported commons math looks like HypergeometricDistribution sample method work well used large integer values – example code return sample usually returns import org apache commons math distribution HypergeometricDistribution public class Foo public static void main String args HypergeometricDistribution new HypergeometricDistribution System printf n getSupportLowerBound getSupportUpperBound Prints System printf n sample Prints debugger traced far integer overflow HypergeometricDistribution getNumericalMean – instead return double getSampleSize getNumberOfSuccesses double getPopulationSize could return getSampleSize double getNumberOfSuccesses double getPopulationSize seemed fix based quick test,1
0,Math,Dangerous code PoissonDistributionImpl,following excerpt class PoissonDistributionImpl PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z super setNormal z setMean p 1 Overridable methods called within constructor 2 reference z stored modified within class encountered problem 1 several classes working issue 348 cases order remove potential problems copied pasted body setter methods inside constructor think elegant solution would remove setters altogether e make classes immutable Problem 2 also create unexpected behaviour really necessary pass NormalDistribution object always created within class,following excerpt class PoissonDistributionImpl PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z super setNormal z setMean p  Overridable methods called within constructor  reference z stored modified within class encountered problem  several classes working issue  cases order remove potential problems copied pasted body setter methods inside constructor think elegant solution would remove setters altogether e make classes immutable Problem  also create unexpected behaviour really necessary pass NormalDistribution object always created within class,following excerpt class PoissonDistributionImpl PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z super setNormal z setMean p Overridable methods called within constructor reference z stored modified within class encountered problem several classes working issue cases order remove potential problems copied pasted body setter methods inside constructor think elegant solution would remove setters altogether e make classes immutable Problem also create unexpected behaviour really necessary pass NormalDistribution object always created within class,1
0,Math,Need range checks elitismRate ElitisticListPopulation constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,1
0,Math,MathUtils factorial n fails n 17,result MathUtils factorial n n 17 18 19 wrong probably rounding errors double calculations Replace first line MathUtilsTest testFactorial int 1 20 check valid arguments long result see failure suggest implementing simple loop multiply long result even using precomputed long instead adding logarithms,result MathUtils factorial n n    wrong probably rounding errors double calculations Replace first line MathUtilsTest testFactorial int   check valid arguments long result see failure suggest implementing simple loop multiply long result even using precomputed long instead adding logarithms,result MathUtils factorial n n wrong probably rounding errors double calculations Replace first line MathUtilsTest testFactorial int check valid arguments long result see failure suggest implementing simple loop multiply long result even using precomputed long instead adding logarithms,1
0,Math,Bugs Frequency API,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return 0 object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ 0 System println f getPct OBJ 0 0 Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return 0 Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return  object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ  System println f getPct OBJ   Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return  Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ System println f getPct OBJ Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return Exception applying instanceof fix would also cause fail,1
0,Math,MathUtils gcd Integer MIN VALUE 0 throw Exception instead returning Integer MIN VALUE,gcd method throw Exception gcd Integer MIN VALUE 0 like gcd Integer MIN VALUE Integer MIN VALUE method return nonnegative results,gcd method throw Exception gcd Integer MIN VALUE  like gcd Integer MIN VALUE Integer MIN VALUE method return nonnegative results,gcd method throw Exception gcd Integer MIN VALUE like gcd Integer MIN VALUE Integer MIN VALUE method return nonnegative results,1
0,Math,Bugs Frequency API,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return 0 object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ 0 System println f getPct OBJ 0 0 Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return 0 Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return  object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ  System println f getPct OBJ   Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return  Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ System println f getPct OBJ Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return Exception applying instanceof fix would also cause fail,1
0,Math,NPE calling SubLine intersection non intersecting lines,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,1
0,Math,ArrayIndexOutOfBoundsException MathArrays linearCombination,MathArrays linearCombination passed arguments length 1 throws ArrayOutOfBoundsException caused line double prodHighNext prodHigh 1 linearCombination check length arguments fall back simple multiplication length 1,MathArrays linearCombination passed arguments length  throws ArrayOutOfBoundsException caused line double prodHighNext prodHigh  linearCombination check length arguments fall back simple multiplication length ,MathArrays linearCombination passed arguments length throws ArrayOutOfBoundsException caused line double prodHighNext prodHigh linearCombination check length arguments fall back simple multiplication length,1
0,Math,bug inverseCumulativeProbability Normal Distribution,version Revision 617953 Date 2008 02 02 22 54 00 0700 Sat 02 Feb 2008 public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision 506600 Date 2007 02 12 12 35 59 0700 Mon 12 Feb 2007 public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution 0 1 double result normal inverseCumulativeProbability 0 9772498680518209 gives exception return approx 2 0000 normal inverseCumulativeProbability 0 977249868051820 works fine also give errors 0 9986501019683698 return 3 0000 0 9999683287581673 return 4 0000 org apache commons math MathException Number iterations 1 maximum iterations 2 147 483 647 initial 1 lower bound 0 upper bound 179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final value 0 final b value 2 f 0 477 f b 0 org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java 103 org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java 145,version Revision  Date        Sat  Feb  public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision  Date        Mon  Feb  public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution   double result normal inverseCumulativeProbability   gives exception return approx   normal inverseCumulativeProbability   works fine also give errors   return     return   org apache commons math MathException Number iterations  maximum iterations     initial  lower bound  upper bound                                                                                                        final value  final b value  f   f b  org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java  org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java ,version Revision Date Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision Date Mon Feb public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution double result normal inverseCumulativeProbability gives exception return approx normal inverseCumulativeProbability works fine also give errors return return org apache commons math MathException Number iterations maximum iterations initial lower bound upper bound final value final b value f f b org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java,1
0,Math,SimplexSolver working expected 2,SimplexSolver find optimal solution Program Lpsolve Objective function max 7 3 b Constraints R1 3 5 c 0 R2 2 5 0 R3 2 b 5 c 0 R4 3 b 5 0 R5 3 2 b 5 R6 2 3 b 5 Variable bounds 1 b 1 Results correct 1 b 1 value 10 Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double 7 3 0 0 0 Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double 1 0 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 0 1 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 3 0 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 2 0 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 2 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 3 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 3 2 0 0 Relationship LEQ 5 podmienky add new LinearConstraint new double 2 3 0 0 Relationship LEQ 5 SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect 1 b 0 5 value 8 5 P used latest software repository including MATH 286 fix,SimplexSolver find optimal solution Program Lpsolve Objective function max   b Constraints R   c  R    R  b  c  R  b   R   b  R   b  Variable bounds  b  Results correct  b  value  Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double      Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect  b   value   P used latest software repository including MATH  fix,SimplexSolver find optimal solution Program Lpsolve Objective function max b Constraints R c R R b c R b R b R b Variable bounds b Results correct b value Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect b value P used latest software repository including MATH fix,1
0,Math,Complex ZERO reciprocal returns NaN return INF,Complex ZERO reciprocal returns NaN return INF Class org apache commons math3 complex Complex Method reciprocal version Id Complex java 1416643 2012 12 03 19 37 14Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java       Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java Z tn,1
0,Math,HarmonicFitter ParameterGuesser sometimes fails return sensible values,inner class ParameterGuesser HarmonicFitter package c optimization fitting fails compute usable guess amplitude parameter,inner class ParameterGuesser HarmonicFitter package c optimization fitting fails compute usable guess amplitude parameter,inner class ParameterGuesser HarmonicFitter package c optimization fitting fails compute usable guess amplitude parameter,1
0,Time,possibly bug org joda time field FieldUtils safeMultiply,seems currently written joda time 2 1 jar org joda time field FieldUtils safeMultiply long val1 int scalar detect overflow long val1 Long MIN VALUE int scalar 1 attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,seems currently written joda time   jar org joda time field FieldUtils safeMultiply long val int scalar detect overflow long val Long MIN VALUE int scalar  attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,seems currently written joda time jar org joda time field FieldUtils safeMultiply long val int scalar detect overflow long val Long MIN VALUE int scalar attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,1
0,Lang,NumberUtils createNumber bad behaviour leading,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,1
0,Lang,NumberUtils isNumber String right String 1 1L,1 1L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint, L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint,L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint,1
0,Closure,Break finally block optimized properly,None,None,None,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Math,wrong result eigen decomposition,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version 2 0 public void testMathpbx02 double mainTridiagonal 7484 860960227216 18405 28129035345 13855 225609560746 10016 708722343366 559 8117399576674 6750 190788301587 71 21428769782159 double secondaryTridiagonal 4175 088570476366 1975 7955858241994 5193 178422374075 1995 286659169179 75 34535882933804 234 0808002076056 reference values computed using routine DSTEMR fortran library LAPACK version 3 2 1 double refEigenValues 20654 744890306974412 16828 208208485466457 6893 155912634994820 6757 083016675340332 5887 799885688558788 64 309089923240379 57 992628792736340 RealVector refEigenVectors new ArrayRealVector new double 0 270356342026904 0 852811091326997 0 399639490702077 0 198794657813990 0 019739323307666 0 000106983022327 0 000001216636321 new ArrayRealVector new double 0 179995273578326 0 402807848153042 0 701870993525734 0 555058211014888 0 068079148898236 0 000509139115227 0 000007112235617 new ArrayRealVector new double 0 399582721284727 0 056629954519333 0 514406488522827 0 711168164518580 0 225548081276367 0 125943999652923 0 004321507456014 new ArrayRealVector new double 0 058515721572821 0 010200130057739 0 063516274916536 0 090696087449378 0 017148420432597 0 991318870265707 0 034707338554096 new ArrayRealVector new double 0 855205995537564 0 327134656629775 0 265382397060548 0 282690729026706 0 105736068025572 0 009138126622039 0 000367751821196 new ArrayRealVector new double 0 002913069901144 0 005177515777101 0 041906334478672 0 109315918416258 0 436192305456741 0 026307315639535 0 891797507436344 new ArrayRealVector new double 0 005738311176435 0 010207611670378 0 082662420517928 0 215733886094368 0 861606487840411 0 025478530652759 0 451080697503958 following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int 0 refEigenValues length assertEquals refEigenValues eigenValues 1 0e 3 refEigenVectors dotProduct decomposition getEigenvector 0 assertEquals 0 refEigenVectors add decomposition getEigenvector getNorm 1 0e 5 else assertEquals 0 refEigenVectors subtract decomposition getEigenvector getNorm 1 0e 5,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version   public void testMathpbx double mainTridiagonal               double secondaryTridiagonal             reference values computed using routine DSTEMR fortran library LAPACK version    double refEigenValues               RealVector refEigenVectors new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int  refEigenValues length assertEquals refEigenValues eigenValues  e  refEigenVectors dotProduct decomposition getEigenvector  assertEquals  refEigenVectors add decomposition getEigenvector getNorm  e  else assertEquals  refEigenVectors subtract decomposition getEigenvector getNorm  e ,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version public void testMathpbx double mainTridiagonal double secondaryTridiagonal reference values computed using routine DSTEMR fortran library LAPACK version double refEigenValues RealVector refEigenVectors new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int refEigenValues length assertEquals refEigenValues eigenValues e refEigenVectors dotProduct decomposition getEigenvector assertEquals refEigenVectors add decomposition getEigenvector getNorm e else assertEquals refEigenVectors subtract decomposition getEigenvector getNorm e,1
0,Lang,ClassUtils toClass Object throws NPE null array element,see summary,see summary,see summary,1
0,Closure,Classify non rightmost expressions problematic,None,None,None,1
0,Closure,Break finally block optimized properly,None,None,None,1
0,Closure,Erroneous optimization ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,Classify non rightmost expressions problematic,None,None,None,1
0,Closure,Break finally block optimized properly,None,None,None,1
0,Closure,Erroneous optimization ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,smartNameRemoval causing compiler crash,None,None,None,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze gives bad results commons math3 3 0 simple test problem works well commons math 2 2,Methode SimplexSolver optimeze gives bad results commons math   simple test problem works well commons math  ,Methode SimplexSolver optimeze gives bad results commons math simple test problem works well commons math,1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line 640 RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line  RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line RealMatrixImpl java read double new double nRows instead double new double v length,1
0,Math,One Variance evaluate methods work correctly,method org apache commons math stat descriptive moment Variance evaluate double values double weights double mean int begin int length work properly Looks loke ignores length parameter grabs whole dataset Similar method Mean class seems work check methods taking part array may problem Workaround shrink arrays use method without length,method org apache commons math stat descriptive moment Variance evaluate double values double weights double mean int begin int length work properly Looks loke ignores length parameter grabs whole dataset Similar method Mean class seems work check methods taking part array may problem Workaround shrink arrays use method without length,method org apache commons math stat descriptive moment Variance evaluate double values double weights double mean int begin int length work properly Looks loke ignores length parameter grabs whole dataset Similar method Mean class seems work check methods taking part array may problem Workaround shrink arrays use method without length,1
0,Time,DateTimeFormat parseInto sometimes miscalculates year 2 2,following code added org joda time format TestDateTimeFormatter breaks input mutable date time millis appear mishandled year parse changed 1999,following code added org joda time format TestDateTimeFormatter breaks input mutable date time millis appear mishandled year parse changed ,following code added org joda time format TestDateTimeFormatter breaks input mutable date time millis appear mishandled year parse changed,1
0,Lang,NullPointerException isAvailableLocale Locale,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,1
0,Lang,NumberUtils createNumber bad behaviour leading,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,1
0,Lang,ExtendedMessageFormat OutOfMemory custom format registry pattern containing single quotes,using ExtendedMessageFormat custom format registry pattern conatining single quotes OutOfMemoryError occur Example cause error ExtendedMessageFormatTest java private static Map String Object formatRegistry new HashMap String Object static formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory public static void main String args ExtendedMessageFormat mf new ExtendedMessageFormat dummy test formatRegistry String formattedPattern mf format new String great System println formattedPattern following change starting line 421 2 4 release seems fix problem ExtendedMessageFormat java CURRENT Broken escapingOn c start QUOTE return appendTo null null appendTo append QUOTE WORKING escapingOn c start QUOTE next pos return appendTo null null appendTo append QUOTE,using ExtendedMessageFormat custom format registry pattern conatining single quotes OutOfMemoryError occur Example cause error ExtendedMessageFormatTest java private static Map String Object formatRegistry new HashMap String Object static formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory public static void main String args ExtendedMessageFormat mf new ExtendedMessageFormat dummy test formatRegistry String formattedPattern mf format new String great System println formattedPattern following change starting line    release seems fix problem ExtendedMessageFormat java CURRENT Broken escapingOn c start QUOTE return appendTo null null appendTo append QUOTE WORKING escapingOn c start QUOTE next pos return appendTo null null appendTo append QUOTE,using ExtendedMessageFormat custom format registry pattern conatining single quotes OutOfMemoryError occur Example cause error ExtendedMessageFormatTest java private static Map String Object formatRegistry new HashMap String Object static formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory public static void main String args ExtendedMessageFormat mf new ExtendedMessageFormat dummy test formatRegistry String formattedPattern mf format new String great System println formattedPattern following change starting line release seems fix problem ExtendedMessageFormat java CURRENT Broken escapingOn c start QUOTE return appendTo null null appendTo append QUOTE WORKING escapingOn c start QUOTE next pos return appendTo null null appendTo append QUOTE,1
0,Lang,org apache commons lang3 math Fraction reduce Integer MIN VALUE 2 k,greatestCommonDivisor method class Fraction find gcd Integer MIN VALUE 2 k case triggered taking Integer MIN VALUE numerator Note case taking Integer MIN VALUE denominator handled explicitly getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int f Fraction getReducedFraction Integer MIN VALUE 2 assertEquals Integer MIN VALUE 2 f getNumerator assertEquals 1 f getDenominator public void testReduce f Fraction getFraction Integer MIN VALUE 2 result f reduce assertEquals Integer MIN VALUE 2 result getNumerator assertEquals 1 result getDenominator,greatestCommonDivisor method class Fraction find gcd Integer MIN VALUE  k case triggered taking Integer MIN VALUE numerator Note case taking Integer MIN VALUE denominator handled explicitly getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int f Fraction getReducedFraction Integer MIN VALUE  assertEquals Integer MIN VALUE  f getNumerator assertEquals  f getDenominator public void testReduce f Fraction getFraction Integer MIN VALUE  result f reduce assertEquals Integer MIN VALUE  result getNumerator assertEquals  result getDenominator,greatestCommonDivisor method class Fraction find gcd Integer MIN VALUE k case triggered taking Integer MIN VALUE numerator Note case taking Integer MIN VALUE denominator handled explicitly getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int f Fraction getReducedFraction Integer MIN VALUE assertEquals Integer MIN VALUE f getNumerator assertEquals f getDenominator public void testReduce f Fraction getFraction Integer MIN VALUE result f reduce assertEquals Integer MIN VALUE result getNumerator assertEquals result getDenominator,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path1 GeneralPath path2 thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,1
0,Math,BisectionSolver solve final UnivariateRealFunction f double min double max double initial throws NullPointerException,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl 0 0 1 0 0 5 NullPointerException thrown,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl       NullPointerException thrown,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl NullPointerException thrown,1
0,Lang,NumberUtils createNumber thows StringIndexOutOfBoundsException l passed,Seems similar LANG 300 except place digit front l L throws StringIndexOutOfBoundsException instead,Seems similar LANG  except place digit front l L throws StringIndexOutOfBoundsException instead,Seems similar LANG except place digit front l L throws StringIndexOutOfBoundsException instead,1
0,Closure,side effects analysis incorrectly removing function calls side effects,None,None,None,1
0,Closure,Column indicating caret sometimes error output,None,None,None,1
0,Closure,Constructor types return unknown fail parse,None,None,None,1
0,Closure,Converting interface type constructor implements causes stack overflow,None,None,None,1
0,Closure,division zero wrongly throws JSC DIVIDE 0 ERROR,None,None,None,1
0,Chart,Potential NPE AbstractCategoryItemRender getLegendItems,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,1
0,Chart,Fix MultiplePiePlot,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,1
0,Math,FastMath max 50 0f 50 0f 50 0f 50 0f,FastMath max 50 0f 50 0f 50 0f 50 0f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,FastMath max  f  f  f  f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,FastMath max f f f f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,1
0,Math,Need range checks elitismRate ElitisticListPopulation constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze gives bad results commons math3 3 0 simple test problem works well commons math 2 2,Methode SimplexSolver optimeze gives bad results commons math   simple test problem works well commons math  ,Methode SimplexSolver optimeze gives bad results commons math simple test problem works well commons math,1
0,Math,stat Frequency getPct Object uses getCumPct Comparable instead getPct Comparable,Drop Replacement 1 2 2 0 possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable 2 0 Deprecated public double getPct Object v return getCumPct Comparable v,Drop Replacement     possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable   Deprecated public double getPct Object v return getCumPct Comparable v,Drop Replacement possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable Deprecated public double getPct Object v return getCumPct Comparable v,1
0,Math,Statistics setVarianceImpl makes getStandardDeviation produce NaN,Invoking SummaryStatistics setVarianceImpl new Variance true false makes getStandardDeviation produce NaN code reproduce int scores 1 2 3 4 SummaryStatistics stats new SummaryStatistics stats setVarianceImpl new Variance false use population variance int scores stats addValue double sd stats getStandardDeviation System println sd workaround suggested Mikkel double sd FastMath sqrt stats getSecondMoment stats getN,Invoking SummaryStatistics setVarianceImpl new Variance true false makes getStandardDeviation produce NaN code reproduce int scores     SummaryStatistics stats new SummaryStatistics stats setVarianceImpl new Variance false use population variance int scores stats addValue double sd stats getStandardDeviation System println sd workaround suggested Mikkel double sd FastMath sqrt stats getSecondMoment stats getN,Invoking SummaryStatistics setVarianceImpl new Variance true false makes getStandardDeviation produce NaN code reproduce int scores SummaryStatistics stats new SummaryStatistics stats setVarianceImpl new Variance false use population variance int scores stats addValue double sd stats getStandardDeviation System println sd workaround suggested Mikkel double sd FastMath sqrt stats getSecondMoment stats getN,1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line 640 RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line  RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line RealMatrixImpl java read double new double nRows instead double new double v length,1
0,Math,Division zero,class Complex division zero always returns NaN think return NaN numerator also ZERO otherwise result INF See,class Complex division zero always returns NaN think return NaN numerator also ZERO otherwise result INF See,class Complex division zero always returns NaN think return NaN numerator also ZERO otherwise result INF See,1
0,Math,BrentOptimizer always reporting best point,BrentOptimizer package c optimization univariate check point going return indeed best one encountered Indeed last evaluated point might slightly worse one last,BrentOptimizer package c optimization univariate check point going return indeed best one encountered Indeed last evaluated point might slightly worse one last,BrentOptimizer package c optimization univariate check point going return indeed best one encountered Indeed last evaluated point might slightly worse one last,1
0,Math,NPE calling SubLine intersection non intersecting lines,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,1
0,Math,MathRuntimeException simple ebeMultiply OpenMapRealVector,following piece code import org apache commons math linear OpenMapRealVector import org apache commons math linear RealVector public class DemoBugOpenMapRealVector public static void main String args final RealVector u new OpenMapRealVector 3 1E 6 u setEntry 0 1 u setEntry 1 0 u setEntry 2 2 final RealVector v new OpenMapRealVector 3 1E 6 v setEntry 0 0 v setEntry 1 3 v setEntry 2 0 System println u System println v System println u ebeMultiply v raises exception org apache commons math linear OpenMapRealVector 7170a9b6 Exception thread main org apache commons math MathRuntimeException 6 map modified iterating org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java 373 org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java 564 org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java 372 org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java 1 DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java 17,following piece code import org apache commons math linear OpenMapRealVector import org apache commons math linear RealVector public class DemoBugOpenMapRealVector public static void main String args final RealVector u new OpenMapRealVector  E  u setEntry   u setEntry   u setEntry   final RealVector v new OpenMapRealVector  E  v setEntry   v setEntry   v setEntry   System println u System println v System println u ebeMultiply v raises exception org apache commons math linear OpenMapRealVector ab Exception thread main org apache commons math MathRuntimeException  map modified iterating org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java  org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java  org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java  org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java  DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java ,following piece code import org apache commons math linear OpenMapRealVector import org apache commons math linear RealVector public class DemoBugOpenMapRealVector public static void main String args final RealVector u new OpenMapRealVector E u setEntry u setEntry u setEntry final RealVector v new OpenMapRealVector E v setEntry v setEntry v setEntry System println u System println v System println u ebeMultiply v raises exception org apache commons math linear OpenMapRealVector ab Exception thread main org apache commons math MathRuntimeException map modified iterating org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java,1
0,Math,HarmonicFitter ParameterGuesser sometimes fails return sensible values,inner class ParameterGuesser HarmonicFitter package c optimization fitting fails compute usable guess amplitude parameter,inner class ParameterGuesser HarmonicFitter package c optimization fitting fails compute usable guess amplitude parameter,inner class ParameterGuesser HarmonicFitter package c optimization fitting fails compute usable guess amplitude parameter,1
0,Time,withHourOfDay sets hour inconsistantly DST transition,hour day set ambiguous hour daylight standard time transition given time zone result inconsistent different time zones Shoul hour set daylight hour standard hour time zones find anything documents behavior test code returns different results different time zones last assertion fails Australia time zone cutover,hour day set ambiguous hour daylight standard time transition given time zone result inconsistent different time zones Shoul hour set daylight hour standard hour time zones find anything documents behavior test code returns different results different time zones last assertion fails Australia time zone cutover,hour day set ambiguous hour daylight standard time transition given time zone result inconsistent different time zones Shoul hour set daylight hour standard hour time zones find anything documents behavior test code returns different results different time zones last assertion fails Australia time zone cutover,1
0,Time,Constructing invalid Partials,Partials constructed invoking constructor Partial DateTimeFieldType int merging together set partials using constructed calling Partial DateTimeFieldType int However work cases suppose Partials allow constructed either case right also related issue probably stems fact Partial invalid,Partials constructed invoking constructor Partial DateTimeFieldType int merging together set partials using constructed calling Partial DateTimeFieldType int However work cases suppose Partials allow constructed either case right also related issue probably stems fact Partial invalid,Partials constructed invoking constructor Partial DateTimeFieldType int merging together set partials using constructed calling Partial DateTimeFieldType int However work cases suppose Partials allow constructed either case right also related issue probably stems fact Partial invalid,1
0,Lang,StrBuilder contains usages thisBuf length use size,fixing LANG 294 noticed two places StrBuilder reference thisBuf length unless mistaken,fixing LANG  noticed two places StrBuilder reference thisBuf length unless mistaken,fixing LANG noticed two places StrBuilder reference thisBuf length unless mistaken,1
0,Lang,ClassUtils toClass Object throws NPE null array element,see summary,see summary,see summary,1
0,Lang,DateFormatUtils format correctly change Calendar TimeZone certain situations,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z commonly constructed cal new GregorianCalendar 2009 9 16 8 42 16 unit test work time zone constructing GMT 8 rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime   T   Z commonly constructed cal new GregorianCalendar       unit test work time zone constructing GMT  rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime   T   Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime Z commonly constructed cal new GregorianCalendar unit test work time zone constructing GMT rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,1
0,Lang,StrBuilder appendFixedWidth handle nulls,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,1
0,Math,NPE KMeansPlusPlusClusterer unittest,running unittest facing NPE java lang NullPointerException org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java 91 unittest package org fao fisheries chronicles calcuation cluster import static org junit Assert assertEquals import static org junit Assert assertTrue import java util Arrays import java util List import java util Random import org apache commons math stat clustering Cluster import org apache commons math stat clustering EuclideanIntegerPoint import org apache commons math stat clustering KMeansPlusPlusClusterer import org fao fisheries chronicles input CsvImportProcess import org fao fisheries chronicles input Top200Csv import org junit Test public class ClusterAnalysisTest Test public void testPerformClusterAnalysis2 KMeansPlusPlusClusterer EuclideanIntegerPoint transformer new KMeansPlusPlusClusterer EuclideanIntegerPoint new Random 1746432956321l EuclideanIntegerPoint points new EuclideanIntegerPoint new EuclideanIntegerPoint new int 1959 325100 new EuclideanIntegerPoint new int 1960 373200 List Cluster EuclideanIntegerPoint clusters transformer cluster Arrays asList points 1 1 assertEquals 1 clusters size,running unittest facing NPE java lang NullPointerException org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java  unittest package org fao fisheries chronicles calcuation cluster import static org junit Assert assertEquals import static org junit Assert assertTrue import java util Arrays import java util List import java util Random import org apache commons math stat clustering Cluster import org apache commons math stat clustering EuclideanIntegerPoint import org apache commons math stat clustering KMeansPlusPlusClusterer import org fao fisheries chronicles input CsvImportProcess import org fao fisheries chronicles input TopCsv import org junit Test public class ClusterAnalysisTest Test public void testPerformClusterAnalysis KMeansPlusPlusClusterer EuclideanIntegerPoint transformer new KMeansPlusPlusClusterer EuclideanIntegerPoint new Random l EuclideanIntegerPoint points new EuclideanIntegerPoint new EuclideanIntegerPoint new int   new EuclideanIntegerPoint new int   List Cluster EuclideanIntegerPoint clusters transformer cluster Arrays asList points   assertEquals  clusters size,running unittest facing NPE java lang NullPointerException org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java unittest package org fao fisheries chronicles calcuation cluster import static org junit Assert assertEquals import static org junit Assert assertTrue import java util Arrays import java util List import java util Random import org apache commons math stat clustering Cluster import org apache commons math stat clustering EuclideanIntegerPoint import org apache commons math stat clustering KMeansPlusPlusClusterer import org fao fisheries chronicles input CsvImportProcess import org fao fisheries chronicles input TopCsv import org junit Test public class ClusterAnalysisTest Test public void testPerformClusterAnalysis KMeansPlusPlusClusterer EuclideanIntegerPoint transformer new KMeansPlusPlusClusterer EuclideanIntegerPoint new Random l EuclideanIntegerPoint points new EuclideanIntegerPoint new EuclideanIntegerPoint new int new EuclideanIntegerPoint new int List Cluster EuclideanIntegerPoint clusters transformer cluster Arrays asList points assertEquals clusters size,1
0,Lang,BooleanUtils toBoolean invalid drop thru case statement causes StringIndexOutOfBoundsException,method BooleanUtils toBoolean case statement case 3 drops case 4 cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case 3 return false Patch follow source unit test,method BooleanUtils toBoolean case statement case  drops case  cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case  return false Patch follow source unit test,method BooleanUtils toBoolean case statement case drops case cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case return false Patch follow source unit test,1
0,Lang,LocaleUtils toLocale rejects strings language variant,LocaleUtils toLocale throws exception strings containing language variant country code example fr POSIX string produced JDK instanciating Locale empty string country new Locale fr POSIX toString According javadoc Locale class variant allowed language code country code Commons Configuration handles case PropertyConverter toLocale method like replace implementation one provided LocaleUtils tests fail due case,LocaleUtils toLocale throws exception strings containing language variant country code example fr POSIX string produced JDK instanciating Locale empty string country new Locale fr POSIX toString According javadoc Locale class variant allowed language code country code Commons Configuration handles case PropertyConverter toLocale method like replace implementation one provided LocaleUtils tests fail due case,LocaleUtils toLocale throws exception strings containing language variant country code example fr POSIX string produced JDK instanciating Locale empty string country new Locale fr POSIX toString According javadoc Locale class variant allowed language code country code Commons Configuration handles case PropertyConverter toLocale method like replace implementation one provided LocaleUtils tests fail due case,1
0,Closure,Identifier minus negative number needs space,None,None,None,1
0,Closure,Add support manage closure dependencies closure dependencies compilation level WHITESPACE,None,None,None,1
0,Closure,ClassCastException TypeCheck pass,None,None,None,1
0,Chart,Error TimeSeries createCopy method,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart 1 0 7,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart   ,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart,1
0,Chart,Fix MultiplePiePlot,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,1
0,Math,Truncation issue KMeansPlusPlusClusterer,loop inside KMeansPlusPlusClusterer chooseInitialClusters defines variable int sum 0 variable type double rather int Using int causes method truncate distances points square roots integers especially bad distances points typically less 1 aside version 2 2 bug manifested making clusterer return empty clusters wonder EmptyClusterStrategy would still necessary bug fixed,loop inside KMeansPlusPlusClusterer chooseInitialClusters defines variable int sum  variable type double rather int Using int causes method truncate distances points square roots integers especially bad distances points typically less  aside version   bug manifested making clusterer return empty clusters wonder EmptyClusterStrategy would still necessary bug fixed,loop inside KMeansPlusPlusClusterer chooseInitialClusters defines variable int sum variable type double rather int Using int causes method truncate distances points square roots integers especially bad distances points typically less aside version bug manifested making clusterer return empty clusters wonder EmptyClusterStrategy would still necessary bug fixed,1
0,Math,MathUtils gcd u v fails u v contain high power 2,test beginning MathUtils gcd u v arguments equal zero fails u v contain high enough powers 2 product overflows zero assertEquals 3 1 15 MathUtils gcd 3 1 20 9 1 15 Fix Replace test start MathUtils gcd u v 0 u 0 || v 0,test beginning MathUtils gcd u v arguments equal zero fails u v contain high enough powers  product overflows zero assertEquals    MathUtils gcd       Fix Replace test start MathUtils gcd u v  u  || v ,test beginning MathUtils gcd u v arguments equal zero fails u v contain high enough powers product overflows zero assertEquals MathUtils gcd Fix Replace test start MathUtils gcd u v u || v,1
0,Math,ListPopulation Iterator allows remove chromosomes population,Calling iterator method ListPopulation returns iterator protected modifiable list returning iterator wrap unmodifiable list,Calling iterator method ListPopulation returns iterator protected modifiable list returning iterator wrap unmodifiable list,Calling iterator method ListPopulation returns iterator protected modifiable list returning iterator wrap unmodifiable list,1
0,Math,Fraction percentageValue rare overflow,percentageValue method Fraction class works first multiplying Fraction 100 converting Fraction double causes overflows numerator greater Integer MAX VALUE 100 even value fraction far value patch changes method first convert double value multiply value 100 result less overflows addition test method covers bug also included,percentageValue method Fraction class works first multiplying Fraction  converting Fraction double causes overflows numerator greater Integer MAX VALUE  even value fraction far value patch changes method first convert double value multiply value  result less overflows addition test method covers bug also included,percentageValue method Fraction class works first multiplying Fraction converting Fraction double causes overflows numerator greater Integer MAX VALUE even value fraction far value patch changes method first convert double value multiply value result less overflows addition test method covers bug also included,1
0,Math,wrong result eigen decomposition,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version 2 0 public void testMathpbx02 double mainTridiagonal 7484 860960227216 18405 28129035345 13855 225609560746 10016 708722343366 559 8117399576674 6750 190788301587 71 21428769782159 double secondaryTridiagonal 4175 088570476366 1975 7955858241994 5193 178422374075 1995 286659169179 75 34535882933804 234 0808002076056 reference values computed using routine DSTEMR fortran library LAPACK version 3 2 1 double refEigenValues 20654 744890306974412 16828 208208485466457 6893 155912634994820 6757 083016675340332 5887 799885688558788 64 309089923240379 57 992628792736340 RealVector refEigenVectors new ArrayRealVector new double 0 270356342026904 0 852811091326997 0 399639490702077 0 198794657813990 0 019739323307666 0 000106983022327 0 000001216636321 new ArrayRealVector new double 0 179995273578326 0 402807848153042 0 701870993525734 0 555058211014888 0 068079148898236 0 000509139115227 0 000007112235617 new ArrayRealVector new double 0 399582721284727 0 056629954519333 0 514406488522827 0 711168164518580 0 225548081276367 0 125943999652923 0 004321507456014 new ArrayRealVector new double 0 058515721572821 0 010200130057739 0 063516274916536 0 090696087449378 0 017148420432597 0 991318870265707 0 034707338554096 new ArrayRealVector new double 0 855205995537564 0 327134656629775 0 265382397060548 0 282690729026706 0 105736068025572 0 009138126622039 0 000367751821196 new ArrayRealVector new double 0 002913069901144 0 005177515777101 0 041906334478672 0 109315918416258 0 436192305456741 0 026307315639535 0 891797507436344 new ArrayRealVector new double 0 005738311176435 0 010207611670378 0 082662420517928 0 215733886094368 0 861606487840411 0 025478530652759 0 451080697503958 following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int 0 refEigenValues length assertEquals refEigenValues eigenValues 1 0e 3 refEigenVectors dotProduct decomposition getEigenvector 0 assertEquals 0 refEigenVectors add decomposition getEigenvector getNorm 1 0e 5 else assertEquals 0 refEigenVectors subtract decomposition getEigenvector getNorm 1 0e 5,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version   public void testMathpbx double mainTridiagonal               double secondaryTridiagonal             reference values computed using routine DSTEMR fortran library LAPACK version    double refEigenValues               RealVector refEigenVectors new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int  refEigenValues length assertEquals refEigenValues eigenValues  e  refEigenVectors dotProduct decomposition getEigenvector  assertEquals  refEigenVectors add decomposition getEigenvector getNorm  e  else assertEquals  refEigenVectors subtract decomposition getEigenvector getNorm  e ,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version public void testMathpbx double mainTridiagonal double secondaryTridiagonal reference values computed using routine DSTEMR fortran library LAPACK version double refEigenValues RealVector refEigenVectors new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int refEigenValues length assertEquals refEigenValues eigenValues e refEigenVectors dotProduct decomposition getEigenvector assertEquals refEigenVectors add decomposition getEigenvector getNorm e else assertEquals refEigenVectors subtract decomposition getEigenvector getNorm e,1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line 640 RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line  RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line RealMatrixImpl java read double new double nRows instead double new double v length,1
0,Math,Mann Whitney U Test Suffers Integer Overflow Large Data Sets,performing Mann Whitney U Test large data sets attached test uses two 1500 element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,performing Mann Whitney U Test large data sets attached test uses two  element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,performing Mann Whitney U Test large data sets attached test uses two element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,1
0,Math,Bugs Frequency API,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return 0 object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ 0 System println f getPct OBJ 0 0 Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return 0 Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return  object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ  System println f getPct OBJ   Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return  Exception applying instanceof fix would also cause fail,think existing Frequency API bugs addValue Object v method allows one add plain Object one cannot add anything instance second add fails IllegalArgumentException fact problem first call addValue Object allow plain Object added allow Comparable objects could fixed checking object Comparable Similar considerations apply getCumFreq Object getCumPct Object methods work objects implement Comparable getCount Object getPct Object methods fail given non Comparable object class cast exception caught however return object present final Object OBJ new Object f addValue OBJ ought fail causing unexpected behaviour System println f getCount OBJ System println f getPct OBJ Rather adding extra checks Comparable seems API would much improved using Comparable instead Object Also make easier implement generics However would cause compilation failures programs pass Object rather Comparable class would need recoding think would continue run OK new API would also affect run time behaviour slightly first attempt add non Comparable object would fail rather second add possibly valid object viable program add one object attempt get statistics either return Exception applying instanceof fix would also cause fail,1
0,Math,getLInfNorm uses wrong formula ArrayRealVector OpenMapRealVector different ways,L infinity norm finite dimensional vector max absolute value entries current implementation ArrayRealVector typo public double getLInfNorm double max 0 double data max Math max max Math abs return max sadly unit test assuring us correct behavior effectively regression test test correctness Worse implementation OpenMapRealVector even positive semi definite public double getLInfNorm double max 0 Iterator iter entries iterator iter hasNext iter advance max iter value return max would suggest method moved AbstractRealVector superclass implemented using sparseIterator public double getLInfNorm double norm 0 Iterator Entry sparseIterator Entry e hasNext e next null norm Math max norm Math abs e getValue return norm Unit tests negative valued vectors would helpful check kind thing future,L infinity norm finite dimensional vector max absolute value entries current implementation ArrayRealVector typo public double getLInfNorm double max  double data max Math max max Math abs return max sadly unit test assuring us correct behavior effectively regression test test correctness Worse implementation OpenMapRealVector even positive semi definite public double getLInfNorm double max  Iterator iter entries iterator iter hasNext iter advance max iter value return max would suggest method moved AbstractRealVector superclass implemented using sparseIterator public double getLInfNorm double norm  Iterator Entry sparseIterator Entry e hasNext e next null norm Math max norm Math abs e getValue return norm Unit tests negative valued vectors would helpful check kind thing future,L infinity norm finite dimensional vector max absolute value entries current implementation ArrayRealVector typo public double getLInfNorm double max double data max Math max max Math abs return max sadly unit test assuring us correct behavior effectively regression test test correctness Worse implementation OpenMapRealVector even positive semi definite public double getLInfNorm double max Iterator iter entries iterator iter hasNext iter advance max iter value return max would suggest method moved AbstractRealVector superclass implemented using sparseIterator public double getLInfNorm double norm Iterator Entry sparseIterator Entry e hasNext e next null norm Math max norm Math abs e getValue return norm Unit tests negative valued vectors would helpful check kind thing future,1
0,Math,SimplexSolver working expected 2,SimplexSolver find optimal solution Program Lpsolve Objective function max 7 3 b Constraints R1 3 5 c 0 R2 2 5 0 R3 2 b 5 c 0 R4 3 b 5 0 R5 3 2 b 5 R6 2 3 b 5 Variable bounds 1 b 1 Results correct 1 b 1 value 10 Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double 7 3 0 0 0 Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double 1 0 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 0 1 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 3 0 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 2 0 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 2 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 3 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 3 2 0 0 Relationship LEQ 5 podmienky add new LinearConstraint new double 2 3 0 0 Relationship LEQ 5 SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect 1 b 0 5 value 8 5 P used latest software repository including MATH 286 fix,SimplexSolver find optimal solution Program Lpsolve Objective function max   b Constraints R   c  R    R  b  c  R  b   R   b  R   b  Variable bounds  b  Results correct  b  value  Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double      Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect  b   value   P used latest software repository including MATH  fix,SimplexSolver find optimal solution Program Lpsolve Objective function max b Constraints R c R R b c R b R b R b Variable bounds b Results correct b value Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect b value P used latest software repository including MATH fix,1
0,Math,HypergeometricDistribution sample suffers integer overflow,Hi application broke ported commons math 2 2 3 2 looks like HypergeometricDistribution sample method work well used large integer values – example code return sample 0 50 usually returns 50 import org apache commons math3 distribution HypergeometricDistribution public class Foo public static void main String args HypergeometricDistribution new HypergeometricDistribution 43130568 42976365 50 System printf n getSupportLowerBound getSupportUpperBound Prints 0 50 System printf n sample Prints 50 debugger traced far integer overflow HypergeometricDistribution getNumericalMean – instead return double getSampleSize getNumberOfSuccesses double getPopulationSize could return getSampleSize double getNumberOfSuccesses double getPopulationSize seemed fix based quick test,Hi application broke ported commons math     looks like HypergeometricDistribution sample method work well used large integer values – example code return sample   usually returns  import org apache commons math distribution HypergeometricDistribution public class Foo public static void main String args HypergeometricDistribution new HypergeometricDistribution    System printf n getSupportLowerBound getSupportUpperBound Prints   System printf n sample Prints  debugger traced far integer overflow HypergeometricDistribution getNumericalMean – instead return double getSampleSize getNumberOfSuccesses double getPopulationSize could return getSampleSize double getNumberOfSuccesses double getPopulationSize seemed fix based quick test,Hi application broke ported commons math looks like HypergeometricDistribution sample method work well used large integer values – example code return sample usually returns import org apache commons math distribution HypergeometricDistribution public class Foo public static void main String args HypergeometricDistribution new HypergeometricDistribution System printf n getSupportLowerBound getSupportUpperBound Prints System printf n sample Prints debugger traced far integer overflow HypergeometricDistribution getNumericalMean – instead return double getSampleSize getNumberOfSuccesses double getPopulationSize could return getSampleSize double getNumberOfSuccesses double getPopulationSize seemed fix based quick test,1
0,Lang,BooleanUtils toBoolean invalid drop thru case statement causes StringIndexOutOfBoundsException,method BooleanUtils toBoolean case statement case 3 drops case 4 cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case 3 return false Patch follow source unit test,method BooleanUtils toBoolean case statement case  drops case  cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case  return false Patch follow source unit test,method BooleanUtils toBoolean case statement case drops case cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case return false Patch follow source unit test,1
0,Lang,ClassUtils toClass Object throws NPE null array element,see summary,see summary,see summary,1
0,Lang,FastDateParser handle white space properly,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,1
0,Mockito,fixed verify call example Captor javadoc,None,None,None,1
0,Mockito,1 10 regression StackOverflowError interface generic type upper bound,None,None,None,1
0,Mockito,Generate change list separated types using labels,discussed mailing list instead one big list Improvements change list release divided change types based labels required specify labels considered separately labels excluded like question refactoring also headerForOtherChanges method override default header,discussed mailing list instead one big list Improvements change list release divided change types based labels required specify labels considered separately labels excluded like question refactoring also headerForOtherChanges method override default header,discussed mailing list instead one big list Improvements change list release divided change types based labels required specify labels considered separately labels excluded like question refactoring also headerForOtherChanges method override default header,1
0,Closure,weird object literal invalid property error unrelated object prototype,None,None,None,1
0,Closure,Dependency sorting closurePass set false longer works,None,None,None,1
0,Closure,Codepoint U 007f appears raw output,None,None,None,1
0,Closure,Add support manage closure dependencies closure dependencies compilation level WHITESPACE,None,None,None,1
0,Closure,Column indicating caret sometimes error output,None,None,None,1
0,Closure,Column indicating caret sometimes error output,None,None,None,1
0,Closure,unexpected typed coverage less 100,None,None,None,1
0,Chart,Error TimeSeries createCopy method,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart 1 0 7,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart   ,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart,1
0,Chart,Error TimeSeries createCopy method,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart 1 0 7,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart   ,test case end fails java lang IllegalArgumentException Requires start end problem int start end indexes corresponding given timePeriod computed incorectly would expect empty serie returned exception jfreechart,1
0,Chart,Potential NPE AbstractCategoryItemRender getLegendItems,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Math,BSPTree class recovery Euclidean 3D BRep,New work Thanks efforts code create BSPTree BoundaryRep Brep test Brep cube represented float array containing 8 3D points x z order array indices 12 triplets 12 faces cube construct BSPMesh shown code construct PolyhedronsSet problems extracting faces BSPTree reconstruct BRep attached code BSPMesh2 java shows small change 1 vertex positions causes corrects problem ideas,New work Thanks efforts code create BSPTree BoundaryRep Brep test Brep cube represented float array containing  D points x z order array indices  triplets  faces cube construct BSPMesh shown code construct PolyhedronsSet problems extracting faces BSPTree reconstruct BRep attached code BSPMesh java shows small change  vertex positions causes corrects problem ideas,New work Thanks efforts code create BSPTree BoundaryRep Brep test Brep cube represented float array containing points x z order array indices triplets faces cube construct BSPMesh shown code construct PolyhedronsSet problems extracting faces BSPTree reconstruct BRep attached code BSPMesh java shows small change vertex positions causes corrects problem ideas,1
0,Math,wrong result eigen decomposition,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version 2 0 public void testMathpbx02 double mainTridiagonal 7484 860960227216 18405 28129035345 13855 225609560746 10016 708722343366 559 8117399576674 6750 190788301587 71 21428769782159 double secondaryTridiagonal 4175 088570476366 1975 7955858241994 5193 178422374075 1995 286659169179 75 34535882933804 234 0808002076056 reference values computed using routine DSTEMR fortran library LAPACK version 3 2 1 double refEigenValues 20654 744890306974412 16828 208208485466457 6893 155912634994820 6757 083016675340332 5887 799885688558788 64 309089923240379 57 992628792736340 RealVector refEigenVectors new ArrayRealVector new double 0 270356342026904 0 852811091326997 0 399639490702077 0 198794657813990 0 019739323307666 0 000106983022327 0 000001216636321 new ArrayRealVector new double 0 179995273578326 0 402807848153042 0 701870993525734 0 555058211014888 0 068079148898236 0 000509139115227 0 000007112235617 new ArrayRealVector new double 0 399582721284727 0 056629954519333 0 514406488522827 0 711168164518580 0 225548081276367 0 125943999652923 0 004321507456014 new ArrayRealVector new double 0 058515721572821 0 010200130057739 0 063516274916536 0 090696087449378 0 017148420432597 0 991318870265707 0 034707338554096 new ArrayRealVector new double 0 855205995537564 0 327134656629775 0 265382397060548 0 282690729026706 0 105736068025572 0 009138126622039 0 000367751821196 new ArrayRealVector new double 0 002913069901144 0 005177515777101 0 041906334478672 0 109315918416258 0 436192305456741 0 026307315639535 0 891797507436344 new ArrayRealVector new double 0 005738311176435 0 010207611670378 0 082662420517928 0 215733886094368 0 861606487840411 0 025478530652759 0 451080697503958 following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int 0 refEigenValues length assertEquals refEigenValues eigenValues 1 0e 3 refEigenVectors dotProduct decomposition getEigenvector 0 assertEquals 0 refEigenVectors add decomposition getEigenvector getNorm 1 0e 5 else assertEquals 0 refEigenVectors subtract decomposition getEigenvector getNorm 1 0e 5,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version   public void testMathpbx double mainTridiagonal               double secondaryTridiagonal             reference values computed using routine DSTEMR fortran library LAPACK version    double refEigenValues               RealVector refEigenVectors new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int  refEigenValues length assertEquals refEigenValues eigenValues  e  refEigenVectors dotProduct decomposition getEigenvector  assertEquals  refEigenVectors add decomposition getEigenvector getNorm  e  else assertEquals  refEigenVectors subtract decomposition getEigenvector getNorm  e ,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version public void testMathpbx double mainTridiagonal double secondaryTridiagonal reference values computed using routine DSTEMR fortran library LAPACK version double refEigenValues RealVector refEigenVectors new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int refEigenValues length assertEquals refEigenValues eigenValues e refEigenVectors dotProduct decomposition getEigenvector assertEquals refEigenVectors add decomposition getEigenvector getNorm e else assertEquals refEigenVectors subtract decomposition getEigenvector getNorm e,1
0,Math,wrong result eigen decomposition,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version 2 0 public void testMathpbx02 double mainTridiagonal 7484 860960227216 18405 28129035345 13855 225609560746 10016 708722343366 559 8117399576674 6750 190788301587 71 21428769782159 double secondaryTridiagonal 4175 088570476366 1975 7955858241994 5193 178422374075 1995 286659169179 75 34535882933804 234 0808002076056 reference values computed using routine DSTEMR fortran library LAPACK version 3 2 1 double refEigenValues 20654 744890306974412 16828 208208485466457 6893 155912634994820 6757 083016675340332 5887 799885688558788 64 309089923240379 57 992628792736340 RealVector refEigenVectors new ArrayRealVector new double 0 270356342026904 0 852811091326997 0 399639490702077 0 198794657813990 0 019739323307666 0 000106983022327 0 000001216636321 new ArrayRealVector new double 0 179995273578326 0 402807848153042 0 701870993525734 0 555058211014888 0 068079148898236 0 000509139115227 0 000007112235617 new ArrayRealVector new double 0 399582721284727 0 056629954519333 0 514406488522827 0 711168164518580 0 225548081276367 0 125943999652923 0 004321507456014 new ArrayRealVector new double 0 058515721572821 0 010200130057739 0 063516274916536 0 090696087449378 0 017148420432597 0 991318870265707 0 034707338554096 new ArrayRealVector new double 0 855205995537564 0 327134656629775 0 265382397060548 0 282690729026706 0 105736068025572 0 009138126622039 0 000367751821196 new ArrayRealVector new double 0 002913069901144 0 005177515777101 0 041906334478672 0 109315918416258 0 436192305456741 0 026307315639535 0 891797507436344 new ArrayRealVector new double 0 005738311176435 0 010207611670378 0 082662420517928 0 215733886094368 0 861606487840411 0 025478530652759 0 451080697503958 following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int 0 refEigenValues length assertEquals refEigenValues eigenValues 1 0e 3 refEigenVectors dotProduct decomposition getEigenvector 0 assertEquals 0 refEigenVectors add decomposition getEigenvector getNorm 1 0e 5 else assertEquals 0 refEigenVectors subtract decomposition getEigenvector getNorm 1 0e 5,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version   public void testMathpbx double mainTridiagonal               double secondaryTridiagonal             reference values computed using routine DSTEMR fortran library LAPACK version    double refEigenValues               RealVector refEigenVectors new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               new ArrayRealVector new double               following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int  refEigenValues length assertEquals refEigenValues eigenValues  e  refEigenVectors dotProduct decomposition getEigenvector  assertEquals  refEigenVectors add decomposition getEigenvector getNorm  e  else assertEquals  refEigenVectors subtract decomposition getEigenvector getNorm  e ,results computed EigenDecompositionImpl wrong following case computed Fortran Lapack fails version public void testMathpbx double mainTridiagonal double secondaryTridiagonal reference values computed using routine DSTEMR fortran library LAPACK version double refEigenValues RealVector refEigenVectors new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double new ArrayRealVector new double following line triggers exception EigenDecomposition decomposition new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN double eigenValues decomposition getRealEigenvalues int refEigenValues length assertEquals refEigenValues eigenValues e refEigenVectors dotProduct decomposition getEigenvector assertEquals refEigenVectors add decomposition getEigenvector getNorm e else assertEquals refEigenVectors subtract decomposition getEigenvector getNorm e,1
0,Math,Complex Add Subtract handle NaN arguments differently javadoc contracts,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back 1 1,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back  ,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back,1
0,Math,Complex Add Subtract handle NaN arguments differently javadoc contracts,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back 1 1,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back  ,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back,1
0,Math,bug inverseCumulativeProbability Normal Distribution,version Revision 617953 Date 2008 02 02 22 54 00 0700 Sat 02 Feb 2008 public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision 506600 Date 2007 02 12 12 35 59 0700 Mon 12 Feb 2007 public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution 0 1 double result normal inverseCumulativeProbability 0 9772498680518209 gives exception return approx 2 0000 normal inverseCumulativeProbability 0 977249868051820 works fine also give errors 0 9986501019683698 return 3 0000 0 9999683287581673 return 4 0000 org apache commons math MathException Number iterations 1 maximum iterations 2 147 483 647 initial 1 lower bound 0 upper bound 179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final value 0 final b value 2 f 0 477 f b 0 org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java 103 org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java 145,version Revision  Date        Sat  Feb  public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision  Date        Mon  Feb  public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution   double result normal inverseCumulativeProbability   gives exception return approx   normal inverseCumulativeProbability   works fine also give errors   return     return   org apache commons math MathException Number iterations  maximum iterations     initial  lower bound  upper bound                                                                                                        final value  final b value  f   f b  org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java  org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java ,version Revision Date Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision Date Mon Feb public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution double result normal inverseCumulativeProbability gives exception return approx normal inverseCumulativeProbability works fine also give errors return return org apache commons math MathException Number iterations maximum iterations initial lower bound upper bound final value final b value f f b org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java,1
0,Math,SimplexSolver working expected 2,SimplexSolver find optimal solution Program Lpsolve Objective function max 7 3 b Constraints R1 3 5 c 0 R2 2 5 0 R3 2 b 5 c 0 R4 3 b 5 0 R5 3 2 b 5 R6 2 3 b 5 Variable bounds 1 b 1 Results correct 1 b 1 value 10 Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double 7 3 0 0 0 Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double 1 0 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 0 1 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 3 0 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 2 0 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 2 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 3 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 3 2 0 0 Relationship LEQ 5 podmienky add new LinearConstraint new double 2 3 0 0 Relationship LEQ 5 SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect 1 b 0 5 value 8 5 P used latest software repository including MATH 286 fix,SimplexSolver find optimal solution Program Lpsolve Objective function max   b Constraints R   c  R    R  b  c  R  b   R   b  R   b  Variable bounds  b  Results correct  b  value  Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double      Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect  b   value   P used latest software repository including MATH  fix,SimplexSolver find optimal solution Program Lpsolve Objective function max b Constraints R c R R b c R b R b R b Variable bounds b Results correct b value Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect b value P used latest software repository including MATH fix,1
0,Math,Complex ZERO reciprocal returns NaN return INF,Complex ZERO reciprocal returns NaN return INF Class org apache commons math3 complex Complex Method reciprocal version Id Complex java 1416643 2012 12 03 19 37 14Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java       Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java Z tn,1
0,Math,Complex ZERO reciprocal returns NaN return INF,Complex ZERO reciprocal returns NaN return INF Class org apache commons math3 complex Complex Method reciprocal version Id Complex java 1416643 2012 12 03 19 37 14Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java       Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java Z tn,1
0,Math,Complex ZERO reciprocal returns NaN return INF,Complex ZERO reciprocal returns NaN return INF Class org apache commons math3 complex Complex Method reciprocal version Id Complex java 1416643 2012 12 03 19 37 14Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java       Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java Z tn,1
0,Lang,BooleanUtils toBoolean invalid drop thru case statement causes StringIndexOutOfBoundsException,method BooleanUtils toBoolean case statement case 3 drops case 4 cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case 3 return false Patch follow source unit test,method BooleanUtils toBoolean case statement case  drops case  cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case  return false Patch follow source unit test,method BooleanUtils toBoolean case statement case drops case cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case return false Patch follow source unit test,1
0,Lang,BooleanUtils toBoolean invalid drop thru case statement causes StringIndexOutOfBoundsException,method BooleanUtils toBoolean case statement case 3 drops case 4 cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case 3 return false Patch follow source unit test,method BooleanUtils toBoolean case statement case  drops case  cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case  return false Patch follow source unit test,method BooleanUtils toBoolean case statement case drops case cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case return false Patch follow source unit test,1
0,Lang,BooleanUtils toBoolean invalid drop thru case statement causes StringIndexOutOfBoundsException,method BooleanUtils toBoolean case statement case 3 drops case 4 cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case 3 return false Patch follow source unit test,method BooleanUtils toBoolean case statement case  drops case  cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case  return false Patch follow source unit test,method BooleanUtils toBoolean case statement case drops case cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case return false Patch follow source unit test,1
0,Lang,BooleanUtils toBoolean invalid drop thru case statement causes StringIndexOutOfBoundsException,method BooleanUtils toBoolean case statement case 3 drops case 4 cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case 3 return false Patch follow source unit test,method BooleanUtils toBoolean case statement case  drops case  cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case  return false Patch follow source unit test,method BooleanUtils toBoolean case statement case drops case cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case return false Patch follow source unit test,1
0,Lang,BooleanUtils toBoolean invalid drop thru case statement causes StringIndexOutOfBoundsException,method BooleanUtils toBoolean case statement case 3 drops case 4 cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case 3 return false Patch follow source unit test,method BooleanUtils toBoolean case statement case  drops case  cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case  return false Patch follow source unit test,method BooleanUtils toBoolean case statement case drops case cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case return false Patch follow source unit test,1
0,Lang,ClassUtils toClass Object throws NPE null array element,see summary,see summary,see summary,1
0,Lang,ClassUtils toClass Object throws NPE null array element,see summary,see summary,see summary,1
0,Lang,WordUtils abbreviate bug lower greater str length,WordUtils abbreviate upper adjusted length string lower lower never adjusted length string lower greater str lengt upper str substring 0 upper throw StringIndexOutOfBoundsException fix adjust lower length string,WordUtils abbreviate upper adjusted length string lower lower never adjusted length string lower greater str lengt upper str substring  upper throw StringIndexOutOfBoundsException fix adjust lower length string,WordUtils abbreviate upper adjusted length string lower lower never adjusted length string lower greater str lengt upper str substring upper throw StringIndexOutOfBoundsException fix adjust lower length string,1
0,Lang,DateFormatUtils format correctly change Calendar TimeZone certain situations,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z commonly constructed cal new GregorianCalendar 2009 9 16 8 42 16 unit test work time zone constructing GMT 8 rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime   T   Z commonly constructed cal new GregorianCalendar       unit test work time zone constructing GMT  rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime   T   Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime Z commonly constructed cal new GregorianCalendar unit test work time zone constructing GMT rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,1
0,Lang,DateFormatUtils format correctly change Calendar TimeZone certain situations,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z commonly constructed cal new GregorianCalendar 2009 9 16 8 42 16 unit test work time zone constructing GMT 8 rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime   T   Z commonly constructed cal new GregorianCalendar       unit test work time zone constructing GMT  rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime   T   Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime Z commonly constructed cal new GregorianCalendar unit test work time zone constructing GMT rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,1
0,Lang,DateFormatUtils format correctly change Calendar TimeZone certain situations,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z commonly constructed cal new GregorianCalendar 2009 9 16 8 42 16 unit test work time zone constructing GMT 8 rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime 2009 10 16T16 42 16 000Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT 8 cal clear cal set 2009 9 16 8 42 16 cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime   T   Z commonly constructed cal new GregorianCalendar       unit test work time zone constructing GMT  rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime   T   Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT  cal clear cal set       cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,Calendar object constructed certain ways call Calendar setTimeZone correctly change Calendars fields Calling Calenar getTime seems fix problem probably bug JDK would nice DateFormatUtils smart enough detect resolve problem example following unit test fails public void testFormat CalendarIsoMsZulu final String dateTime Z commonly constructed cal new GregorianCalendar unit test work time zone constructing GMT rather default locale time zone GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal However unit test passes public void testFormat CalendarIsoMsZulu final String dateTime Z GregorianCalendar cal new GregorianCalendar TimeZone getTimeZone GMT cal clear cal set cal getTime FastDateFormat format FastDateFormat getInstance yyyy MM dd HH mm ss SSS Z TimeZone getTimeZone GMT assertEquals dateTime dateTime format format cal,1
0,Lang,StopWatch suspend acts split followed stop,opinion bug suspend acts split followed stop see StopWatch sw new StopWatch sw start Thread sleep 1000 sw suspend Time 1 ok System println sw getTime Thread sleep 2000 Time 1 ok System println sw getTime sw resume Thread sleep 3000 sw suspend Time 2 ok System println sw getTime Thread sleep 4000 Time 2 ok System println sw getTime Thread sleep 5000 sw stop Time 2 Time 3 ok System println sw getTime suspend resume like pause time counter continue following stop call increase time counter,opinion bug suspend acts split followed stop see StopWatch sw new StopWatch sw start Thread sleep  sw suspend Time  ok System println sw getTime Thread sleep  Time  ok System println sw getTime sw resume Thread sleep  sw suspend Time  ok System println sw getTime Thread sleep  Time  ok System println sw getTime Thread sleep  sw stop Time  Time  ok System println sw getTime suspend resume like pause time counter continue following stop call increase time counter,opinion bug suspend acts split followed stop see StopWatch sw new StopWatch sw start Thread sleep sw suspend Time ok System println sw getTime Thread sleep Time ok System println sw getTime sw resume Thread sleep sw suspend Time ok System println sw getTime Thread sleep Time ok System println sw getTime Thread sleep sw stop Time Time ok System println sw getTime suspend resume like pause time counter continue following stop call increase time counter,1
0,Closure,Identifier minus negative number needs space,None,None,None,1
0,Closure,ClassCastException TypeCheck pass,None,None,None,1
0,Closure,Erroneous optimization ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,combining interface multiple extends crash compiler,None,None,None,1
0,Math,FastMath max 50 0f 50 0f 50 0f 50 0f,FastMath max 50 0f 50 0f 50 0f 50 0f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,FastMath max  f  f  f  f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,FastMath max f f f f wrong variable returned bug detected test case testMinMaxFloat bug tests doubles floats,1
0,Math,NPE calling SubLine intersection non intersecting lines,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,1
0,Closure,Column indicating caret sometimes error output,None,None,None,1
0,Closure,Erroneous optimization ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,combining interface multiple extends crash compiler,None,None,None,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path1 GeneralPath path2 thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,1
0,Math,NPE calling SubLine intersection non intersecting lines,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,1
0,Math,Fix deprecate isSupportXxxInclusive RealDistribution interface,conclusion 1 never implemented deprecate properties RealDistribution interface since removal wait 4 0 agree precise definition fix code match mean time definition propose isSupportXxxInclusive means density function applied upper lower bound support returned getSupportXxxBound finite e infinite NaN value returned 1 http markmail org message dxuxh7eybl7xejde,conclusion  never implemented deprecate properties RealDistribution interface since removal wait   agree precise definition fix code match mean time definition propose isSupportXxxInclusive means density function applied upper lower bound support returned getSupportXxxBound finite e infinite NaN value returned  http markmail org message dxuxheyblxejde,conclusion never implemented deprecate properties RealDistribution interface since removal wait agree precise definition fix code match mean time definition propose isSupportXxxInclusive means density function applied upper lower bound support returned getSupportXxxBound finite e infinite NaN value returned http markmail org message dxuxheyblxejde,1
0,Lang,StrBuilder contains usages thisBuf length use size,fixing LANG 294 noticed two places StrBuilder reference thisBuf length unless mistaken,fixing LANG  noticed two places StrBuilder reference thisBuf length unless mistaken,fixing LANG noticed two places StrBuilder reference thisBuf length unless mistaken,1
0,Lang,DateUtils isSameLocalTime work correct,Hi think found bug DateUtils class method isSameLocalTime Example Calendar Calendar getInstance setTimeInMillis 1297364400000L Calendar b Calendar getInstance b setTimeInMillis 1297321200000L Assert assertFalse DateUtils isSameLocalTime b method compares cal1 get Calendar HOUR cal2 get Calendar HOUR think cal1 get Calendar HOUR DAY cal2 get Calendar HOUR DAY,Hi think found bug DateUtils class method isSameLocalTime Example Calendar Calendar getInstance setTimeInMillis L Calendar b Calendar getInstance b setTimeInMillis L Assert assertFalse DateUtils isSameLocalTime b method compares cal get Calendar HOUR cal get Calendar HOUR think cal get Calendar HOUR DAY cal get Calendar HOUR DAY,Hi think found bug DateUtils class method isSameLocalTime Example Calendar Calendar getInstance setTimeInMillis L Calendar b Calendar getInstance b setTimeInMillis L Assert assertFalse DateUtils isSameLocalTime b method compares cal get Calendar HOUR cal get Calendar HOUR think cal get Calendar HOUR DAY cal get Calendar HOUR DAY,1
0,Lang,StrBuilder appendFixedWidth handle nulls,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,1
0,Mockito,Return deep stubs generic method returns generic type,try mock generic method generic returntype returntype derived generic type method using deep stubs get ClassCastException calling use deep stubs raw Supplier mock pass around works,try mock generic method generic returntype returntype derived generic type method using deep stubs get ClassCastException calling use deep stubs raw Supplier mock pass around works,try mock generic method generic returntype returntype derived generic type method using deep stubs get ClassCastException calling use deep stubs raw Supplier mock pass around works,1
0,Closure,Codepoint U 007f appears raw output,None,None,None,1
0,Closure,Codepoint U 007f appears raw output,None,None,None,1
0,Chart,Potential NPE AbstractCategoryItemRender getLegendItems,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,1
0,Math,stat Frequency getPct Object uses getCumPct Comparable instead getPct Comparable,Drop Replacement 1 2 2 0 possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable 2 0 Deprecated public double getPct Object v return getCumPct Comparable v,Drop Replacement     possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable   Deprecated public double getPct Object v return getCumPct Comparable v,Drop Replacement possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable Deprecated public double getPct Object v return getCumPct Comparable v,1
0,Math,Mann Whitney U Test Suffers Integer Overflow Large Data Sets,performing Mann Whitney U Test large data sets attached test uses two 1500 element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,performing Mann Whitney U Test large data sets attached test uses two  element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,performing Mann Whitney U Test large data sets attached test uses two element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,1
0,Math,SimplexSolver working expected 2,SimplexSolver find optimal solution Program Lpsolve Objective function max 7 3 b Constraints R1 3 5 c 0 R2 2 5 0 R3 2 b 5 c 0 R4 3 b 5 0 R5 3 2 b 5 R6 2 3 b 5 Variable bounds 1 b 1 Results correct 1 b 1 value 10 Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double 7 3 0 0 0 Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double 1 0 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 0 1 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 3 0 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 2 0 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 2 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 3 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 3 2 0 0 Relationship LEQ 5 podmienky add new LinearConstraint new double 2 3 0 0 Relationship LEQ 5 SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect 1 b 0 5 value 8 5 P used latest software repository including MATH 286 fix,SimplexSolver find optimal solution Program Lpsolve Objective function max   b Constraints R   c  R    R  b  c  R  b   R   b  R   b  Variable bounds  b  Results correct  b  value  Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double      Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect  b   value   P used latest software repository including MATH  fix,SimplexSolver find optimal solution Program Lpsolve Objective function max b Constraints R c R R b c R b R b R b Variable bounds b Results correct b value Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect b value P used latest software repository including MATH fix,1
0,Math,SimplexSolver working expected 2,SimplexSolver find optimal solution Program Lpsolve Objective function max 7 3 b Constraints R1 3 5 c 0 R2 2 5 0 R3 2 b 5 c 0 R4 3 b 5 0 R5 3 2 b 5 R6 2 3 b 5 Variable bounds 1 b 1 Results correct 1 b 1 value 10 Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double 7 3 0 0 0 Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double 1 0 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 0 1 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 3 0 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 2 0 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 2 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 3 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 3 2 0 0 Relationship LEQ 5 podmienky add new LinearConstraint new double 2 3 0 0 Relationship LEQ 5 SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect 1 b 0 5 value 8 5 P used latest software repository including MATH 286 fix,SimplexSolver find optimal solution Program Lpsolve Objective function max   b Constraints R   c  R    R  b  c  R  b   R   b  R   b  Variable bounds  b  Results correct  b  value  Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double      Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect  b   value   P used latest software repository including MATH  fix,SimplexSolver find optimal solution Program Lpsolve Objective function max b Constraints R c R R b c R b R b R b Variable bounds b Results correct b value Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect b value P used latest software repository including MATH fix,1
0,Math,Complex ZERO reciprocal returns NaN return INF,Complex ZERO reciprocal returns NaN return INF Class org apache commons math3 complex Complex Method reciprocal version Id Complex java 1416643 2012 12 03 19 37 14Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java       Z tn,Complex ZERO reciprocal returns NaN return INF Class org apache commons math complex Complex Method reciprocal version Id Complex java Z tn,1
0,Lang,StringIndexOutOfBoundsException CharSequenceTranslator,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uD83D\uDE30 surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uD83D\uDE30 StringEscapeUtils escapeCsv \uD83D\uDE30 get exception shown java lang StringIndexOutOfBoundsException String index range 2 java lang String charAt String java 658 java lang Character codePointAt Character java 4668 org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java 95 org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java 59 org apache commons lang3 StringEscapeUtils escapeCsv StringEscapeUtils java 556 Patch attached method affected public final void translate CharSequence input Writer throws IOException,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uDD\uDE surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE get exception shown java lang StringIndexOutOfBoundsException String index range  java lang String charAt String java  java lang Character codePointAt Character java  org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java  org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java  org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java  Patch attached method affected public final void translate CharSequence input Writer throws IOException,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uDD\uDE surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE get exception shown java lang StringIndexOutOfBoundsException String index range java lang String charAt String java java lang Character codePointAt Character java org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java Patch attached method affected public final void translate CharSequence input Writer throws IOException,1
0,Chart,Fix MultiplePiePlot,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,dataset passed constructor MultiplePiePlot dataset wired listener would setDataset called,1
0,Chart,XYSeries addOrUpdate add duplicates allowed,found bug jfreechart 1 0 9 code org jfree data xy XYSeries change time ago introduced notion allowing duplicate X values XYSeries data method addOrUpdate Number x Number never modified support therefore duplicate data overwriting existing data,found bug jfreechart    code org jfree data xy XYSeries change time ago introduced notion allowing duplicate X values XYSeries data method addOrUpdate Number x Number never modified support therefore duplicate data overwriting existing data,found bug jfreechart code org jfree data xy XYSeries change time ago introduced notion allowing duplicate X values XYSeries data method addOrUpdate Number x Number never modified support therefore duplicate data overwriting existing data,1
0,Math,GaussianFitter Unexpectedly Throws NotStrictlyPositiveException,Running following double observations 1 1143831578403364E 29 4 95281403484594E 28 1 1171347211930288E 26 1 7044813962636277E 25 1 9784716574832164E 24 1 8630236407866774E 23 1 4820532905097742E 22 1 0241963854632831E 21 6 275077366673128E 21 3 461808994532493E 20 1 7407124684715706E 19 8 056687953553974E 19 3 460193945992071E 18 1 3883326374011525E 17 5 233894983671116E 17 1 8630791465263745E 16 6 288759227922111E 16 2 0204433920597856E 15 6 198768938576155E 15 1 821419346860626E 14 5 139176445538471E 14 1 3956427429045787E 13 3 655705706448139E 13 9 253753324779779E 13 2 267636001476696E 12 5 3880460095836855E 12 1 2431632654852931E 11 GaussianFitter g new GaussianFitter new LevenbergMarquardtOptimizer int index 0 index 27 index g addObservedPoint index observations index g fit Results org apache commons math exception NotStrictlyPositiveException 1 277 smaller equal minimum 0 org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java 184 org apache commons math analysis function Gaussian Parametric value Gaussian java 129 guessing initial guess sigma,Running following double observations  E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E   E  GaussianFitter g new GaussianFitter new LevenbergMarquardtOptimizer int index  index  index g addObservedPoint index observations index g fit Results org apache commons math exception NotStrictlyPositiveException   smaller equal minimum  org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java  org apache commons math analysis function Gaussian Parametric value Gaussian java  guessing initial guess sigma,Running following double observations E E E E E E E E E E E E E E E E E E E E E E E E E E E GaussianFitter g new GaussianFitter new LevenbergMarquardtOptimizer int index index index g addObservedPoint index observations index g fit Results org apache commons math exception NotStrictlyPositiveException smaller equal minimum org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java org apache commons math analysis function Gaussian Parametric value Gaussian java guessing initial guess sigma,1
0,Math,Brent solver throw IllegalArgumentException initial guess wrong sign,Javadoc public double solve final UnivariateRealFunction f final double min final double max final double initial claims values function three points sign IllegalArgumentException thrown case even checked,Javadoc public double solve final UnivariateRealFunction f final double min final double max final double initial claims values function three points sign IllegalArgumentException thrown case even checked,Javadoc public double solve final UnivariateRealFunction f final double min final double max final double initial claims values function three points sign IllegalArgumentException thrown case even checked,1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line 640 RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line  RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line RealMatrixImpl java read double new double nRows instead double new double v length,1
0,Math,Complex Add Subtract handle NaN arguments differently javadoc contracts,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back 1 1,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back  ,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back,1
0,Math,large first step embedded Runge Kutta integrators Dormand Prince 8 5 3,Adaptive step size integrators compute first step size provided embedded Runge Kutta type step size checked integration range integration range extremely short step size may evaluate function range fact tries afterward go back fails stop Gragg Bulirsch Stoer integrators problem step size checked truncated needed,Adaptive step size integrators compute first step size provided embedded Runge Kutta type step size checked integration range integration range extremely short step size may evaluate function range fact tries afterward go back fails stop Gragg Bulirsch Stoer integrators problem step size checked truncated needed,Adaptive step size integrators compute first step size provided embedded Runge Kutta type step size checked integration range integration range extremely short step size may evaluate function range fact tries afterward go back fails stop Gragg Bulirsch Stoer integrators problem step size checked truncated needed,1
0,Time,possibly bug org joda time field FieldUtils safeMultiply,seems currently written joda time 2 1 jar org joda time field FieldUtils safeMultiply long val1 int scalar detect overflow long val1 Long MIN VALUE int scalar 1 attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,seems currently written joda time   jar org joda time field FieldUtils safeMultiply long val int scalar detect overflow long val Long MIN VALUE int scalar  attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,seems currently written joda time jar org joda time field FieldUtils safeMultiply long val int scalar detect overflow long val Long MIN VALUE int scalar attached file demonstrates think bug suggests patch looked Joda Time bugs list SourceForge see anything looked relevant,1
0,Lang,ArrayUtils add array element create unexpected ClassCastException,ArrayUtils add array element create unexpected ClassCastException example following code compiles without warning String sa ArrayUtils add stringArray aString works fine provided least one parameters non null However parameters null add method returns Object array hence Exception parameters null possible determine correct array type return seems disallowed think method ought changed throw IllegalParameterException parameters null,ArrayUtils add array element create unexpected ClassCastException example following code compiles without warning String sa ArrayUtils add stringArray aString works fine provided least one parameters non null However parameters null add method returns Object array hence Exception parameters null possible determine correct array type return seems disallowed think method ought changed throw IllegalParameterException parameters null,ArrayUtils add array element create unexpected ClassCastException example following code compiles without warning String sa ArrayUtils add stringArray aString works fine provided least one parameters non null However parameters null add method returns Object array hence Exception parameters null possible determine correct array type return seems disallowed think method ought changed throw IllegalParameterException parameters null,1
0,Lang,StringUtils join throws NPE toString returns null one objects collection,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,1
0,Lang,WordUtils abbreviate bug lower greater str length,WordUtils abbreviate upper adjusted length string lower lower never adjusted length string lower greater str lengt upper str substring 0 upper throw StringIndexOutOfBoundsException fix adjust lower length string,WordUtils abbreviate upper adjusted length string lower lower never adjusted length string lower greater str lengt upper str substring  upper throw StringIndexOutOfBoundsException fix adjust lower length string,WordUtils abbreviate upper adjusted length string lower lower never adjusted length string lower greater str lengt upper str substring upper throw StringIndexOutOfBoundsException fix adjust lower length string,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Math,Need range checks elitismRate ElitisticListPopulation constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,1
0,Math,Brent solver throw IllegalArgumentException initial guess wrong sign,Javadoc public double solve final UnivariateRealFunction f final double min final double max final double initial claims values function three points sign IllegalArgumentException thrown case even checked,Javadoc public double solve final UnivariateRealFunction f final double min final double max final double initial claims values function three points sign IllegalArgumentException thrown case even checked,Javadoc public double solve final UnivariateRealFunction f final double min final double max final double initial claims values function three points sign IllegalArgumentException thrown case even checked,1
0,Lang,NumberUtils createNumber throws NumberFormatException one digit long,NumberUtils createNumber throws NumberFormatException parsing 1l 2l etc works fine try parse 01l 02l condition isDigits numeric substring 1 line 455 return false numeric substring 1 empty string 1l,NumberUtils createNumber throws NumberFormatException parsing l l etc works fine try parse l l condition isDigits numeric substring  line  return false numeric substring  empty string l,NumberUtils createNumber throws NumberFormatException parsing l l etc works fine try parse l l condition isDigits numeric substring line return false numeric substring empty string l,1
0,Lang,NumberUtils createNumber thows StringIndexOutOfBoundsException l passed,Seems similar LANG 300 except place digit front l L throws StringIndexOutOfBoundsException instead,Seems similar LANG  except place digit front l L throws StringIndexOutOfBoundsException instead,Seems similar LANG except place digit front l L throws StringIndexOutOfBoundsException instead,1
0,Lang,StopWatch suspend acts split followed stop,opinion bug suspend acts split followed stop see StopWatch sw new StopWatch sw start Thread sleep 1000 sw suspend Time 1 ok System println sw getTime Thread sleep 2000 Time 1 ok System println sw getTime sw resume Thread sleep 3000 sw suspend Time 2 ok System println sw getTime Thread sleep 4000 Time 2 ok System println sw getTime Thread sleep 5000 sw stop Time 2 Time 3 ok System println sw getTime suspend resume like pause time counter continue following stop call increase time counter,opinion bug suspend acts split followed stop see StopWatch sw new StopWatch sw start Thread sleep  sw suspend Time  ok System println sw getTime Thread sleep  Time  ok System println sw getTime sw resume Thread sleep  sw suspend Time  ok System println sw getTime Thread sleep  Time  ok System println sw getTime Thread sleep  sw stop Time  Time  ok System println sw getTime suspend resume like pause time counter continue following stop call increase time counter,opinion bug suspend acts split followed stop see StopWatch sw new StopWatch sw start Thread sleep sw suspend Time ok System println sw getTime Thread sleep Time ok System println sw getTime sw resume Thread sleep sw suspend Time ok System println sw getTime Thread sleep Time ok System println sw getTime Thread sleep sw stop Time Time ok System println sw getTime suspend resume like pause time counter continue following stop call increase time counter,1
0,Lang,NumberUtils isNumber String right String 1 1L,1 1L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint, L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint,L Java Number NumberUtils isNumber String return true perhaps change chars l || chars L allowing L exponent return foundDigit hasExp chars l || chars L allowing L exponent return foundDigit hasExp hasDecPoint,1
0,Closure,Codepoint U 007f appears raw output,None,None,None,1
0,Closure,Identifier minus negative number needs space,None,None,None,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path1 GeneralPath path2 thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,comparison two GeneralPath objects uses PathIterator objects equal GeneralPath path GeneralPath path thus return true pair non null GeneralPath instances windingRule,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze gives bad results commons math3 3 0 simple test problem works well commons math 2 2,Methode SimplexSolver optimeze gives bad results commons math   simple test problem works well commons math  ,Methode SimplexSolver optimeze gives bad results commons math simple test problem works well commons math,1
0,Math,stat Frequency getPct Object uses getCumPct Comparable instead getPct Comparable,Drop Replacement 1 2 2 0 possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable 2 0 Deprecated public double getPct Object v return getCumPct Comparable v,Drop Replacement     possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable   Deprecated public double getPct Object v return getCumPct Comparable v,Drop Replacement possible getPct calls cummulative without code change Frequency java Returns percentage values equal v deprecated replaced link getPct Comparable Deprecated public double getPct Object v return getCumPct Comparable v,1
0,Math,Mann Whitney U Test Suffers Integer Overflow Large Data Sets,performing Mann Whitney U Test large data sets attached test uses two 1500 element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,performing Mann Whitney U Test large data sets attached test uses two  element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,performing Mann Whitney U Test large data sets attached test uses two element sets intermediate integer values used calculateAsymptoticPValue overflow leading invalid results p values NaN incorrect calculations Attached patch including test fix modifies affected code use doubles,1
0,Math,BisectionSolver solve final UnivariateRealFunction f double min double max double initial throws NullPointerException,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl 0 0 1 0 0 5 NullPointerException thrown,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl       NullPointerException thrown,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max throws NullPointerException member variable UnivariateRealSolverImpl f null Instead method BisectionSolver solve final UnivariateRealFunction f double min double max called Steps reproduce invoke new BisectionSolver solve someUnivariateFunctionImpl NullPointerException thrown,1
0,Time,Inconsistent interpretation ambiguous time DST,inconsistency appears timezone Europe London three DateTime objects represent moment time even ambiguous always returns earlier instant summer time overlap,inconsistency appears timezone Europe London three DateTime objects represent moment time even ambiguous always returns earlier instant summer time overlap,inconsistency appears timezone Europe London three DateTime objects represent moment time even ambiguous always returns earlier instant summer time overlap,1
0,Lang,BooleanUtils toBoolean invalid drop thru case statement causes StringIndexOutOfBoundsException,method BooleanUtils toBoolean case statement case 3 drops case 4 cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case 3 return false Patch follow source unit test,method BooleanUtils toBoolean case statement case  drops case  cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case  return false Patch follow source unit test,method BooleanUtils toBoolean case statement case drops case cause StringIndexOutOfBoundsException example test assertEquals false BooleanUtils toBoolean tru end case return false Patch follow source unit test,1
0,Lang,StringIndexOutOfBoundsException CharSequenceTranslator,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uD83D\uDE30 surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uD83D\uDE30 StringEscapeUtils escapeCsv \uD83D\uDE30 get exception shown java lang StringIndexOutOfBoundsException String index range 2 java lang String charAt String java 658 java lang Character codePointAt Character java 4668 org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java 95 org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java 59 org apache commons lang3 StringEscapeUtils escapeCsv StringEscapeUtils java 556 Patch attached method affected public final void translate CharSequence input Writer throws IOException,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uDD\uDE surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE get exception shown java lang StringIndexOutOfBoundsException String index range  java lang String charAt String java  java lang Character codePointAt Character java  org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java  org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java  org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java  Patch attached method affected public final void translate CharSequence input Writer throws IOException,found bad surrogate pair handling CharSequenceTranslator simple test case problem \uDD\uDE surrogate pair Test public void testEscapeSurrogatePairs throws Exception assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE get exception shown java lang StringIndexOutOfBoundsException String index range java lang String charAt String java java lang Character codePointAt Character java org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java Patch attached method affected public final void translate CharSequence input Writer throws IOException,1
0,Closure,Classify non rightmost expressions problematic,None,None,None,1
0,Closure,Break finally block optimized properly,None,None,None,1
0,Closure,Classify non rightmost expressions problematic,None,None,None,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Lang,NumberUtils createNumber bad behaviour leading,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,NumberUtils createNumber checks leading string returns null found documented work round bug BigDecimal Returning nulll contrary Javadoc behaviour methods would throw NumberFormatException clear whether BigDecimal problem still exists recent versions Java However exist check needs done invocations BigDecimal e needs moved createBigDecimal,1
0,Lang,FastDateParser handle white space properly,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,SimpleDateFormat Javadoc treat white space specially however FastDateParser treats single white space number white space characters means FDP parse dates fail parsed SDP,1
0,Closure,compiler crashes goog provide used non string,None,None,None,1
0,Closure,Erroneous optimization ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Math,RegulaFalsiSolver failure,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 fails illegal state maximal count 100 exceeded evaluations Using PegasusSolver answer found 17 evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   fails illegal state maximal count  exceeded evaluations Using PegasusSolver answer found  evaluations,following unit test Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f fails illegal state maximal count exceeded evaluations Using PegasusSolver answer found evaluations,1
0,Math,Need range checks elitismRate ElitisticListPopulation constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,range check setting elitismRate via ElitisticListPopulation setElitismRate method via constructors,1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line 640 RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line  RealMatrixImpl java read double new double nRows instead double new double v length,org apache commons math linear RealMatrixImpl operate tries create result vector always length input vector result runtime exceptions matrix non square always yields incorrect results matrix non square correct behaviour would course create vector length row dimension matrix Thus line RealMatrixImpl java read double new double nRows instead double new double v length,1
0,Math,Complex Add Subtract handle NaN arguments differently javadoc contracts,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back 1 1,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back  ,Complex add subtract javadoc states either code rhs code NaN value either part link NaN returned otherwise Inifinite NaN values returned parts result according rules link java lang Double arithmetic Subtract includes isNaN test returns Complex NaN either complex argument isNaN add omits test test added add implementation actually restored since looks like code merge problem going back,1
0,Math,NaN equals methods,MathUtils equals methods return true argument NaN Unless mistaken contradicts IEEE standard nobody objects going make changes,MathUtils equals methods return true argument NaN Unless mistaken contradicts IEEE standard nobody objects going make changes,MathUtils equals methods return true argument NaN Unless mistaken contradicts IEEE standard nobody objects going make changes,1
0,Math,NPE KMeansPlusPlusClusterer unittest,running unittest facing NPE java lang NullPointerException org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java 91 unittest package org fao fisheries chronicles calcuation cluster import static org junit Assert assertEquals import static org junit Assert assertTrue import java util Arrays import java util List import java util Random import org apache commons math stat clustering Cluster import org apache commons math stat clustering EuclideanIntegerPoint import org apache commons math stat clustering KMeansPlusPlusClusterer import org fao fisheries chronicles input CsvImportProcess import org fao fisheries chronicles input Top200Csv import org junit Test public class ClusterAnalysisTest Test public void testPerformClusterAnalysis2 KMeansPlusPlusClusterer EuclideanIntegerPoint transformer new KMeansPlusPlusClusterer EuclideanIntegerPoint new Random 1746432956321l EuclideanIntegerPoint points new EuclideanIntegerPoint new EuclideanIntegerPoint new int 1959 325100 new EuclideanIntegerPoint new int 1960 373200 List Cluster EuclideanIntegerPoint clusters transformer cluster Arrays asList points 1 1 assertEquals 1 clusters size,running unittest facing NPE java lang NullPointerException org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java  unittest package org fao fisheries chronicles calcuation cluster import static org junit Assert assertEquals import static org junit Assert assertTrue import java util Arrays import java util List import java util Random import org apache commons math stat clustering Cluster import org apache commons math stat clustering EuclideanIntegerPoint import org apache commons math stat clustering KMeansPlusPlusClusterer import org fao fisheries chronicles input CsvImportProcess import org fao fisheries chronicles input TopCsv import org junit Test public class ClusterAnalysisTest Test public void testPerformClusterAnalysis KMeansPlusPlusClusterer EuclideanIntegerPoint transformer new KMeansPlusPlusClusterer EuclideanIntegerPoint new Random l EuclideanIntegerPoint points new EuclideanIntegerPoint new EuclideanIntegerPoint new int   new EuclideanIntegerPoint new int   List Cluster EuclideanIntegerPoint clusters transformer cluster Arrays asList points   assertEquals  clusters size,running unittest facing NPE java lang NullPointerException org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java unittest package org fao fisheries chronicles calcuation cluster import static org junit Assert assertEquals import static org junit Assert assertTrue import java util Arrays import java util List import java util Random import org apache commons math stat clustering Cluster import org apache commons math stat clustering EuclideanIntegerPoint import org apache commons math stat clustering KMeansPlusPlusClusterer import org fao fisheries chronicles input CsvImportProcess import org fao fisheries chronicles input TopCsv import org junit Test public class ClusterAnalysisTest Test public void testPerformClusterAnalysis KMeansPlusPlusClusterer EuclideanIntegerPoint transformer new KMeansPlusPlusClusterer EuclideanIntegerPoint new Random l EuclideanIntegerPoint points new EuclideanIntegerPoint new EuclideanIntegerPoint new int new EuclideanIntegerPoint new int List Cluster EuclideanIntegerPoint clusters transformer cluster Arrays asList points assertEquals clusters size,1
0,Math,One Variance evaluate methods work correctly,method org apache commons math stat descriptive moment Variance evaluate double values double weights double mean int begin int length work properly Looks loke ignores length parameter grabs whole dataset Similar method Mean class seems work check methods taking part array may problem Workaround shrink arrays use method without length,method org apache commons math stat descriptive moment Variance evaluate double values double weights double mean int begin int length work properly Looks loke ignores length parameter grabs whole dataset Similar method Mean class seems work check methods taking part array may problem Workaround shrink arrays use method without length,method org apache commons math stat descriptive moment Variance evaluate double values double weights double mean int begin int length work properly Looks loke ignores length parameter grabs whole dataset Similar method Mean class seems work check methods taking part array may problem Workaround shrink arrays use method without length,1
0,Math,ODE integrator goes past specified end integration range,End integration range ODE solving handled event cases numerical accuracy events detection leads error events location following test case shows end event handled properly integration cover 60s range fact covers 160s range twice specified range public void testMissedEvent throws IntegratorException DerivativeException final double t0 1878250320 0000029 final double 1878250379 9999986 FirstOrderDifferentialEquations ode new FirstOrderDifferentialEquations public int getDimension return 1 public void computeDerivatives double double double yDot throws DerivativeException yDot 0 0 1 0e 6 DormandPrince853Integrator integrator new DormandPrince853Integrator 0 0 100 0 1 0e 10 1 0e 10 double 1 0 integrator setInitialStepSize 60 0 double finalT integrator integrate ode t0 Assert assertEquals finalT 1 0e 6,End integration range ODE solving handled event cases numerical accuracy events detection leads error events location following test case shows end event handled properly integration cover s range fact covers s range twice specified range public void testMissedEvent throws IntegratorException DerivativeException final double t   final double   FirstOrderDifferentialEquations ode new FirstOrderDifferentialEquations public int getDimension return  public void computeDerivatives double double double yDot throws DerivativeException yDot    e  DormandPrinceIntegrator integrator new DormandPrinceIntegrator      e   e  double   integrator setInitialStepSize   double finalT integrator integrate ode t Assert assertEquals finalT  e ,End integration range ODE solving handled event cases numerical accuracy events detection leads error events location following test case shows end event handled properly integration cover range fact covers range twice specified range public void testMissedEvent throws IntegratorException DerivativeException final double final double FirstOrderDifferentialEquations ode new FirstOrderDifferentialEquations public int getDimension return public void computeDerivatives double double double yDot throws DerivativeException yDot e DormandPrinceIntegrator integrator new DormandPrinceIntegrator e e double integrator setInitialStepSize double finalT integrator integrate ode Assert assertEquals finalT e,1
0,Lang,FastDateFormat getDateInstance getDateTimeInstance assume Locale getDefault change,FastDateFormat getDateInstance getDateTimeInstance methods create HashMap key various items including locale locale null made part key stored object created using current default locale Locale changed subsequently wrong locale applied Patch test case follow,FastDateFormat getDateInstance getDateTimeInstance methods create HashMap key various items including locale locale null made part key stored object created using current default locale Locale changed subsequently wrong locale applied Patch test case follow,FastDateFormat getDateInstance getDateTimeInstance methods create HashMap key various items including locale locale null made part key stored object created using current default locale Locale changed subsequently wrong locale applied Patch test case follow,1
0,Lang,NumberUtils createNumber throws NumberFormatException one digit long,NumberUtils createNumber throws NumberFormatException parsing 1l 2l etc works fine try parse 01l 02l condition isDigits numeric substring 1 line 455 return false numeric substring 1 empty string 1l,NumberUtils createNumber throws NumberFormatException parsing l l etc works fine try parse l l condition isDigits numeric substring  line  return false numeric substring  empty string l,NumberUtils createNumber throws NumberFormatException parsing l l etc works fine try parse l l condition isDigits numeric substring line return false numeric substring empty string l,1
0,Lang,ClassUtils toClass Object throws NPE null array element,see summary,see summary,see summary,1
0,Lang,NumberUtils handle upper case hex 0X 0X,NumberUtils createNumber work equally 0x1234 0X1234 currently 0X1234 generates NumberFormatException Integer decode handles upper lower case hex,NumberUtils createNumber work equally x X currently X generates NumberFormatException Integer decode handles upper lower case hex,NumberUtils createNumber work equally x X currently X generates NumberFormatException Integer decode handles upper lower case hex,1
0,Lang,StringUtils replaceEach Bug Missing Documentation,following Test Case replaceEach fails null pointer exception expected StringUtils methods null friendly use case stuff Values replacementList want check whether null admit use case perfect unclear happens replace outlined three expectations test case course one met decided none possible propose update documentation happens null passed replacement string import static org junit Assert assertEquals import org apache commons lang StringUtils import org junit Test public class StringUtilsTest Test public void replaceEach String original Hello World String searchList Hello World String replacementList Greetings null String result StringUtils replaceEach original searchList replacementList assertEquals Greetings result perhaps ok well assertEquals Greetings World result even assertEquals Greetings null result,following Test Case replaceEach fails null pointer exception expected StringUtils methods null friendly use case stuff Values replacementList want check whether null admit use case perfect unclear happens replace outlined three expectations test case course one met decided none possible propose update documentation happens null passed replacement string import static org junit Assert assertEquals import org apache commons lang StringUtils import org junit Test public class StringUtilsTest Test public void replaceEach String original Hello World String searchList Hello World String replacementList Greetings null String result StringUtils replaceEach original searchList replacementList assertEquals Greetings result perhaps ok well assertEquals Greetings World result even assertEquals Greetings null result,following Test Case replaceEach fails null pointer exception expected StringUtils methods null friendly use case stuff Values replacementList want check whether null admit use case perfect unclear happens replace outlined three expectations test case course one met decided none possible propose update documentation happens null passed replacement string import static org junit Assert assertEquals import org apache commons lang StringUtils import org junit Test public class StringUtilsTest Test public void replaceEach String original Hello World String searchList Hello World String replacementList Greetings null String result StringUtils replaceEach original searchList replacementList assertEquals Greetings result perhaps ok well assertEquals Greetings World result even assertEquals Greetings null result,1
0,Chart,Bug propgated v1 0 5 present,method getRowCount class org jfree data category DefaultIntervalCategoryDataset says Returns number series dataset possibly zero implementation v1 0 5 longer checks null condition would return zero seriesKeys v1 0 4 previous throws Null Pointer seriesKeys never got initialized getRowCount method called,method getRowCount class org jfree data category DefaultIntervalCategoryDataset says Returns number series dataset possibly zero implementation v   longer checks null condition would return zero seriesKeys v   previous throws Null Pointer seriesKeys never got initialized getRowCount method called,method getRowCount class org jfree data category DefaultIntervalCategoryDataset says Returns number series dataset possibly zero implementation v longer checks null condition would return zero seriesKeys v previous throws Null Pointer seriesKeys never got initialized getRowCount method called,1
0,Chart,Bug propgated v1 0 5 present,method getRowCount class org jfree data category DefaultIntervalCategoryDataset says Returns number series dataset possibly zero implementation v1 0 5 longer checks null condition would return zero seriesKeys v1 0 4 previous throws Null Pointer seriesKeys never got initialized getRowCount method called,method getRowCount class org jfree data category DefaultIntervalCategoryDataset says Returns number series dataset possibly zero implementation v   longer checks null condition would return zero seriesKeys v   previous throws Null Pointer seriesKeys never got initialized getRowCount method called,method getRowCount class org jfree data category DefaultIntervalCategoryDataset says Returns number series dataset possibly zero implementation v longer checks null condition would return zero seriesKeys v previous throws Null Pointer seriesKeys never got initialized getRowCount method called,1
0,Math,NPE calling SubLine intersection non intersecting lines,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,1
0,Math,NPE calling SubLine intersection non intersecting lines,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,calling SubLine intersection two lines intersect NullPointerException thrown Line toSubSpace bug twod threed implementations attached patch fixes implementations adds required test cases,1
0,Lang,NullPointerException isAvailableLocale Locale,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,FindBugs pointed UwF Field initialized constructor org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet used directly source availableLocaleSet called cause NullPointerException,1
0,Lang,ClassUtils toClass Object throws NPE null array element,see summary,see summary,see summary,1
0,Lang,StringUtils join throws NPE toString returns null one objects collection,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,1
0,Lang,StringUtils join throws NPE toString returns null one objects collection,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,Try StringUtils join new Object new Object Override public String toString return null ToString probably never return null javax mail internet InternetAddress,1
0,Lang,StringUtils replaceEach Bug Missing Documentation,following Test Case replaceEach fails null pointer exception expected StringUtils methods null friendly use case stuff Values replacementList want check whether null admit use case perfect unclear happens replace outlined three expectations test case course one met decided none possible propose update documentation happens null passed replacement string import static org junit Assert assertEquals import org apache commons lang StringUtils import org junit Test public class StringUtilsTest Test public void replaceEach String original Hello World String searchList Hello World String replacementList Greetings null String result StringUtils replaceEach original searchList replacementList assertEquals Greetings result perhaps ok well assertEquals Greetings World result even assertEquals Greetings null result,following Test Case replaceEach fails null pointer exception expected StringUtils methods null friendly use case stuff Values replacementList want check whether null admit use case perfect unclear happens replace outlined three expectations test case course one met decided none possible propose update documentation happens null passed replacement string import static org junit Assert assertEquals import org apache commons lang StringUtils import org junit Test public class StringUtilsTest Test public void replaceEach String original Hello World String searchList Hello World String replacementList Greetings null String result StringUtils replaceEach original searchList replacementList assertEquals Greetings result perhaps ok well assertEquals Greetings World result even assertEquals Greetings null result,following Test Case replaceEach fails null pointer exception expected StringUtils methods null friendly use case stuff Values replacementList want check whether null admit use case perfect unclear happens replace outlined three expectations test case course one met decided none possible propose update documentation happens null passed replacement string import static org junit Assert assertEquals import org apache commons lang StringUtils import org junit Test public class StringUtilsTest Test public void replaceEach String original Hello World String searchList Hello World String replacementList Greetings null String result StringUtils replaceEach original searchList replacementList assertEquals Greetings result perhaps ok well assertEquals Greetings World result even assertEquals Greetings null result,1
0,Lang,StrBuilder appendFixedWidth handle nulls,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,1
0,Lang,StrBuilder appendFixedWidth handle nulls,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,Appending null value fixed width causes null pointer exception getNullText set,1
0,Closure,Column indicating caret sometimes error output,None,None,None,1
0,Chart,Potential NPE AbstractCategoryItemRender getLegendItems,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,Setting working copy current JFreeChart trunk Eclipse got warning null pointer access bit code AbstractCategoryItemRender java warning last code line seriesCount assigned variable dataset guaranteed null location suppose check actually read dataset null dataset null,1
0,Math,bug inverseCumulativeProbability Normal Distribution,version Revision 617953 Date 2008 02 02 22 54 00 0700 Sat 02 Feb 2008 public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision 506600 Date 2007 02 12 12 35 59 0700 Mon 12 Feb 2007 public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution 0 1 double result normal inverseCumulativeProbability 0 9772498680518209 gives exception return approx 2 0000 normal inverseCumulativeProbability 0 977249868051820 works fine also give errors 0 9986501019683698 return 3 0000 0 9999683287581673 return 4 0000 org apache commons math MathException Number iterations 1 maximum iterations 2 147 483 647 initial 1 lower bound 0 upper bound 179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final value 0 final b value 2 f 0 477 f b 0 org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java 103 org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java 145,version Revision  Date        Sat  Feb  public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision  Date        Mon  Feb  public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution   double result normal inverseCumulativeProbability   gives exception return approx   normal inverseCumulativeProbability   works fine also give errors   return     return   org apache commons math MathException Number iterations  maximum iterations     initial  lower bound  upper bound                                                                                                        final value  final b value  f   f b  org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java  org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java ,version Revision Date Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision Date Mon Feb public abstract class AbstractContinuousDistribution code DistributionFactory factory app getDistributionFactory NormalDistribution normal factory createNormalDistribution double result normal inverseCumulativeProbability gives exception return approx normal inverseCumulativeProbability works fine also give errors return return org apache commons math MathException Number iterations maximum iterations initial lower bound upper bound final value final b value f f b org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java,1
0,Math,SimplexSolver working expected 2,SimplexSolver find optimal solution Program Lpsolve Objective function max 7 3 b Constraints R1 3 5 c 0 R2 2 5 0 R3 2 b 5 c 0 R4 3 b 5 0 R5 3 2 b 5 R6 2 3 b 5 Variable bounds 1 b 1 Results correct 1 b 1 value 10 Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double 7 3 0 0 0 Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double 1 0 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 0 1 0 0 Relationship LEQ 1 podmienky add new LinearConstraint new double 3 0 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 2 0 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 2 5 0 Relationship LEQ 0 podmienky add new LinearConstraint new double 0 3 0 5 Relationship LEQ 0 podmienky add new LinearConstraint new double 3 2 0 0 Relationship LEQ 5 podmienky add new LinearConstraint new double 2 3 0 0 Relationship LEQ 5 SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect 1 b 0 5 value 8 5 P used latest software repository including MATH 286 fix,SimplexSolver find optimal solution Program Lpsolve Objective function max   b Constraints R   c  R    R  b  c  R  b   R   b  R   b  Variable bounds  b  Results correct  b  value  Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double      Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  podmienky add new LinearConstraint new double     Relationship LEQ  SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect  b   value   P used latest software repository including MATH  fix,SimplexSolver find optimal solution Program Lpsolve Objective function max b Constraints R c R R b c R b R b R b Variable bounds b Results correct b value Program SimplexSolve LinearObjectiveFunction kritFcia new LinearObjectiveFunction new double Collection LinearConstraint podmienky new ArrayList LinearConstraint podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ podmienky add new LinearConstraint new double Relationship LEQ SimplexSolver solver new SimplexSolver RealPointValuePair result solver optimize kritFcia podmienky GoalType MAXIMIZE true Results incorrect b value P used latest software repository including MATH fix,1
0,Closure,Break finally block optimized properly,None,None,None,1
0,Closure,Erroneous optimization ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,OAKfeadc,PropertyIndex cost calculation faulty,cost calculation easily go bounds needs estimate whenever 100 nodes high value returns higher traversal index max 10M less smaller example 100 nodes index single level content cost 6250000 adding second level content data cost jumps 1 544804416E9 101 nodes index single level content cost 100 adding second level content data stays 100 100 nodes 12 levels deep cost 2 147483647E9 101 nodes 12 levels deep cost 6 7108864E7,cost calculation easily go bounds needs estimate whenever  nodes high value returns higher traversal index max M less smaller example  nodes index single level content cost  adding second level content data cost jumps  E  nodes index single level content cost  adding second level content data stays   nodes  levels deep cost  E  nodes  levels deep cost  E,cost calculation easily go bounds needs estimate whenever nodes high value returns higher traversal index max less smaller example nodes index single level content cost adding second level content data cost jumps E nodes index single level content cost adding second level content data stays nodes levels deep cost E nodes levels deep cost E,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,MATHcb,RegulaFalsiSolver failure,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI 3 0 UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve 100 f 1 10 code fails noformat illegal state maximal count 100 exceeded evaluations noformat Using PegasusSolver answer found 17 evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI   UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve  f   code fails noformat illegal state maximal count  exceeded evaluations noformat Using PegasusSolver answer found  evaluations,following unit test code Test public void testBug final UnivariateRealFunction f new UnivariateRealFunction Override public double value double x return Math exp x Math pow Math PI UnivariateRealSolver solver new RegulaFalsiSolver double root solver solve f code fails noformat illegal state maximal count exceeded evaluations noformat Using PegasusSolver answer found evaluations,1
0,Bears,ClassGeneratingPropertyAccessorFactory isTypeInjectable fails NPE entities default packages DATACMNS 1201,opened commented Introspecting ClassGeneratingPropertyAccessorFactory support entity fails NPE entity resides default package Affects 1 13 8 Ingalls SR8 2 0 GA Kay Referenced pull request 256 Backported 2 0 1 Kay SR1 1 13 9 Ingalls SR9,opened commented Introspecting ClassGeneratingPropertyAccessorFactory support entity fails NPE entity resides default package Affects    Ingalls SR   GA Kay Referenced pull request  Backported    Kay SR    Ingalls SR,opened commented Introspecting ClassGeneratingPropertyAccessorFactory support entity fails NPE entity resides default package Affects Ingalls SR GA Kay Referenced pull request Backported Kay SR Ingalls SR,1
0,Bears,AnnotationRevisionMetadata throws ClassCastException DATACMNS 1173,opened commented AnnotationRevisionMetadata throws ClassCastException line 90 likely leftovers migration java util Optional Affects 2 0 RC3 Kay,opened commented AnnotationRevisionMetadata throws ClassCastException line  likely leftovers migration java util Optional Affects   RC Kay,opened commented AnnotationRevisionMetadata throws ClassCastException line likely leftovers migration java util Optional Affects RC Kay,1
0,Bears,ClassCastExecption,Hi started using meitrack tc68s device however try generate summary trip report returns following error console device future correct timezone also using official build recommendation osram works fine,Hi started using meitrack tcs device however try generate summary trip report returns following error console device future correct timezone also using official build recommendation osram works fine,Hi started using meitrack tcs device however try generate summary trip report returns following error console device future correct timezone also using official build recommendation osram works fine,1
0,Bears,address controller NPE required parameters address plan type set,Description required parameter address plan type address definition set cause NPE address controller https github com EnMasseProject enmasse blob master address model lib src main java io enmasse address model v1 AddressV1Deserializer java L36 Steps reproduce create brokered address space brokered space create address without required parameter brokered incorrect address json Automated test automated test yet output address controller log,Description required parameter address plan type address definition set cause NPE address controller https github com EnMasseProject enmasse blob master address model lib src main java io enmasse address model v AddressVDeserializer java L Steps reproduce create brokered address space brokered space create address without required parameter brokered incorrect address json Automated test automated test yet output address controller log,Description required parameter address plan type address definition set cause NPE address controller https github com EnMasseProject enmasse blob master address model lib src main java io enmasse address model v AddressVDeserializer java L Steps reproduce create brokered address space brokered space create address without required parameter brokered incorrect address json Automated test automated test yet output address controller log,1
0,Bears,Locale deserialize zh hant CN,zh hant CN convert zh HANT cn Locale include language country variant Locale toString use split language country variant | script extensions Jackson deserialize Locale use code LocaleHandle readResolve iana language tags rfc4647 language lookup jdk1 5 1 8,zh hant CN convert zh HANT cn Locale include language country variant Locale toString use split language country variant | script extensions Jackson deserialize Locale use code LocaleHandle readResolve iana language tags rfc language lookup jdk   ,zh hant CN convert zh HANT cn Locale include language country variant Locale toString use split language country variant | script extensions Jackson deserialize Locale use code LocaleHandle readResolve iana language tags rfc language lookup jdk,1
0,Bears,rest api returns wrong address status isReady true phase Pending,address space standard addresses queue sharded queue topic sharded topic addresses deployed address space ready use simple send receive status phase set Pending reproducer create deploy get addresses result address space definition standardSpace json addresses definition standard qt json however standard controller log see addresses phase Active ConfigMap myqueue contains phase Active well try reproduce brokered,address space standard addresses queue sharded queue topic sharded topic addresses deployed address space ready use simple send receive status phase set Pending reproducer create deploy get addresses result address space definition standardSpace json addresses definition standard qt json however standard controller log see addresses phase Active ConfigMap myqueue contains phase Active well try reproduce brokered,address space standard addresses queue sharded queue topic sharded topic addresses deployed address space ready use simple send receive status phase set Pending reproducer create deploy get addresses result address space definition standardSpace json addresses definition standard qt json however standard controller log see addresses phase Active ConfigMap myqueue contains phase Active well try reproduce brokered,1
0,Bears,could disable static imports v55 output,found v53 producing static imports,found v producing static imports,found v producing static imports,1
0,Bears,EntityInstantiators deallocate params required instantiation parent object DATACMNS 1175,opened commented Fetching nested document MongoDB Kotlin data class structure sometimes result NullPointerException caused DefaultingKotlinClassInstantiatorAdapter createInstance calling ClassGeneratingEntityInstantiator deallocateArguments method cleaning shared params array instantiating child object clean previously prepared arguments parents constructor thus causing NPEs non null parameters Note everything fine using version Spring Data bundled Spring Boot 2 0 0 M3 Affects 2 0 RC3 Kay Referenced pull request 247 commits,opened commented Fetching nested document MongoDB Kotlin data class structure sometimes result NullPointerException caused DefaultingKotlinClassInstantiatorAdapter createInstance calling ClassGeneratingEntityInstantiator deallocateArguments method cleaning shared params array instantiating child object clean previously prepared arguments parents constructor thus causing NPEs non null parameters Note everything fine using version Spring Data bundled Spring Boot    M Affects   RC Kay Referenced pull request  commits,opened commented Fetching nested document MongoDB Kotlin data class structure sometimes result NullPointerException caused DefaultingKotlinClassInstantiatorAdapter createInstance calling ClassGeneratingEntityInstantiator deallocateArguments method cleaning shared params array instantiating child object clean previously prepared arguments parents constructor thus causing NPEs non null parameters Note everything fine using version Spring Data bundled Spring Boot Affects RC Kay Referenced pull request commits,1
0,Bears,Failing generic type resolution generic types within nested generic fields DATACMNS 1196,opened commented seems type resolution working properly nested object composition generic type Example model constructors getters ommited create instance Outer create instance Outer reference instance Generic whose generic type MyEnum save Outer instance using MongoTemplate persisted db correctly converted mongo document try read db mapped incorrectly back Outer Field myList instance Inner contains List contains instances String field elem instance Inner mapped correctly really contains instance MyEnum Seems problem MongoConverter attaching simple project able reproduce problem described tests actually storing instance mongo collection rather using MongoConverter convert instance Document back Outer know workaround cold writing custom Converter workaround real project manually convert Document domain specific instance really annoying know mapping mongo types back tricky sometimes type information lost case comparison tried Jackson ObjectMapper serialization instance Outer JSON string de serialize JSON back Outer seems Jackson resolves generic types correctly Affects 1 13 8 Ingalls SR8 2 0 GA Kay Attachments Backported 2 0 1 Kay SR1 1 13 9 Ingalls SR9,opened commented seems type resolution working properly nested object composition generic type Example model constructors getters ommited create instance Outer create instance Outer reference instance Generic whose generic type MyEnum save Outer instance using MongoTemplate persisted db correctly converted mongo document try read db mapped incorrectly back Outer Field myList instance Inner contains List contains instances String field elem instance Inner mapped correctly really contains instance MyEnum Seems problem MongoConverter attaching simple project able reproduce problem described tests actually storing instance mongo collection rather using MongoConverter convert instance Document back Outer know workaround cold writing custom Converter workaround real project manually convert Document domain specific instance really annoying know mapping mongo types back tricky sometimes type information lost case comparison tried Jackson ObjectMapper serialization instance Outer JSON string de serialize JSON back Outer seems Jackson resolves generic types correctly Affects    Ingalls SR   GA Kay Attachments Backported    Kay SR    Ingalls SR,opened commented seems type resolution working properly nested object composition generic type Example model constructors getters ommited create instance Outer create instance Outer reference instance Generic whose generic type MyEnum save Outer instance using MongoTemplate persisted db correctly converted mongo document try read db mapped incorrectly back Outer Field myList instance Inner contains List contains instances String field elem instance Inner mapped correctly really contains instance MyEnum Seems problem MongoConverter attaching simple project able reproduce problem described tests actually storing instance mongo collection rather using MongoConverter convert instance Document back Outer know workaround cold writing custom Converter workaround real project manually convert Document domain specific instance really annoying know mapping mongo types back tricky sometimes type information lost case comparison tried Jackson ObjectMapper serialization instance Outer JSON string de serialize JSON back Outer seems Jackson resolves generic types correctly Affects Ingalls SR GA Kay Attachments Backported Kay SR Ingalls SR,1
0,Bears,ParentNotInitializedException CtComments,Hello build JavaFileTest javapoet comments enabled build throw following error snippet example assertThat source,Hello build JavaFileTest javapoet comments enabled build throw following error snippet example assertThat source,Hello build JavaFileTest javapoet comments enabled build throw following error snippet example assertThat source,1
0,Bears,CtTypeReferenceImpl getSuperClass fails noClasspath mode,method following implementation see check noClasspath thus may fail calling getActualClass,method following implementation see check noClasspath thus may fail calling getActualClass,method following implementation see check noClasspath thus may fail calling getActualClass,1
0,Bears,address controller allows create multiple addresses spec address value,reproducible via following steps create standard address space reproducible brokered well deploy 3 addresses address space addresses created successfully console shows one addresses next address appears previous one removed first multiple addresses isReady attribute set true configMap standard anycast json,reproducible via following steps create standard address space reproducible brokered well deploy  addresses address space addresses created successfully console shows one addresses next address appears previous one removed first multiple addresses isReady attribute set true configMap standard anycast json,reproducible via following steps create standard address space reproducible brokered well deploy addresses address space addresses created successfully console shows one addresses next address appears previous one removed first multiple addresses isReady attribute set true configMap standard anycast json,1
0,Bears,Hibernate Subselect Entity supported EntityMetamodelImpl,Description playing bit table functions see also 181 idea experiment mapping generate series query entity using annotation Find produced stack trace trivial work around wrap query view map instead uncertain whether fix worthwhile could perhaps step towards implementing table functions 181 Expected behavior Actual behavior Steps reproduce Environment Version 1 2 0 Alpha3 JPA Provider Hibernate 5 2 12 DBMS PostgresSQL Application Server Wildfly,Description playing bit table functions see also  idea experiment mapping generate series query entity using annotation Find produced stack trace trivial work around wrap query view map instead uncertain whether fix worthwhile could perhaps step towards implementing table functions  Expected behavior Actual behavior Steps reproduce Environment Version    Alpha JPA Provider Hibernate    DBMS PostgresSQL Application Server Wildfly,Description playing bit table functions see also idea experiment mapping generate series query entity using annotation Find produced stack trace trivial work around wrap query view map instead uncertain whether fix worthwhile could perhaps step towards implementing table functions Expected behavior Actual behavior Steps reproduce Environment Version Alpha JPA Provider Hibernate DBMS PostgresSQL Application Server Wildfly,1
0,Bears,Unable set compression input output decorator SmileFactory,special need riak java client allows use ObjectMapper serialize deserialize key values would like decorate SmileFactory compressors like LZ4 Snappy GZip moment possible try mapper like following exception get used Gzip example reality using LZ4 Gzip throw exceptions try SmileFactory works perfectly JsonFactory reason prefer SmileFactory JsonFactory notice able faster JsonFactory basically help compensate price pay compression,special need riak java client allows use ObjectMapper serialize deserialize key values would like decorate SmileFactory compressors like LZ Snappy GZip moment possible try mapper like following exception get used Gzip example reality using LZ Gzip throw exceptions try SmileFactory works perfectly JsonFactory reason prefer SmileFactory JsonFactory notice able faster JsonFactory basically help compensate price pay compression,special need riak java client allows use ObjectMapper serialize deserialize key values would like decorate SmileFactory compressors like LZ Snappy GZip moment possible try mapper like following exception get used Gzip example reality using LZ Gzip throw exceptions try SmileFactory works perfectly JsonFactory reason prefer SmileFactory JsonFactory notice able faster JsonFactory basically help compensate price pay compression,1
0,Bears,feat add support java version pom xml,Hi issue creating MavenLauncher projects java version POM xml Replacing 1 8 example seems work around Thank help,Hi issue creating MavenLauncher projects java version POM xml Replacing   example seems work around Thank help,Hi issue creating MavenLauncher projects java version POM xml Replacing example seems work around Thank help,1
0,Bears,ClassGeneratingPropertyAccessorFactory needs custom ClassLoader defineClass DATACMNS 1422,opened commented ClassGeneratingPropertyAccessorFactory fails generate classes OSGi environment ClassLoader model project store implementation Spring Data different error facing problem seems PropertyAccessorClassGenerator generateBytecode adds interface PersistentPropertyAccessor lives Spring Data generateCustomAccessorClass ClassLoader model entity used Therefore ClassLoader custom model project needs access classes added factory especially package org springframework data mapping resolve problem child ClassLoader entity used able access projects Spring Data custom entity model Else fail different classes mixed cannot accessed single ClassLoader Affects 2 1 2 Lovelace SR2 Attachments Referenced pull request 324 Backported 2 1 3 Lovelace SR3,opened commented ClassGeneratingPropertyAccessorFactory fails generate classes OSGi environment ClassLoader model project store implementation Spring Data different error facing problem seems PropertyAccessorClassGenerator generateBytecode adds interface PersistentPropertyAccessor lives Spring Data generateCustomAccessorClass ClassLoader model entity used Therefore ClassLoader custom model project needs access classes added factory especially package org springframework data mapping resolve problem child ClassLoader entity used able access projects Spring Data custom entity model Else fail different classes mixed cannot accessed single ClassLoader Affects    Lovelace SR Attachments Referenced pull request  Backported    Lovelace SR,opened commented ClassGeneratingPropertyAccessorFactory fails generate classes OSGi environment ClassLoader model project store implementation Spring Data different error facing problem seems PropertyAccessorClassGenerator generateBytecode adds interface PersistentPropertyAccessor lives Spring Data generateCustomAccessorClass ClassLoader model entity used Therefore ClassLoader custom model project needs access classes added factory especially package org springframework data mapping resolve problem child ClassLoader entity used able access projects Spring Data custom entity model Else fail different classes mixed cannot accessed single ClassLoader Affects Lovelace SR Attachments Referenced pull request Backported Lovelace SR,1
0,Bears,Calling blacklistLibOrExtJars without arguments causes Exception,Calling blacklistLibOrExtJars without arguments throws java lang IllegalArgumentException blacklist jars leafname System Library Java Extensions MRJToolkit jar whitelistLibOrExtJars without arguments works fine,Calling blacklistLibOrExtJars without arguments throws java lang IllegalArgumentException blacklist jars leafname System Library Java Extensions MRJToolkit jar whitelistLibOrExtJars without arguments works fine,Calling blacklistLibOrExtJars without arguments throws java lang IllegalArgumentException blacklist jars leafname System Library Java Extensions MRJToolkit jar whitelistLibOrExtJars without arguments works fine,1
0,Bears,One many integer ids retrieval broken,Reproduce Upload string id xlsx Go dataexplorer select Subjects table like order samples want change ID attribute datatype samples int Upload int id xlsx Go table Expected behavior beautiful table nicely int sorted happy datamanager Observed behavior Sad datamanager,Reproduce Upload string id xlsx Go dataexplorer select Subjects table like order samples want change ID attribute datatype samples int Upload int id xlsx Go table Expected behavior beautiful table nicely int sorted happy datamanager Observed behavior Sad datamanager,Reproduce Upload string id xlsx Go dataexplorer select Subjects table like order samples want change ID attribute datatype samples int Upload int id xlsx Go table Expected behavior beautiful table nicely int sorted happy datamanager Observed behavior Sad datamanager,1
0,Bears,NPE google cloud storage,Hi time try access Resource google storage throws following NPE happens read write pom looks like code even tried checking entire repo run code spring cloud gcp storage resource sample class WebController changing bucket name still get NPE removed entire m2 directory started still issue persists double checked access bucket even tried form service account project admin access problem persists,Hi time try access Resource google storage throws following NPE happens read write pom looks like code even tried checking entire repo run code spring cloud gcp storage resource sample class WebController changing bucket name still get NPE removed entire m directory started still issue persists double checked access bucket even tried form service account project admin access problem persists,Hi time try access Resource google storage throws following NPE happens read write pom looks like code even tried checking entire repo run code spring cloud gcp storage resource sample class WebController changing bucket name still get NPE removed entire directory started still issue persists double checked access bucket even tried form service account project admin access problem persists,1
0,Bears,FromStringDeserializer ignores registered DeserializationProblemHandler java util UUID,Culprit appears lines 155 161 FromStringDeserializer lines appear show exception thrown regardless problem handling logic Test Case handler handles issue properly exception thrown anyway,Culprit appears lines   FromStringDeserializer lines appear show exception thrown regardless problem handling logic Test Case handler handles issue properly exception thrown anyway,Culprit appears lines FromStringDeserializer lines appear show exception thrown regardless problem handling logic Test Case handler handles issue properly exception thrown anyway,1
0,Bears,Add support handling primitive discrepancy problem type refinements,note derived FasterXML jackson module jaxb annotations 64 problem although int java lang Integer related logically related inheritance implementation Since legacy code may try refinements axis nice handle somehow Two basic approaches would ignore primitive wrapper override return original type Allow wrapper refine primitive return wrapper also related question whether allow int long similar refinements start basics,note derived FasterXML jackson module jaxb annotations  problem although int java lang Integer related logically related inheritance implementation Since legacy code may try refinements axis nice handle somehow Two basic approaches would ignore primitive wrapper override return original type Allow wrapper refine primitive return wrapper also related question whether allow int long similar refinements start basics,note derived FasterXML jackson module jaxb annotations problem although int java lang Integer related logically related inheritance implementation Since legacy code may try refinements axis nice handle somehow Two basic approaches would ignore primitive wrapper override return original type Allow wrapper refine primitive return wrapper also related question whether allow int long similar refinements start basics,1
0,Bears,Importing entitytype several columns name import without errors,Reproduce Import datasheet multiple columns name Expected behavior error telling use name every attribute per entitytype Observed behavior Everything imports fine issues much later one would expect,Reproduce Import datasheet multiple columns name Expected behavior error telling use name every attribute per entitytype Observed behavior Everything imports fine issues much later one would expect,Reproduce Import datasheet multiple columns name Expected behavior error telling use name every attribute per entitytype Observed behavior Everything imports fine issues much later one would expect,1
0,Bears,Changes SourcePosition 5 5 0,Hello according 1081 find mentions changes SourcePosition use case want calculate size constructors methods worked fine 5 4 5 5 Snapshot want analyze file inner private class constructors Spoon generates default private constructor one statement super start line constructor 1 getPosition getFile returns null statements super line 383 file method throws NP method size calculation wrong gets passed threshold try access file generated private constructor always implement case ignore generated constructors want make sure intented,Hello according  find mentions changes SourcePosition use case want calculate size constructors methods worked fine     Snapshot want analyze file inner private class constructors Spoon generates default private constructor one statement super start line constructor  getPosition getFile returns null statements super line  file method throws NP method size calculation wrong gets passed threshold try access file generated private constructor always implement case ignore generated constructors want make sure intented,Hello according find mentions changes SourcePosition use case want calculate size constructors methods worked fine Snapshot want analyze file inner private class constructors Spoon generates default private constructor one statement super start line constructor getPosition getFile returns null statements super line file method throws NP method size calculation wrong gets passed threshold try access file generated private constructor always implement case ignore generated constructors want make sure intented,1
0,Bears,Enum key Map ignores SerializationFeature WRITE ENUMS USING INDEX,Version latest 2 8 Failing unit tests added https github com SolaKun jackson databind commit 6e095f75edd1de3eb33be5950c56d562bd6d584a java util Map test case provided work EnumMap well,Version latest   Failing unit tests added https github com SolaKun jackson databind commit efedddeebbecdbdda java util Map test case provided work EnumMap well,Version latest Failing unit tests added https github com SolaKun jackson databind commit efedddeebbecdbdda java util Map test case provided work EnumMap well,1
0,Bears,JsonEnumDefaultValue take precedence FAIL NUMBERS ENUMS,Consider following ObjectMapper definition ObjectMapper one attempts deserialize enum value V enum JsonEnumDefaultValue element deserialization Pass Pass Fail seems highly unintuitive would expected READ UNKNOWN ENUM VALUES USING DEFAULT VALUE feature take precedence FAIL NUMBERS ENUMS feature cases applies e deserializing enum default element put together test class enumerating relevant cases See inline comments towards bottom four cases feel Jackson current behavior one might expect Would love hear thoughts feature enable get behavior looking let know,Consider following ObjectMapper definition ObjectMapper one attempts deserialize enum value V enum JsonEnumDefaultValue element deserialization Pass Pass Fail seems highly unintuitive would expected READ UNKNOWN ENUM VALUES USING DEFAULT VALUE feature take precedence FAIL NUMBERS ENUMS feature cases applies e deserializing enum default element put together test class enumerating relevant cases See inline comments towards bottom four cases feel Jackson current behavior one might expect Would love hear thoughts feature enable get behavior looking let know,Consider following ObjectMapper definition ObjectMapper one attempts deserialize enum value V enum JsonEnumDefaultValue element deserialization Pass Pass Fail seems highly unintuitive would expected READ UNKNOWN ENUM VALUES USING DEFAULT VALUE feature take precedence FAIL NUMBERS ENUMS feature cases applies e deserializing enum default element put together test class enumerating relevant cases See inline comments towards bottom four cases feel Jackson current behavior one might expect Would love hear thoughts feature enable get behavior looking let know,1
0,Bears,Wrong serializer causing JsonMappingException,using spring data rest 3 0 0 uses jackson databind 2 9 0 pr2 sure changed since long ago functional application getting Could write JSON document java lang Double cannot cast java lang Integer reference chain org springframework data rest webmvc json PersistentEntityJackson2Module PersistentEntityResourceSerializer 1 content Contrato storageUtilizado nested exception com fasterxml jackson databind JsonMappingException java lang Double cannot cast java lang Integer reference chain org springframework data rest webmvc json PersistentEntityJackson2Module PersistentEntityResourceSerializer 1 content Contrato storageUtilizado stucked problem assuming something wrong de Serializer specific field defined need least directions,using spring data rest    uses jackson databind    pr sure changed since long ago functional application getting Could write JSON document java lang Double cannot cast java lang Integer reference chain org springframework data rest webmvc json PersistentEntityJacksonModule PersistentEntityResourceSerializer  content Contrato storageUtilizado nested exception com fasterxml jackson databind JsonMappingException java lang Double cannot cast java lang Integer reference chain org springframework data rest webmvc json PersistentEntityJacksonModule PersistentEntityResourceSerializer  content Contrato storageUtilizado stucked problem assuming something wrong de Serializer specific field defined need least directions,using spring data rest uses jackson databind pr sure changed since long ago functional application getting Could write JSON document java lang Double cannot cast java lang Integer reference chain org springframework data rest webmvc json PersistentEntityJacksonModule PersistentEntityResourceSerializer content Contrato storageUtilizado nested exception com fasterxml jackson databind JsonMappingException java lang Double cannot cast java lang Integer reference chain org springframework data rest webmvc json PersistentEntityJacksonModule PersistentEntityResourceSerializer content Contrato storageUtilizado stucked problem assuming something wrong de Serializer specific field defined need least directions,1
0,Bears,Invalid generics resolution locally declared wildcard fully resolved target type DATACMNS 1138,opened commented Given following context entity declares field type class wildcard type implementation field class typed custom object custom converter declared custom object persist entity custom class Mongo retrieve entity database field custom type deserialized custom converter problem happen remove wildcard declared field use type require custom converter e g Integer sure description clear please take look project GitHub https github com mclem spring data mongodb generics reproduce problem running mvn test Affects 1 12 11 Hopper SR11 1 13 6 Ingalls SR6 2 0 RC2 Kay Reference URL https github com mclem spring data mongodb generics Issue Links Backported 1 13 7 Ingalls SR7 1 12 12 Hopper SR12,opened commented Given following context entity declares field type class wildcard type implementation field class typed custom object custom converter declared custom object persist entity custom class Mongo retrieve entity database field custom type deserialized custom converter problem happen remove wildcard declared field use type require custom converter e g Integer sure description clear please take look project GitHub https github com mclem spring data mongodb generics reproduce problem running mvn test Affects    Hopper SR    Ingalls SR   RC Kay Reference URL https github com mclem spring data mongodb generics Issue Links Backported    Ingalls SR    Hopper SR,opened commented Given following context entity declares field type class wildcard type implementation field class typed custom object custom converter declared custom object persist entity custom class Mongo retrieve entity database field custom type deserialized custom converter problem happen remove wildcard declared field use type require custom converter e g Integer sure description clear please take look project GitHub https github com mclem spring data mongodb generics reproduce problem running mvn test Affects Hopper SR Ingalls SR RC Kay Reference URL https github com mclem spring data mongodb generics Issue Links Backported Ingalls SR Hopper SR,1
0,Bears,MU 201 v3 xx doesnt work,Hi tried install tracker Traccar work Logfile generated everything running tracker HEX translatet Port 5051 add device Kind regards Daniel,Hi tried install tracker Traccar work Logfile generated everything running tracker HEX translatet Port  add device Kind regards Daniel,Hi tried install tracker Traccar work Logfile generated everything running tracker HEX translatet Port add device Kind regards Daniel,1
0,Bears,CtFieldReference getDefaultExpression returns initializer field another class,Hi trying collect evaluate certain strings source repository tried VisitorPartialEvaluator runs infinite loop reason fields get mixed code setup like try read return value getKey method CtFieldReference object return default value ClassB PREFIX BaseClass PREFIX,Hi trying collect evaluate certain strings source repository tried VisitorPartialEvaluator runs infinite loop reason fields get mixed code setup like try read return value getKey method CtFieldReference object return default value ClassB PREFIX BaseClass PREFIX,Hi trying collect evaluate certain strings source repository tried VisitorPartialEvaluator runs infinite loop reason fields get mixed code setup like try read return value getKey method CtFieldReference object return default value ClassB PREFIX BaseClass PREFIX,1
0,Bears,Converting Vavr Option fails present value DATACMNS 1087,opened commented Curently QueryExecutionConverters tries invoke Vavr Optional like instance method rather static one causes exception Affects 1 13 4 Ingalls SR4 Referenced commits,opened commented Curently QueryExecutionConverters tries invoke Vavr Optional like instance method rather static one causes exception Affects    Ingalls SR Referenced commits,opened commented Curently QueryExecutionConverters tries invoke Vavr Optional like instance method rather static one causes exception Affects Ingalls SR Referenced commits,1
0,Bears,JsonProperty access Access READ unexpected behaviour,Hey hoping make use JsonProperty access Access READ failed Assume class find way stop deserializer attempting deserialize field fullName thing helps create setter annotate JsonIgnore However setter make sense want bug behaviour missing something Thanks,Hey hoping make use JsonProperty access Access READ failed Assume class find way stop deserializer attempting deserialize field fullName thing helps create setter annotate JsonIgnore However setter make sense want bug behaviour missing something Thanks,Hey hoping make use JsonProperty access Access READ failed Assume class find way stop deserializer attempting deserialize field fullName thing helps create setter annotate JsonIgnore However setter make sense want bug behaviour missing something Thanks,1
0,Bears,ParentNotInitializedException processing comments c,aware comments processed using command c since Spoon 5 2 0 Thanks feature using Spoon process comments either code snippet ParentNotInitializedException thrown empty processor used reproduce issue happens Spoon 5 2 5 4 public class Comment 1 public class Comment2 Details exception follows spoon reflect declaration ParentNotInitializedException parent initialized class spoon support reflect code CtCommentImpl home jifeng workspace Temp4 src main java example Comment1 java 17 spoon support reflect declaration CtElementImpl getParent CtElementImpl java 284 spoon support compiler jdt JDTCommentBuilder insertCommentInAST JDTCommentBuilder java 377 spoon support compiler jdt JDTCommentBuilder buildComment JDTCommentBuilder java 131 spoon support compiler jdt JDTCommentBuilder build JDTCommentBuilder java 96 spoon support compiler jdt JDTBasedSpoonCompiler buildSources JDTBasedSpoonCompiler java 387 spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java 116 spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java 99 spoon Launcher buildModel Launcher java 712 spoon Launcher run Launcher java 663 spoon Launcher run Launcher java 106 spoon Launcher main Launcher java 99,aware comments processed using command c since Spoon    Thanks feature using Spoon process comments either code snippet ParentNotInitializedException thrown empty processor used reproduce issue happens Spoon     public class Comment  public class Comment Details exception follows spoon reflect declaration ParentNotInitializedException parent initialized class spoon support reflect code CtCommentImpl home jifeng workspace Temp src main java example Comment java  spoon support reflect declaration CtElementImpl getParent CtElementImpl java  spoon support compiler jdt JDTCommentBuilder insertCommentInAST JDTCommentBuilder java  spoon support compiler jdt JDTCommentBuilder buildComment JDTCommentBuilder java  spoon support compiler jdt JDTCommentBuilder build JDTCommentBuilder java  spoon support compiler jdt JDTBasedSpoonCompiler buildSources JDTBasedSpoonCompiler java  spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java  spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java  spoon Launcher buildModel Launcher java  spoon Launcher run Launcher java  spoon Launcher run Launcher java  spoon Launcher main Launcher java ,aware comments processed using command c since Spoon Thanks feature using Spoon process comments either code snippet ParentNotInitializedException thrown empty processor used reproduce issue happens Spoon public class Comment public class Comment Details exception follows spoon reflect declaration ParentNotInitializedException parent initialized class spoon support reflect code CtCommentImpl home jifeng workspace Temp src main java example Comment java spoon support reflect declaration CtElementImpl getParent CtElementImpl java spoon support compiler jdt JDTCommentBuilder insertCommentInAST JDTCommentBuilder java spoon support compiler jdt JDTCommentBuilder buildComment JDTCommentBuilder java spoon support compiler jdt JDTCommentBuilder build JDTCommentBuilder java spoon support compiler jdt JDTBasedSpoonCompiler buildSources JDTBasedSpoonCompiler java spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java spoon Launcher buildModel Launcher java spoon Launcher run Launcher java spoon Launcher run Launcher java spoon Launcher main Launcher java,1
0,Bears,Extraneous type id mapping added base type,Looks like type id name matching base type included type resolution list automatically might useful sometimes seems quite odd probably included Base type concrete Base type explicit name add default name used,Looks like type id name matching base type included type resolution list automatically might useful sometimes seems quite odd probably included Base type concrete Base type explicit name add default name used,Looks like type id name matching base type included type resolution list automatically might useful sometimes seems quite odd probably included Base type concrete Base type explicit name add default name used,1
0,Bears,Wrong constructor picked deserializing object,discovered issue Jackson 2 7 8 Jackson 2 8 4 several constructors parameters annotated JsonProperty one annotated JsonCreator test case reproduce test throws following exception debugging looks like BasicDeserializerFactory addDeserializerConstructors looping constructors favoring explicit constructor non explicit one actually know expected behavior jackson fail two constructors annotated jackson favor one annotated JsonCreator options look reasonable actually removing one constructors,discovered issue Jackson    Jackson    several constructors parameters annotated JsonProperty one annotated JsonCreator test case reproduce test throws following exception debugging looks like BasicDeserializerFactory addDeserializerConstructors looping constructors favoring explicit constructor non explicit one actually know expected behavior jackson fail two constructors annotated jackson favor one annotated JsonCreator options look reasonable actually removing one constructors,discovered issue Jackson Jackson several constructors parameters annotated JsonProperty one annotated JsonCreator test case reproduce test throws following exception debugging looks like BasicDeserializerFactory addDeserializerConstructors looping constructors favoring explicit constructor non explicit one actually know expected behavior jackson fail two constructors annotated jackson favor one annotated JsonCreator options look reasonable actually removing one constructors,1
0,Bears,DeserializationFeature UNWRAP SINGLE VALUE ARRAYS works POJOs Maps,Documentation DeserializationFeature UNWRAP SINGLE VALUE ARRAYS mentiones exceptional behavior one value array one value found array JsonMappingException thrown trying parse value value String produces following Stacktrace Parsing null might expected instead problematic using DeserializationFeature ACCEPT EMPTY ARRAY NULL OBJECT take precedence DeserializationFeature UNWRAP SINGLE VALUE ARRAYS bug still gives error workarounds still need map single element arrays sometimes appear empty using version 2 5 1 tested also 2 6 0 behavior,Documentation DeserializationFeature UNWRAP SINGLE VALUE ARRAYS mentiones exceptional behavior one value array one value found array JsonMappingException thrown trying parse value value String produces following Stacktrace Parsing null might expected instead problematic using DeserializationFeature ACCEPT EMPTY ARRAY NULL OBJECT take precedence DeserializationFeature UNWRAP SINGLE VALUE ARRAYS bug still gives error workarounds still need map single element arrays sometimes appear empty using version    tested also    behavior,Documentation DeserializationFeature UNWRAP SINGLE VALUE ARRAYS mentiones exceptional behavior one value array one value found array JsonMappingException thrown trying parse value value String produces following Stacktrace Parsing null might expected instead problematic using DeserializationFeature ACCEPT EMPTY ARRAY NULL OBJECT take precedence DeserializationFeature UNWRAP SINGLE VALUE ARRAYS bug still gives error workarounds still need map single element arrays sometimes appear empty using version tested also behavior,1
0,Bears,Repository findOne method fails return row row level secured entity type first row readable,Code inspection FindOne check first row delegate readable find first readable row,Code inspection FindOne check first row delegate readable find first readable row,Code inspection FindOne check first row delegate readable find first readable row,1
0,Bears,MapSerializer orderEntries throws NPE operating ConcurrentHashMap,seems fix introduced 1411 2 8 problematic ConcurrentSkipListMap possibly map data structures doc ConcurrentSkipListMap doGet,seems fix introduced    problematic ConcurrentSkipListMap possibly map data structures doc ConcurrentSkipListMap doGet,seems fix introduced problematic ConcurrentSkipListMap possibly map data structures doc ConcurrentSkipListMap doGet,1
0,Bears,NPE importing EMX abtract entity type data,Reproduce Import file Expected behavior Success allowed add data abstract entities expect message Observed behavior Importer hangs server logs report null pointer exception dataservice add method,Reproduce Import file Expected behavior Success allowed add data abstract entities expect message Observed behavior Importer hangs server logs report null pointer exception dataservice add method,Reproduce Import file Expected behavior Success allowed add data abstract entities expect message Observed behavior Importer hangs server logs report null pointer exception dataservice add method,1
0,Bears,DateTimeSerializerBase ignores configured date format creating contextual,DateTimeSerializerBase createContextual creates new serializer StdDateFormat DATE FORMAT STR ISO8601 format instead using actual format may specified configuration See following code Using JsonFormat annotation field therefore reset format Jackson default even annotation specify custom format DateBasedDeserializer createContextual behaves differently tries use configured format serializer follow approach,DateTimeSerializerBase createContextual creates new serializer StdDateFormat DATE FORMAT STR ISO format instead using actual format may specified configuration See following code Using JsonFormat annotation field therefore reset format Jackson default even annotation specify custom format DateBasedDeserializer createContextual behaves differently tries use configured format serializer follow approach,DateTimeSerializerBase createContextual creates new serializer StdDateFormat DATE FORMAT STR ISO format instead using actual format may specified configuration See following code Using JsonFormat annotation field therefore reset format Jackson default even annotation specify custom format DateBasedDeserializer createContextual behaves differently tries use configured format serializer follow approach,1
0,Bears,ProxyingHandlerMethodArgumentResolver handles interfaces intended projection DATACMNS 776,opened commented Spring Boot application depends spring boot starter data pa uses Spring Mobile create proxy Spring Mobile Device interface injected handler method Calling isMobile proxy fails follows culprit ProxyingHandlerMethodArgumentResolver takes responsibility argument interface work around problem ensuring Spring Mobile DeviceHandlerMethodArgumentResolver appears ProxyingHandlerMethodArgumentResolver Spring MVC list argument resolvers prefer ProxyingHandlerMethodArgumentResolver fixed either claim responsibility anything interface returns working proxy Affects 1 10 2 Fowler SR2 1 11 GA Gosling Issue Links Backported 1 13 GA Ingalls 1 12 7 Hopper SR7 1 11 7 Gosling SR7 4 votes 8 watchers,opened commented Spring Boot application depends spring boot starter data pa uses Spring Mobile create proxy Spring Mobile Device interface injected handler method Calling isMobile proxy fails follows culprit ProxyingHandlerMethodArgumentResolver takes responsibility argument interface work around problem ensuring Spring Mobile DeviceHandlerMethodArgumentResolver appears ProxyingHandlerMethodArgumentResolver Spring MVC list argument resolvers prefer ProxyingHandlerMethodArgumentResolver fixed either claim responsibility anything interface returns working proxy Affects    Fowler SR   GA Gosling Issue Links Backported   GA Ingalls    Hopper SR    Gosling SR  votes  watchers,opened commented Spring Boot application depends spring boot starter data pa uses Spring Mobile create proxy Spring Mobile Device interface injected handler method Calling isMobile proxy fails follows culprit ProxyingHandlerMethodArgumentResolver takes responsibility argument interface work around problem ensuring Spring Mobile DeviceHandlerMethodArgumentResolver appears ProxyingHandlerMethodArgumentResolver Spring MVC list argument resolvers prefer ProxyingHandlerMethodArgumentResolver fixed either claim responsibility anything interface returns working proxy Affects Fowler SR GA Gosling Issue Links Backported GA Ingalls Hopper SR Gosling SR votes watchers,1
0,Bears,bug removeStatement,example want remove second block removeStatement block getStatement 3 Spoon removes first one found martinezmatias thanks,example want remove second block removeStatement block getStatement  Spoon removes first one found martinezmatias thanks,example want remove second block removeStatement block getStatement Spoon removes first one found martinezmatias thanks,1
0,Bears,RepositoryBeanNameGenerator fails resolve bean names custom implementations detected via Spring component index DATACMNS 1115,opened commented upgrading Spring Boot 2 0 0 M2 Spring Data Kay M4 cannot start microservices accessing MongoDB testcase appended produce stacktrace First thought Spring Boot issue spring projects spring boot 9780 Stacktrace Affects 2 0 M4 Kay Attachments Backported 1 13 5 Ingalls SR5 1 12 12 Hopper SR12,opened commented upgrading Spring Boot    M Spring Data Kay M cannot start microservices accessing MongoDB testcase appended produce stacktrace First thought Spring Boot issue spring projects spring boot  Stacktrace Affects   M Kay Attachments Backported    Ingalls SR    Hopper SR,opened commented upgrading Spring Boot Spring Data Kay cannot start microservices accessing MongoDB testcase appended produce stacktrace First thought Spring Boot issue spring projects spring boot Stacktrace Affects Kay Attachments Backported Ingalls SR Hopper SR,1
0,Bears,element toString crashes NP DefaultJavaPrettyPrinter visitCtTypeReference,analyzing elasticsearch get NP calling element toString something type references give concrete source file problem rather part project tar archive elasticsearch tar gz,analyzing elasticsearch get NP calling element toString something type references give concrete source file problem rather part project tar archive elasticsearch tar gz,analyzing elasticsearch get NP calling element toString something type references give concrete source file problem rather part project tar archive elasticsearch tar gz,1
0,Bears,meitrack temp sensor negative value,Hi Anton receiving wrong value temp sensor negative temp values example data temp 06FB2E translate 12 34°C according doc protocol v3 Could please check traccar reading temp correctly negative values sample data test Regards,Hi Anton receiving wrong value temp sensor negative temp values example data temp FBE translate  °C according doc protocol v Could please check traccar reading temp correctly negative values sample data test Regards,Hi Anton receiving wrong value temp sensor negative temp values example data temp FBE translate °C according doc protocol v Could please check traccar reading temp correctly negative values sample data test Regards,1
0,Bears,Jackson configuration used ProjectingJackson2HttpMessageConverter DATACMNS 1152,opened commented ProjectingJackson2HttpMessageConverter using default MappingJackson2HttpMessageConverter constructor instantiate ObjectMapper uses Jackson2ObjectMapperBuilder create Jackson ObjectMapper based application configuration instead ObjectMapper created directly SpringDataWebConfiguration extendMessageConverters causes ProjectingJackson2HttpMessageConverter use Jackson configuration application properties create ObjectMapper possibility configure Jackson ObjectMapper also breaks MappingJackson2HttpMessageConverter configuration functionality solve issue ObjectMapper creation delegated MappingJackson2HttpMessageConverter default constructor Affects 1 13 6 Ingalls SR6 2 0 RC2 Kay Backported 1 13 7 Ingalls SR7,opened commented ProjectingJacksonHttpMessageConverter using default MappingJacksonHttpMessageConverter constructor instantiate ObjectMapper uses JacksonObjectMapperBuilder create Jackson ObjectMapper based application configuration instead ObjectMapper created directly SpringDataWebConfiguration extendMessageConverters causes ProjectingJacksonHttpMessageConverter use Jackson configuration application properties create ObjectMapper possibility configure Jackson ObjectMapper also breaks MappingJacksonHttpMessageConverter configuration functionality solve issue ObjectMapper creation delegated MappingJacksonHttpMessageConverter default constructor Affects    Ingalls SR   RC Kay Backported    Ingalls SR,opened commented ProjectingJacksonHttpMessageConverter using default MappingJacksonHttpMessageConverter constructor instantiate ObjectMapper uses JacksonObjectMapperBuilder create Jackson ObjectMapper based application configuration instead ObjectMapper created directly SpringDataWebConfiguration extendMessageConverters causes ProjectingJacksonHttpMessageConverter use Jackson configuration application properties create ObjectMapper possibility configure Jackson ObjectMapper also breaks MappingJacksonHttpMessageConverter configuration functionality solve issue ObjectMapper creation delegated MappingJacksonHttpMessageConverter default constructor Affects Ingalls SR RC Kay Backported Ingalls SR,1
0,Bears,Repositories expose registered repository proxy type DATACMNS 1215,opened commented Converting entity ID using DomainClassConverter ToIdConverter fails entity instance actually proxy DomainClassConverter ToIdConverter matches checks repository sourceType getType case Hibernate proxy type EntityClass jvst repository registered key EntityClass application inability convert proxy causes exception Thymeleaf template generation prevents page loading completely may possible know persistence provider return proxy raw entity example JpaRepository getOne method may return proxy may cause subsequent queries return proxies would helpful DomainClassConverter attempted least one additional match going one step class hierarchy sort like GenericConversionService Converters find entity class superclass proxy would prevent failure Affects 1 13 8 Ingalls SR8 Reference URL https stackoverflow com q 47318903 3179666 Backported 2 0 2 Kay SR2 1 13 9 Ingalls SR9,opened commented Converting entity ID using DomainClassConverter ToIdConverter fails entity instance actually proxy DomainClassConverter ToIdConverter matches checks repository sourceType getType case Hibernate proxy type EntityClass jvst repository registered key EntityClass application inability convert proxy causes exception Thymeleaf template generation prevents page loading completely may possible know persistence provider return proxy raw entity example JpaRepository getOne method may return proxy may cause subsequent queries return proxies would helpful DomainClassConverter attempted least one additional match going one step class hierarchy sort like GenericConversionService Converters find entity class superclass proxy would prevent failure Affects    Ingalls SR Reference URL https stackoverflow com q   Backported    Kay SR    Ingalls SR,opened commented Converting entity ID using DomainClassConverter ToIdConverter fails entity instance actually proxy DomainClassConverter ToIdConverter matches checks repository sourceType getType case Hibernate proxy type EntityClass jvst repository registered key EntityClass application inability convert proxy causes exception Thymeleaf template generation prevents page loading completely may possible know persistence provider return proxy raw entity example JpaRepository getOne method may return proxy may cause subsequent queries return proxies would helpful DomainClassConverter attempted least one additional match going one step class hierarchy sort like GenericConversionService Converters find entity class superclass proxy would prevent failure Affects Ingalls SR Reference URL https stackoverflow com q Backported Kay SR Ingalls SR,1
0,Bears,Exception compilation due constructor private visibility,Hello issue instrumenting source code AssertJ Spoon instrumentation part work compilation part fail due following error created small Maven project part AssertJ source code cannot instrument compile Spoon project architecture following According Exception message problems comes class BooleanArraysBaseTest contains following code statement arrays new BooleanArrays refers BooleanArrays class contained package internal Singleton constructor package visibility class also called BooleanArrays contained package test private constructor Launcher configuration following something wrong configuration managed instrument several projects one Tell need information archive containing project available Thank Thibault,Hello issue instrumenting source code AssertJ Spoon instrumentation part work compilation part fail due following error created small Maven project part AssertJ source code cannot instrument compile Spoon project architecture following According Exception message problems comes class BooleanArraysBaseTest contains following code statement arrays new BooleanArrays refers BooleanArrays class contained package internal Singleton constructor package visibility class also called BooleanArrays contained package test private constructor Launcher configuration following something wrong configuration managed instrument several projects one Tell need information archive containing project available Thank Thibault,Hello issue instrumenting source code AssertJ Spoon instrumentation part work compilation part fail due following error created small Maven project part AssertJ source code cannot instrument compile Spoon project architecture following According Exception message problems comes class BooleanArraysBaseTest contains following code statement arrays new BooleanArrays refers BooleanArrays class contained package internal Singleton constructor package visibility class also called BooleanArrays contained package test private constructor Launcher configuration following something wrong configuration managed instrument several projects one Tell need information archive containing project available Thank Thibault,1
0,Bears,Stop receiving records error Last request dispatched response Cancelling subscription restarting KCL 2 0,Kinesis stream 2 shards data published continuously use KCL 2 0 1 java connect stream polling populating retrievalConfig retrievalSpecificConfig PollingConfig object works completely fine keeps receiving messages shards first 10 minutes stops receiving message even data continuously published stream leave process running 5 minutes issue persists restart process starts receiving messages shards stops receiving messages running 10 minutes Issue happens repeatedly throttling error seen logs Instead following errors seen logs 2018 10 19 14 12 43 531 ERROR main shardId 000000000000 Last request dispatched 2018 10 19T03 12 07 772Z response 2018 10 19T03 12 43 531Z PT35 759S Cancelling subscription restarting kind logs appear every 35 seconds shard first appeared happened shardId 000000000000 messages received shard appeared shardId 000000000001 well message received shard isolate publishing factor done another test first published lots data stream without consuming stop publishing start consumer application behaviours observed behaviours observed KCL 2 0 3 extracted attached relevant application logs error logs reference app log error log idea,Kinesis stream  shards data published continuously use KCL    java connect stream polling populating retrievalConfig retrievalSpecificConfig PollingConfig object works completely fine keeps receiving messages shards first  minutes stops receiving message even data continuously published stream leave process running  minutes issue persists restart process starts receiving messages shards stops receiving messages running  minutes Issue happens repeatedly throttling error seen logs Instead following errors seen logs        ERROR main shardId  Last request dispatched   T   Z response   T   Z PT S Cancelling subscription restarting kind logs appear every  seconds shard first appeared happened shardId  messages received shard appeared shardId  well message received shard isolate publishing factor done another test first published lots data stream without consuming stop publishing start consumer application behaviours observed behaviours observed KCL    extracted attached relevant application logs error logs reference app log error log idea,Kinesis stream shards data published continuously use KCL java connect stream polling populating retrievalConfig retrievalSpecificConfig PollingConfig object works completely fine keeps receiving messages shards first minutes stops receiving message even data continuously published stream leave process running minutes issue persists restart process starts receiving messages shards stops receiving messages running minutes Issue happens repeatedly throttling error seen logs Instead following errors seen logs ERROR main shardId Last request dispatched Z response Z PT Cancelling subscription restarting kind logs appear every seconds shard first appeared happened shardId messages received shard appeared shardId well message received shard isolate publishing factor done another test first published lots data stream without consuming stop publishing start consumer application behaviours observed behaviours observed KCL extracted attached relevant application logs error logs reference app log error log idea,1
0,Bears,Blank map pointer tracker sending vibration alarm,Hello Im happy traccar platform got strange issue got 40 trackers connected 2 missing map pointers noticed 2 trackers marked ´vibration´ alarm ignition bug something wrong trackers running h02 protocol Thanks,Hello Im happy traccar platform got strange issue got  trackers connected  missing map pointers noticed  trackers marked ´vibration´ alarm ignition bug something wrong trackers running h protocol Thanks,Hello Im happy traccar platform got strange issue got trackers connected missing map pointers noticed trackers marked ´vibration´ alarm ignition bug something wrong trackers running h protocol Thanks,1
0,Bears,Variable called java messes imports,Hello Spooning JUnit4 source code following class variable named java String java System getProperty java home File separator bin File separator java configured launcher launcher getEnvironment setAutoImports false running launcher following code generated java lang String java java lang System getProperty java home java io File separator bin java io File separator java completely normal compilation fail java lang System refers java String declared earlier lang attribute obviously Since previous issue running Spoon using launcher getEnvironment setAutoImports false Since quite specific renaming Java variable source code bit time consuming multiple classes similar variable Thibault,Hello Spooning JUnit source code following class variable named java String java System getProperty java home File separator bin File separator java configured launcher launcher getEnvironment setAutoImports false running launcher following code generated java lang String java java lang System getProperty java home java io File separator bin java io File separator java completely normal compilation fail java lang System refers java String declared earlier lang attribute obviously Since previous issue running Spoon using launcher getEnvironment setAutoImports false Since quite specific renaming Java variable source code bit time consuming multiple classes similar variable Thibault,Hello Spooning JUnit source code following class variable named java String java System getProperty java home File separator bin File separator java configured launcher launcher getEnvironment setAutoImports false running launcher following code generated java lang String java java lang System getProperty java home java io File separator bin java io File separator java completely normal compilation fail java lang System refers java String declared earlier lang attribute obviously Since previous issue running Spoon using launcher getEnvironment setAutoImports false Since quite specific renaming Java variable source code bit time consuming multiple classes similar variable Thibault,1
0,Bears,true setOneIndexedParameters still behaves false links json response DATACMNS 563,opened commented setting true argument 1 accepted HTTP request indeed considered index first page json response still displays links first page indexed 0 example requesting page 3 gets page 3 links described ignoring index start 1 prev link show 2 next link show 4 stands next page link index current page request Affects 1 8 2 Dijkstra SR2 Referenced pull request 267 Backported 2 0 3 Kay SR3 1 13 10 Ingalls SR10,opened commented setting true argument  accepted HTTP request indeed considered index first page json response still displays links first page indexed  example requesting page  gets page  links described ignoring index start  prev link show  next link show  stands next page link index current page request Affects    Dijkstra SR Referenced pull request  Backported    Kay SR    Ingalls SR,opened commented setting true argument accepted HTTP request indeed considered index first page json response still displays links first page indexed example requesting page gets page links described ignoring index start prev link show next link show stands next page link index current page request Affects Dijkstra SR Referenced pull request Backported Kay SR Ingalls SR,1
0,Bears,cGuard protocol decoding issue,got pair cGuard Atom devices one 2015 another one 2016 trying install configure Traccar server inside Docker acquire data devices Traccar version 3 10 cGuard Atom fw 3 2 3 latest available server successfully detects new device 2017 04 09 03 06 43 WARN Unknown device 35338606530 couple minutes begins decode gps data However navi data seem decoded incorrectly testing time coordinates zeroes datetime mark correspond Unix epoch time etc see hex decoder Trackar site correctly decodes HEX parts data,got pair cGuard Atom devices one  another one  trying install configure Traccar server inside Docker acquire data devices Traccar version   cGuard Atom fw    latest available server successfully detects new device       WARN Unknown device  couple minutes begins decode gps data However navi data seem decoded incorrectly testing time coordinates zeroes datetime mark correspond Unix epoch time etc see hex decoder Trackar site correctly decodes HEX parts data,got pair cGuard Atom devices one another one trying install configure Traccar server inside Docker acquire data devices Traccar version cGuard Atom fw latest available server successfully detects new device WARN Unknown device couple minutes begins decode gps data However navi data seem decoded incorrectly testing time coordinates zeroes datetime mark correspond Unix epoch time etc see hex decoder Trackar site correctly decodes HEX parts data,1
0,Bears,AbstractPersistentProperty getRawType consider generics DATACMNS 1139,opened commented AbstractPersistentProperty getRawType currently uses field property descriptor type turn use generics resolution mechanism means generic fields get different results call getTypeInformation getType getRawType Affects 1 12 11 Hopper SR11 1 13 6 Ingalls SR6 2 0 RC2 Kay Backported 1 13 7 Ingalls SR7 1 12 12 Hopper SR12,opened commented AbstractPersistentProperty getRawType currently uses field property descriptor type turn use generics resolution mechanism means generic fields get different results call getTypeInformation getType getRawType Affects    Hopper SR    Ingalls SR   RC Kay Backported    Ingalls SR    Hopper SR,opened commented AbstractPersistentProperty getRawType currently uses field property descriptor type turn use generics resolution mechanism means generic fields get different results call getTypeInformation getType getRawType Affects Hopper SR Ingalls SR RC Kay Backported Ingalls SR Hopper SR,1
0,Bears,use provided pullRequestTitle creating PR,Summary Related societe generale ci droid 6 new pullRequestTitle field needs taken account creating PR Type Issue Motivation Current Behavior PR created takes commitMessage title dedicated field pullRequestTitle introduced model use Expected Behavior use pullRequestTitle provided otherwise use branch name PR title Steps Reproduce bugs Environment Version used 1 0 5 OS version Version libs used,Summary Related societe generale ci droid  new pullRequestTitle field needs taken account creating PR Type Issue Motivation Current Behavior PR created takes commitMessage title dedicated field pullRequestTitle introduced model use Expected Behavior use pullRequestTitle provided otherwise use branch name PR title Steps Reproduce bugs Environment Version used    OS version Version libs used,Summary Related societe generale ci droid new pullRequestTitle field needs taken account creating PR Type Issue Motivation Current Behavior PR created takes commitMessage title dedicated field pullRequestTitle introduced model use Expected Behavior use pullRequestTitle provided otherwise use branch name PR title Steps Reproduce bugs Environment Version used OS version Version libs used,1
0,Bears,YamlGenerator closes target stream configured,Bug description YamlGenerator closes target stream configured Versions used jackson dataformat yaml 2 9 2 jackson databind 2 9 6 Expected result target stream closed writing value output running reproduction script program Actual result target stream closed using YamlGenerator following output running reproduction script program Steps reproduce,Bug description YamlGenerator closes target stream configured Versions used jackson dataformat yaml    jackson databind    Expected result target stream closed writing value output running reproduction script program Actual result target stream closed using YamlGenerator following output running reproduction script program Steps reproduce,Bug description YamlGenerator closes target stream configured Versions used jackson dataformat yaml jackson databind Expected result target stream closed writing value output running reproduction script program Actual result target stream closed using YamlGenerator following output running reproduction script program Steps reproduce,1
0,Bears,Context must read system properties rewrite properties file,Context must read system properties rewrite properties file,Context must read system properties rewrite properties file,Context must read system properties rewrite properties file,1
0,Bears,ReactiveCommandSegmentCommandFactory resolves StreamingOutput reactive types,using Redis Lettuce dynamic client described official documentation https github com lettuce io lettuce core wiki Redis Command Interfaces command interfaces response types commands interface looks exactly problem method get cannot find value key exception thrown instead returning empty Mono using predefined RedisReactiveCommands get works fine returns empty Mono seems like bug Redis Lettuce version used Also checked 5 0 4 RELEASE issue remained,using Redis Lettuce dynamic client described official documentation https github com lettuce io lettuce core wiki Redis Command Interfaces command interfaces response types commands interface looks exactly problem method get cannot find value key exception thrown instead returning empty Mono using predefined RedisReactiveCommands get works fine returns empty Mono seems like bug Redis Lettuce version used Also checked    RELEASE issue remained,using Redis Lettuce dynamic client described official documentation https github com lettuce io lettuce core wiki Redis Command Interfaces command interfaces response types commands interface looks exactly problem method get cannot find value key exception thrown instead returning empty Mono using predefined RedisReactiveCommands get works fine returns empty Mono seems like bug Redis Lettuce version used Also checked RELEASE issue remained,1
0,Bears,Large HTML File conversion PDF hangs,Hi trying convert large HTML File approximately 600 pages passing conversion hangs Following observation debugging core PdfRendererBuilder class file following method call renderer layout action takes significant time completes process looked renderer createPDF trying create entire PDF memory document completion starts writing OutputStream write directly OutputStream page page think might solve problem Following code snippet please check anything wrong code snippet completing builder run process hangs Please help solution Thanks advance,Hi trying convert large HTML File approximately  pages passing conversion hangs Following observation debugging core PdfRendererBuilder class file following method call renderer layout action takes significant time completes process looked renderer createPDF trying create entire PDF memory document completion starts writing OutputStream write directly OutputStream page page think might solve problem Following code snippet please check anything wrong code snippet completing builder run process hangs Please help solution Thanks advance,Hi trying convert large HTML File approximately pages passing conversion hangs Following observation debugging core PdfRendererBuilder class file following method call renderer layout action takes significant time completes process looked renderer createPDF trying create entire PDF memory document completion starts writing OutputStream write directly OutputStream page page think might solve problem Following code snippet please check anything wrong code snippet completing builder run process hangs Please help solution Thanks advance,1
0,Bears,TracingP6SpyListener computing Tags DB TYPE properly,Type bugfix TracingP6SpyListener class line 112 take account url returned DatabaseMetaData null,Type bugfix TracingPSpyListener class line  take account url returned DatabaseMetaData null,Type bugfix TracingPSpyListener class line take account url returned DatabaseMetaData null,1
0,Bears,CtElementImpl getMetadataKeys throws NPE,get NPE invoking method getMetadataKeys CtElement Looking source code looks like metadata null null check return null like getMetadata method return empty set,get NPE invoking method getMetadataKeys CtElement Looking source code looks like metadata null null check return null like getMetadata method return empty set,get NPE invoking method getMetadataKeys CtElement Looking source code looks like metadata null null check return null like getMetadata method return empty set,1
0,Bears,Processor using templated type process method abstract class,define abstract spoon Processor declaring process method templated type create concrete class extending previous one problem concrete processors receiving every classes matches upper bound template,define abstract spoon Processor declaring process method templated type create concrete class extending previous one problem concrete processors receiving every classes matches upper bound template,define abstract spoon Processor declaring process method templated type create concrete class extending previous one problem concrete processors receiving every classes matches upper bound template,1
0,Bears,generic type Regression able spoon Guava,seems 1218 introduced regression Guava project used CI check behaviour Spoon see trace See full stack trace https ci inria fr sos job Guava 262 console,seems  introduced regression Guava project used CI check behaviour Spoon see trace See full stack trace https ci inria fr sos job Guava  console,seems introduced regression Guava project used CI check behaviour Spoon see trace See full stack trace https ci inria fr sos job Guava console,1
0,Bears,Persist fails entity without id version field EnableAuditing DATACMNS 957,opened commented Follow domain persist works long auditing turned putting EnableAuditing application follows exception thrown Description auditing enabled steps executed Determine strategy fill auditing fields Find fields filled via auditing Fill found fields strategy determined id version available domain exception thrown object persisted exception also thrown fields model filled via auditing need throw exception fields filled via auditing code make clear patch ticket PR 189 Issue Links Referenced pull request 189 Backported 1 13 GA Ingalls 1 12 7 Hopper SR7 1 11 7 Gosling SR7,opened commented Follow domain persist works long auditing turned putting EnableAuditing application follows exception thrown Description auditing enabled steps executed Determine strategy fill auditing fields Find fields filled via auditing Fill found fields strategy determined id version available domain exception thrown object persisted exception also thrown fields model filled via auditing need throw exception fields filled via auditing code make clear patch ticket PR  Issue Links Referenced pull request  Backported   GA Ingalls    Hopper SR    Gosling SR,opened commented Follow domain persist works long auditing turned putting EnableAuditing application follows exception thrown Description auditing enabled steps executed Determine strategy fill auditing fields Find fields filled via auditing Fill found fields strategy determined id version available domain exception thrown object persisted exception also thrown fields model filled via auditing need throw exception fields filled via auditing code make clear patch ticket PR Issue Links Referenced pull request Backported GA Ingalls Hopper SR Gosling SR,1
0,Bears,Improve identifier metadata detection XML based entity mappings DATAJPA 658,opened commented model POJO persistence configuration separated project orm xml file want expose persistence API detected entities configured annotated persistence annotations Id example cannot annotate entities come target model source code would great Spring Data REST configurable using orm xml files xml source apart annotations Thank Affects 1 7 1 Evans SR1 1 8 M1 Fowler Issue Links Referenced pull request 146 Backported 2 0 4 Kay SR4 1 11 11 Ingalls SR11 2 votes 6 watchers,opened commented model POJO persistence configuration separated project orm xml file want expose persistence API detected entities configured annotated persistence annotations Id example cannot annotate entities come target model source code would great Spring Data REST configurable using orm xml files xml source apart annotations Thank Affects    Evans SR   M Fowler Issue Links Referenced pull request  Backported    Kay SR    Ingalls SR  votes  watchers,opened commented model POJO persistence configuration separated project orm xml file want expose persistence API detected entities configured annotated persistence annotations Id example cannot annotate entities come target model source code would great Spring Data REST configurable using orm xml files xml source apart annotations Thank Affects Evans SR Fowler Issue Links Referenced pull request Backported Kay SR Ingalls SR votes watchers,1
0,Bears,mapping service mapping error toString value inserted integrated dataset,Reproduce Go mapping service Create new mapping project Add TypeTestRef new source Edit label attribute Fill Create integrated dataset Expected behaviour Mapping fails validation label label mapping contains script errors Observed behaviour mapping executed toString value error inserted label,Reproduce Go mapping service Create new mapping project Add TypeTestRef new source Edit label attribute Fill Create integrated dataset Expected behaviour Mapping fails validation label label mapping contains script errors Observed behaviour mapping executed toString value error inserted label,Reproduce Go mapping service Create new mapping project Add TypeTestRef new source Edit label attribute Fill Create integrated dataset Expected behaviour Mapping fails validation label label mapping contains script errors Observed behaviour mapping executed toString value error inserted label,1
0,Bears,Infinite recursion deserializing class extending Map recursive value type,Hello using jackson databind 2 8 8 class unusual definition extending Map values type class seems like facing infinite recursion issue reproduce use inspire class defined executing following code calling readValue mapper throws StackOverflowException stacktrace Looking briefly code seems like recursive definition class equals call MapLikeType may never get loop idea Thanks,Hello using jackson databind    class unusual definition extending Map values type class seems like facing infinite recursion issue reproduce use inspire class defined executing following code calling readValue mapper throws StackOverflowException stacktrace Looking briefly code seems like recursive definition class equals call MapLikeType may never get loop idea Thanks,Hello using jackson databind class unusual definition extending Map values type class seems like facing infinite recursion issue reproduce use inspire class defined executing following code calling readValue mapper throws StackOverflowException stacktrace Looking briefly code seems like recursive definition class equals call MapLikeType may never get loop idea Thanks,1
0,Bears,StdDateFormat deserializes dates tz offset UTC instead configured timezone,Prior version 2 8 9 dates without time zone time offset eg 1970 01 01T00 00 00 000 deserialised TimeZone set ObjectMapper Starting 2 8 9 dates deserialised UTC major breaking change behaviour Example,Prior version    dates without time zone time offset eg   T    deserialised TimeZone set ObjectMapper Starting    dates deserialised UTC major breaking change behaviour Example,Prior version dates without time zone time offset eg deserialised TimeZone set ObjectMapper Starting dates deserialised UTC major breaking change behaviour Example,1
0,Bears,ArrayIndexOutOfBoundsException impossible non static inner class constructor,Minimal repro Fails like Validation missing impossible constructor Works expected InnerSomething static,Minimal repro Fails like Validation missing impossible constructor Works expected InnerSomething static,Minimal repro Fails like Validation missing impossible constructor Works expected InnerSomething static,1
0,Bears,JsonIdentityReference used setup class,trying setup JsonIdentityInfo JsonIdentityReference order serialize references given class Object Id deserialize later using custom ObjectIdResolver retrieve proper referenced instance use JsonIdentityReference alwaysAsId true order enforce exporting object id cases work expected define annotation class works fine set directly property would rather define every property probably miss see BeanSerializerBase alwaysAsId reset ObjectIdInfo found accessor kept current value override found tried set back default ObjectIdInfo created NAME OBJECT REF sure right way fix test added TestObjectIdSerialization case,trying setup JsonIdentityInfo JsonIdentityReference order serialize references given class Object Id deserialize later using custom ObjectIdResolver retrieve proper referenced instance use JsonIdentityReference alwaysAsId true order enforce exporting object id cases work expected define annotation class works fine set directly property would rather define every property probably miss see BeanSerializerBase alwaysAsId reset ObjectIdInfo found accessor kept current value override found tried set back default ObjectIdInfo created NAME OBJECT REF sure right way fix test added TestObjectIdSerialization case,trying setup JsonIdentityInfo JsonIdentityReference order serialize references given class Object Id deserialize later using custom ObjectIdResolver retrieve proper referenced instance use JsonIdentityReference alwaysAsId true order enforce exporting object id cases work expected define annotation class works fine set directly property would rather define every property probably miss see BeanSerializerBase alwaysAsId reset ObjectIdInfo found accessor kept current value override found tried set back default ObjectIdInfo created NAME OBJECT REF sure right way fix test added TestObjectIdSerialization case,1
0,Bears,ACCEPT CASE INSENSITIVE PROPERTIES fails JsonUnwrapped,note moved FasterXML jackson dataformat csv 133 trying deserialize type like case insensitive mapper mapper enable MapperFeature ACCEPT CASE INSENSITIVE PROPERTIES get exception,note moved FasterXML jackson dataformat csv  trying deserialize type like case insensitive mapper mapper enable MapperFeature ACCEPT CASE INSENSITIVE PROPERTIES get exception,note moved FasterXML jackson dataformat csv trying deserialize type like case insensitive mapper mapper enable MapperFeature ACCEPT CASE INSENSITIVE PROPERTIES get exception,1
0,Bears,Missing properties deserializing using builder class non default constructor mutator annotated JsonUnwrapped,deserializing using builder class non default constructor number mutator methods annotated JsonUnwrapped BuilderBasedDeserializer deserializeUsingPropertyBasedWithUnwrapped method cuts short process adding SettableBeanProperties logic dictates properties necessary construct builder found builder constructed using known SettableBeanProperties found point tokenizing process Therefore case builder single property required construction property found anywhere end JSON content properties subsequent constructor property evaluated left default values Given following classes given following JSON string see following output However place emp id property end JSON string would get following output place emp age emp first name emp last name emp id property JSON string would get following output,deserializing using builder class non default constructor number mutator methods annotated JsonUnwrapped BuilderBasedDeserializer deserializeUsingPropertyBasedWithUnwrapped method cuts short process adding SettableBeanProperties logic dictates properties necessary construct builder found builder constructed using known SettableBeanProperties found point tokenizing process Therefore case builder single property required construction property found anywhere end JSON content properties subsequent constructor property evaluated left default values Given following classes given following JSON string see following output However place emp id property end JSON string would get following output place emp age emp first name emp last name emp id property JSON string would get following output,deserializing using builder class non default constructor number mutator methods annotated JsonUnwrapped BuilderBasedDeserializer deserializeUsingPropertyBasedWithUnwrapped method cuts short process adding SettableBeanProperties logic dictates properties necessary construct builder found builder constructed using known SettableBeanProperties found point tokenizing process Therefore case builder single property required construction property found anywhere end JSON content properties subsequent constructor property evaluated left default values Given following classes given following JSON string see following output However place emp id property end JSON string would get following output place emp age emp first name emp last name emp id property JSON string would get following output,1
0,Bears,NullPointerException ProjectingJackson2HttpMessageConverter DATACMNS 972,opened commented Managed get nullpointer switching spring boot 1 5 0 RC1 1 4 3 RELEASE Nullpointer happens rawType null type generic type like generic type targetClass initialised correctly using ResolvableType forMethodParameter parameter resolve spring new ProjectingJackson2HttpMessageConverter converter initialized first converter spring boot defines json path depenency spring Stacktrace Affects 1 13 RC1 Ingalls Reference URL https jira spring io browse DATACMNS 885 Attachments Backported 1 13 GA Ingalls,opened commented Managed get nullpointer switching spring boot    RC    RELEASE Nullpointer happens rawType null type generic type like generic type targetClass initialised correctly using ResolvableType forMethodParameter parameter resolve spring new ProjectingJacksonHttpMessageConverter converter initialized first converter spring boot defines json path depenency spring Stacktrace Affects   RC Ingalls Reference URL https jira spring io browse DATACMNS  Attachments Backported   GA Ingalls,opened commented Managed get nullpointer switching spring boot RC RELEASE Nullpointer happens rawType null type generic type like generic type targetClass initialised correctly using ResolvableType forMethodParameter parameter resolve spring new ProjectingJacksonHttpMessageConverter converter initialized first converter spring boot defines json path depenency spring Stacktrace Affects RC Ingalls Reference URL https jira spring io browse DATACMNS Attachments Backported GA Ingalls,1
0,Bears,issue isOverriding behavior extending TypeParameters,consider interface Iterable E contain method forEach Consumer super E create class extends String implements Iterable implement version forEach use ClassTypingContext isSameSignature two forEach methods return false type parameter really sure bug overriding method type parameter defined signature exactly use isSameSignature getAllMethods see 1375 get Iterable forEach ArrayList forEach using ArrayList WDYT consider signature consider getAllMethods indeed return two different methods Edit Actually extended test check isOverriding returns false obviously wrong real issue,consider interface Iterable E contain method forEach Consumer super E create class extends String implements Iterable implement version forEach use ClassTypingContext isSameSignature two forEach methods return false type parameter really sure bug overriding method type parameter defined signature exactly use isSameSignature getAllMethods see  get Iterable forEach ArrayList forEach using ArrayList WDYT consider signature consider getAllMethods indeed return two different methods Edit Actually extended test check isOverriding returns false obviously wrong real issue,consider interface Iterable E contain method forEach Consumer super E create class extends String implements Iterable implement version forEach use ClassTypingContext isSameSignature two forEach methods return false type parameter really sure bug overriding method type parameter defined signature exactly use isSameSignature getAllMethods see get Iterable forEach ArrayList forEach using ArrayList WDYT consider signature consider getAllMethods indeed return two different methods Edit Actually extended test check isOverriding returns false obviously wrong real issue,1
0,Bears,NPE DefaultJavaPrettyPrinter printCtFieldAccess,intel bug reproduction found following issue HabchiSarra SmellDetector 8 full stack trace using spoon 5 9 0 SNAPSHOT,intel bug reproduction found following issue HabchiSarra SmellDetector  full stack trace using spoon    SNAPSHOT,intel bug reproduction found following issue HabchiSarra SmellDetector full stack trace using spoon SNAPSHOT,1
0,Bears,JsonProperty access READ together generated constructor lombok causes JsonMappingException Could find creator property name,following class fails deserialise com fasterxml jackson databind JsonMappingException Could find creator property name class LombokObject Whereas following class functionally identical constructors getters setters code deserialised exception,following class fails deserialise com fasterxml jackson databind JsonMappingException Could find creator property name class LombokObject Whereas following class functionally identical constructors getters setters code deserialised exception,following class fails deserialise com fasterxml jackson databind JsonMappingException Could find creator property name class LombokObject Whereas following class functionally identical constructors getters setters code deserialised exception,1
0,Bears,Object Id found instance using ConstructorProperties,Hi recently migrated 2 4 6 2 8 1 encountered issue use lombok AllArgsConstructor adds ConstructorProperties constructor also used JsonIdentityInfo POJO lead JsonMappingException Object Id found instance exception following test code demonstrates issue Stack trace Prior version 2 5 0 issue offending method com fasterxml jackson databind deser impl PropertyValueBuffer handleIdValue DeserializationContext Object comment TODO error case nothing else,Hi recently migrated       encountered issue use lombok AllArgsConstructor adds ConstructorProperties constructor also used JsonIdentityInfo POJO lead JsonMappingException Object Id found instance exception following test code demonstrates issue Stack trace Prior version    issue offending method com fasterxml jackson databind deser impl PropertyValueBuffer handleIdValue DeserializationContext Object comment TODO error case nothing else,Hi recently migrated encountered issue use lombok AllArgsConstructor adds ConstructorProperties constructor also used JsonIdentityInfo POJO lead JsonMappingException Object Id found instance exception following test code demonstrates issue Stack trace Prior version issue offending method com fasterxml jackson databind deser impl PropertyValueBuffer handleIdValue DeserializationContext Object comment TODO error case nothing else,1
0,Bears,Jackson Deserializer security vulnerability via default typing CVE 2017 7525,send email info fasterxml com,send email info fasterxml com,send email info fasterxml com,1
0,Bears,Missing properties base class recursive types involved,type hierarchy follows constructed base class type constructed first TypeFactory serializing sub class fails due missing properties base class Serializes sub sub 2 base 1 sub 2 expected created minimal scenario bug https github com slobo showbie jackson recursive type bug experienced bug 2 7 8 2 8 8 2 8 8 1,type hierarchy follows constructed base class type constructed first TypeFactory serializing sub class fails due missing properties base class Serializes sub sub  base  sub  expected created minimal scenario bug https github com slobo showbie jackson recursive type bug experienced bug          ,type hierarchy follows constructed base class type constructed first TypeFactory serializing sub class fails due missing properties base class Serializes sub sub base sub expected created minimal scenario bug https github com slobo showbie jackson recursive type bug experienced bug,1
0,Bears,use parameters configured dubbo provider routing rules rules matched,如果将参数添加到dubbo provider中 例如 dubbo provider serialization fastjson 这样生成的url中会带有 default serialization fastjson 这样的参数 如果路由规则设置为 serialization fastjson 是无法过滤出带有 default serialization fastjson 的提供者的,如果将参数添加到dubbo provider中 例如 dubbo provider serialization fastjson 这样生成的url中会带有 default serialization fastjson 这样的参数 如果路由规则设置为 serialization fastjson 是无法过滤出带有 default serialization fastjson 的提供者的,如果将参数添加到dubbo provider中 例如 dubbo provider serialization fastjson 这样生成的url中会带有 default serialization fastjson 这样的参数 如果路由规则设置为 serialization fastjson 是无法过滤出带有 default serialization fastjson 的提供者的,1
0,Bears,upload data one row data uploaded,Reproduce Upload advanced importer add mode eric de test model xlsx Upload csv zip eu bbmri eric DE biobanks csv zip Expected behavior 1 row added biobanks table Observed behavior Import succeeds 0 rows imported,Reproduce Upload advanced importer add mode eric de test model xlsx Upload csv zip eu bbmri eric DE biobanks csv zip Expected behavior  row added biobanks table Observed behavior Import succeeds  rows imported,Reproduce Upload advanced importer add mode eric de test model xlsx Upload csv zip eu bbmri eric DE biobanks csv zip Expected behavior row added biobanks table Observed behavior Import succeeds rows imported,1
0,Bears,NativeQuery Pagination validation error startup DATAJPA 928,opened commented According Example 50 Using Query docs possible use native query pagination using Pageable case failing org springframework data jpa repository query InvalidJpaQueryMethodException NativeJpaQuery constructor checking query Pageable parameter queryString contains pageable sort sequence query Pageable parameter contain pageable string provide pageable string end query validation passes query executes fails saying expecting 3 parameters instead 2 Funny thing server starting set breakpoint inside NativeJpaQuery change containsPageableOrSortInQueryExpression false true manually validation passes fine query executes well paginating Affects 1 10 1 Hopper SR1 1 10 2 Hopper SR2 Reference URL http stackoverflow com questions 38349930 spring data native query pagination Issue Links Referenced pull request 246 commits Backported 2 0 4 Kay SR4 1 votes 12 watchers,opened commented According Example  Using Query docs possible use native query pagination using Pageable case failing org springframework data jpa repository query InvalidJpaQueryMethodException NativeJpaQuery constructor checking query Pageable parameter queryString contains pageable sort sequence query Pageable parameter contain pageable string provide pageable string end query validation passes query executes fails saying expecting  parameters instead  Funny thing server starting set breakpoint inside NativeJpaQuery change containsPageableOrSortInQueryExpression false true manually validation passes fine query executes well paginating Affects    Hopper SR    Hopper SR Reference URL http stackoverflow com questions  spring data native query pagination Issue Links Referenced pull request  commits Backported    Kay SR  votes  watchers,opened commented According Example Using Query docs possible use native query pagination using Pageable case failing org springframework data jpa repository query InvalidJpaQueryMethodException NativeJpaQuery constructor checking query Pageable parameter queryString contains pageable sort sequence query Pageable parameter contain pageable string provide pageable string end query validation passes query executes fails saying expecting parameters instead Funny thing server starting set breakpoint inside NativeJpaQuery change containsPageableOrSortInQueryExpression false true manually validation passes fine query executes well paginating Affects Hopper SR Hopper SR Reference URL http stackoverflow com questions spring data native query pagination Issue Links Referenced pull request commits Backported Kay SR votes watchers,1
0,Bears,StackOverflowError Dynamic StdKeySerializer,seem problem checked seem fixed latest version serialize method Dynamic static class StdKeySerializer problem comes fact ser null new ser returned findAndAddDynamic incorrectly filled say ser 1 ser 1 dynamicSerializers correct PropertySerializerMap Single However result serializer dynamicSerializers PropertySerializerMap Empty Therefore new call result ser 2 made ends creating infinite loop Possible fix replace mistaken please let know seems obvious debugging something working intended,seem problem checked seem fixed latest version serialize method Dynamic static class StdKeySerializer problem comes fact ser null new ser returned findAndAddDynamic incorrectly filled say ser  ser  dynamicSerializers correct PropertySerializerMap Single However result serializer dynamicSerializers PropertySerializerMap Empty Therefore new call result ser  made ends creating infinite loop Possible fix replace mistaken please let know seems obvious debugging something working intended,seem problem checked seem fixed latest version serialize method Dynamic static class StdKeySerializer problem comes fact ser null new ser returned findAndAddDynamic incorrectly filled say ser ser dynamicSerializers correct PropertySerializerMap Single However result serializer dynamicSerializers PropertySerializerMap Empty Therefore new call result ser made ends creating infinite loop Possible fix replace mistaken please let know seems obvious debugging something working intended,1
=======
0,Math,ListPopulation Iterator allows you to remove chromosomes from the population ,Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list Before returning the iterator we should wrap it in an unmodifiable list ,Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list Before returning the iterator we should wrap it in an unmodifiable list ,Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list Before returning the iterator we should wrap it in an unmodifiable list ,1
0,Math,BisectionSolver solve final UnivariateRealFunction f double min double max double initial  throws NullPointerException,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial  invokes BisectionSolver solve double min double max  which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max  should be called Steps to reproduce: invoke: new BisectionSolver   solve someUnivariateFunctionImpl 0 0 1 0 0 5 ; NullPointerException will be thrown ,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial  invokes BisectionSolver solve double min double max  which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max  should be called Steps to reproduce: invoke: new BisectionSolver   solve someUnivariateFunctionImpl       ; NullPointerException will be thrown ,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max should be called Steps to reproduce: invoke: new BisectionSolver solve someUnivariateFunctionImpl ; NullPointerException will be thrown ,1
0,Math,Complex ZERO reciprocal   returns NaN but should return INF ,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math3 complex Complex; Method: reciprocal    version Id: Complex java 1416643 2012-12-03 19:37:14Z tn,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal    version Id: Complex java   ::Z tn,Complex ZERO reciprocal returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal version Id: Complex java ::Z tn,1
0,Math,Fix and then deprecate isSupportXxxInclusive in RealDistribution interface,The conclusion from [1] was never implemented We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4 0 we should agree on a precise definition and fix the code to match it in the mean time The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite i e not infinite  not NaN value is returned [1] http: markmail org message dxuxh7eybl7xejde,The conclusion from [] was never implemented We should deprecate these properties from the RealDistribution interface but since removal will have to wait until   we should agree on a precise definition and fix the code to match it in the mean time The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite i e not infinite  not NaN value is returned [] http: markmail org message dxuxheyblxejde,The conclusion from [] was never implemented We should deprecate these properties from the RealDistribution interface but since removal will have to wait until we should agree on a precise definition and fix the code to match it in the mean time The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite i e not infinite not NaN value is returned [] http: markmail org message dxuxheyblxejde,1
0,Time,Inconsistent interpretation of ambiguous time during DST,The inconsistency appears for timezone Europe London These three DateTime objects should all represent the same moment in time even if they are ambiguous Now it always returns the earlier instant summer time  during an overlap ,The inconsistency appears for timezone Europe London These three DateTime objects should all represent the same moment in time even if they are ambiguous Now it always returns the earlier instant summer time  during an overlap ,The inconsistency appears for timezone Europe London These three DateTime objects should all represent the same moment in time even if they are ambiguous Now it always returns the earlier instant summer time during an overlap ,1
0,Lang,NullPointerException in isAvailableLocale Locale ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source  and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source and if availableLocaleSet hasn t been called it will cause a NullPointerException ,1
0,Closure,Closure removes needed code ,None,None,None,1
0,Closure,Use  public tag to prevent compression of symbol names,None,None,None,1
0,Closure,if statement,None,None,None,1
0,Closure,Cannot exclude globalThis checks through command line,None,None,None,1
0,Closure,bug with implicit namespaces across modules,None,None,None,1
0,Closure, enum does not type correctly,None,None,None,1
0,Closure,Typos in externs html5 js,None,None,None,1
0,Closure,Optimisation: convert array join   to array join  ,None,None,None,1
0,Closure,Cryptic error message on invalid  type function annotation,None,None,None,1
0,Closure,Compiler gives false error with respect to unreachable code,None,None,None,1
0,Closure,compiler crashes when goog provide used with non string,None,None,None,1
0,Closure,Preserve doesn t preserve whitespace at start of line,None,None,None,1
0,Closure,assignment to object in conditional causes type error on function w record type return type,None,None,None,1
0,Closure,compiler assumes that arguments can be shadowed,None,None,None,1
0,Closure,Compiler should warn error when instance methods are operated on,None,None,None,1
0,Closure,Last warning or error in output is truncated,None,None,None,1
0,Closure,Array Join Munged Incorrectly,None,None,None,1
0,Closure,-0 0 becomes 0 even in whitespace mode,None,None,None,1
0,Closure,Online CC bug: report java error ,None,None,None,1
0,Closure,Exception when parsing erroneous jsdoc:  return { code foo} bar baz ,None,None,None,1
0,Closure,Advanced compilations renames a function and then deletes it leaving a reference to a renamed but non-existent function,None,None,None,1
0,Closure,closure-compiler  define annotation does not allow line to be split on 80 characters ,None,None,None,1
0,Closure,void function   {}  ; wrongly identified as having no side effects,None,None,None,1
0,Closure,StackOverflowError exception when running closure compiler javascript attached ,None,None,None,1
0,Closure,weird object literal invalid property error on unrelated object prototype,None,None,None,1
0,Closure,String conversion optimization is incorrect,None,None,None,1
0,Closure,Dependency sorting with closurePass set to false no longer works ,None,None,None,1
0,Closure,Error trying to build try-catch block AST ,None,None,None,1
0,Closure,Compiler fails to find amd module in a subdirectory,None,None,None,1
0,Closure,Record type invalid property not reported on function with  this annotation,None,None,None,1
0,Closure,Bad type inference with goog isFunction and friends,None,None,None,1
0,Closure,closure compiler screws up a perfectly valid isFunction   implementation,None,None,None,1
0,Closure,JSCompiler does not recursively resolve typedefs,None,None,None,1
0,Closure,Casting a function before calling it produces bad code and breaks plugin code,None,None,None,1
0,Closure,Simple Whitespace only compression removing each keyword from for each var x in arr  loop,None,None,None,1
0,Closure,Compiler removes function properties that it should not,None,None,None,1
0,Closure,Erroneous optimization in ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,Assignment removed when used as an expression result to Array push,None,None,None,1
0,Closure,goog isArray doesn t hint compiler,None,None,None,1
0,Closure,Codepoint U 007f appears raw in output,None,None,None,1
0,Closure,Prototype method incorrectly removed,None,None,None,1
0,Closure,IE8 error: Object doesn t support this action,None,None,None,1
0,Closure,Break in finally block isn t optimized properly,None,None,None,1
0,Closure,Unexpected expression nodeDELPROP 1,None,None,None,1
0,Closure,Obvious optimizations don t works in inline if ,None,None,None,1
0,Closure,Overzealous optimization confuses variables,None,None,None,1
0,Closure,better this type checking,None,None,None,1
0,Closure,constant functions not inlined aggressively enough,None,None,None,1
0,Closure, const dumps type cast information,None,None,None,1
0,Closure,function arguments should not be optimized away,None,None,None,1
0,Closure,Wrong code generated if mixing types in ternary operator,None,None,None,1
0,Closure,Type refining of this raises IllegalArgumentException,None,None,None,1
0,Closure,ProcessCommonJSModules module exports failures when checkTypes enabled,None,None,None,1
0,Closure,Obfuscated code triggers TypeError in Firefox,None,None,None,1
0,Closure,Classify non-rightmost expressions as problematic,None,None,None,1
0,Closure,closure compiled swfobject error,None,None,None,1
0,Closure,An unnamed function statement statements should generate a parse error,None,None,None,1
0,Closure,Overzealous optimization confuses variables,None,None,None,1
0,Closure,catch e  yields JSC UNDEFINED NAME warning when e is used in catch in advanced mode,None,None,None,1
0,Closure,side-effects analysis incorrectly removing function calls with side effects,None,None,None,1
0,Closure,Internal Compiler Error on Bullet,None,None,None,1
0,Closure,Break in finally block isn t optimized properly,None,None,None,1
0,Closure,alert  ,None,None,None,1
0,Closure,Allow  private top-level functions in goog scope,None,None,None,1
0,Closure, lends does not work unless class is defined beforehand,None,None,None,1
0,Closure,The compiler quotes the 0 keys in object literals,None,None,None,1
0,Closure,Incorrect assignment removal from expression in simple mode ,None,None,None,1
0,Closure,Wrong type name reported on missing property error ,None,None,None,1
0,Closure,Identifier minus a negative number needs a space between the - s,None,None,None,1
0,Closure,goog addSingletonGetter prevents unused class removal,None,None,None,1
0,Closure,Add support for --manage closure dependencies and --only closure dependencies with compilation level WHITESPACE ONLY,None,None,None,1
0,Closure,unicode characters in property names result in invalid output,None,None,None,1
0,Closure,support  lends annotation,None,None,None,1
0,Closure,String escaping mishandles null byte,None,None,None,1
0,Closure,Column-indicating caret is sometimes not in error output,None,None,None,1
0,Closure,Missing type-checks for var args notation,None,None,None,1
0,Closure,Constructor types that return all or unknown fail to parse,None,None,None,1
0,Closure,Only assignment to this issues a dangerous use of the global this object warning ,None,None,None,1
0,Closure,Prototype methods can t be used from the constructor in case prototype is explicitly defined ,None,None,None,1
0,Closure,Variable names prefixed with MSG cause error with advanced optimizations,None,None,None,1
0,Closure,bad variable inlining in closure,None,None,None,1
0,Closure,compiler-20110811 crashes with index 1  must be less than size 1 ,None,None,None,1
0,Closure,Combining temporary strings are over-optimized in advanced build,None,None,None,1
0,Closure,incomplete function definition crashes the compiler when ideMode is enabled,None,None,None,1
0,Closure,externExport with  typedef can generate invalid externs,None,None,None,1
0,Closure,Exception thrown from com google javascript jscomp CollapseProperties addStubsForUndeclaredProperties,None,None,None,1
0,Closure,Prototypes declared with quotes produce a JSC USED GLOBAL THIS warning ,None,None,None,1
0,Closure,Converts string properties into numbers in literal object definitions,None,None,None,1
0,Closure,--process closure primitives can t be set to false,None,None,None,1
0,Closure,Exception when emitting code containing getters,None,None,None,1
0,Closure,Unsigned Shift Right >>>  bug operating on negative numbers,None,None,None,1
0,Closure,precondition crash: goog scope local with aliased in the type declaration,None,None,None,1
0,Closure,arguments is moved to another scope,None,None,None,1
0,Closure,--language in=ECMASCRIPT5 STRICT results in 1 use strict per input file,None,None,None,1
0,Closure, this emits warning when used with a typedef,None,None,None,1
0,Closure,ClassCastException during TypeCheck pass,None,None,None,1
0,Closure,RuntimeException when compiling with extern prototype,None,None,None,1
0,Closure,Template types on methods incorrectly trigger inference of a template on the class if that template type is unknown,None,None,None,1
0,Closure,In ADVANCED mode Compiler fails to warn about overridden methods with different signatures ,None,None,None,1
0,Closure,Erroneous optimization in ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,Cannot see version with --version,None,None,None,1
0,Closure,\0 \x00 and \u0000 are translated to null character,None,None,None,1
0,Closure,Generates code with invalid for in left-hand assignment,None,None,None,1
0,Closure,Type checking error when replacing a function with a stub after calling ,None,None,None,1
0,Closure,unexpected typed coverage of less than 100 ,None,None,None,1
0,Closure,Invalid left-hand side of assignment not detected,None,None,None,1
0,Closure,Different output from RestAPI and command line jar,None,None,None,1
0,Closure,goog scope doesn t properly check declared functions,None,None,None,1
0,Closure,tryFoldArrayAccess does not check for side effects,None,None,None,1
0,Closure,Converting from an interface type to a constructor which  implements itself causes stack overflow ,None,None,None,1
0,Closure,Switched order of delete key and key in statements changes semantic,None,None,None,1
0,Closure,optimization fails with variable in catch clause,None,None,None,1
0,Closure,Try catch blocks incorporate code not inside original blocks,None,None,None,1
0,Closure,Reproduceable crash with switch statement,None,None,None,1
0,Closure,no warnings when  private prop is redeclared on subclass,None,None,None,1
0,Closure,IllegalStateException at com google javascript rhino jstype FunctionType getInstanceType,None,None,None,1
0,Closure,Assignments within conditions are sometimes incorrectly removed,None,None,None,1
0,Closure, indexOf fails to produce missing property warning,None,None,None,1
0,Closure,Incorrect output if a function is assigned to a variable and the function contains a variable with the same name,None,None,None,1
0,Closure,Inconsistent handling of non-JSDoc comments,None,None,None,1
0,Closure,smartNameRemoval causing compiler crash,None,None,None,1
0,Closure,Crash on the web closure compiler,None,None,None,1
0,Closure,Original source line numbers are one-based in source maps ,None,None,None,1
0,Closure,Bug in require calls processing,None,None,None,1
0,Closure,division by zero wrongly throws JSC DIVIDE BY 0 ERROR,None,None,None,1
0,Closure,combining  interface and multiple  extends can crash compiler,None,None,None,1
0,Closure,true false are not always replaced for 0 1,None,None,None,1
0,Closure,Compiler ignores delete statements can break functionality ,None,None,None,1
0,Closure,bogus missing return warning,None,None,None,1
0,Closure,Classify non-rightmost expressions as problematic,None,None,None,1
0,Closure,anonymous object type inference behavior is different when calling constructors,None,None,None,1
0,Chart,Error on TimeSeries createCopy   method,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart 1 0 7,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart   ,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart ,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2 ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path1 GeneralPath path2  will thus return true for any pair of non-null GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path  will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,1
0,Chart,Bug propgated from v1 0 5 on to present,The method getRowCount   in class org jfree data category DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset possibly zero  The implementation from v1 0 5 on no longer checks for a null condition which would then return a zero  on the seriesKeys as it did in v1 0 4 and previous This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount   method is called ,The method getRowCount   in class org jfree data category DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset possibly zero  The implementation from v   on no longer checks for a null condition which would then return a zero  on the seriesKeys as it did in v   and previous This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount   method is called ,The method getRowCount in class org jfree data category DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset possibly zero The implementation from v on no longer checks for a null condition which would then return a zero on the seriesKeys as it did in v and previous This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount method is called ,1
0,Chart,cloning of TimeSeries,It s just a minor bug When I clone a TimeSeries which has no items I get an IllegalArgumentException Requires start <= end   But I don t think the user should be responsible for checking whether the TimeSeries has any items or not ,It s just a minor bug When I clone a TimeSeries which has no items I get an IllegalArgumentException Requires start <= end   But I don t think the user should be responsible for checking whether the TimeSeries has any items or not ,It s just a minor bug When I clone a TimeSeries which has no items I get an IllegalArgumentException Requires start <= end But I don t think the user should be responsible for checking whether the TimeSeries has any items or not ,1
0,Chart,Potential NPE in AbstractCategoryItemRender getLegendItems  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null not if dataset = null ,1
0,Chart,Fix for MultiplePiePlot,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,1
0,Chart,Bugs in DatasetUtilities iterateRangeBounds   methods,None,None,None,1
0,Chart,XYSeries addOrUpdate   should add if duplicates are allowed,I ve found a bug in jfreechart-1 0 9 code for org jfree data xy XYSeries There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data The method addOrUpdate Number x Number y  was never modified to support this and therefore duplicate data were overwriting existing data ,I ve found a bug in jfreechart   code for org jfree data xy XYSeries There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data The method addOrUpdate Number x Number y  was never modified to support this and therefore duplicate data were overwriting existing data ,I ve found a bug in jfreechart code for org jfree data xy XYSeries There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data The method addOrUpdate Number x Number y was never modified to support this and therefore duplicate data were overwriting existing data ,1
0,Math,Dangerous code in PoissonDistributionImpl ,In the following excerpt from class PoissonDistributionImpl : PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z  { super  ; setNormal z ; setMean p ; } 1  Overridable methods are called within the constructor 2  The reference z is stored and modified within the class I ve encountered problem 1  in several classes while working on issue 348 In those cases in order to remove potential problems I copied pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether i e make the classes immutable  Problem 2  can also create unexpected behaviour Is it really necessary to pass the NormalDistribution object; can t it be always created within the class ,In the following excerpt from class PoissonDistributionImpl : PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z  { super  ; setNormal z ; setMean p ; }   Overridable methods are called within the constructor   The reference z is stored and modified within the class I ve encountered problem   in several classes while working on issue  In those cases in order to remove potential problems I copied pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether i e make the classes immutable  Problem   can also create unexpected behaviour Is it really necessary to pass the NormalDistribution object; can t it be always created within the class ,In the following excerpt from class PoissonDistributionImpl : PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z { super ; setNormal z ; setMean p ; } Overridable methods are called within the constructor The reference z is stored and modified within the class I ve encountered problem in several classes while working on issue In those cases in order to remove potential problems I copied pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether i e make the classes immutable Problem can also create unexpected behaviour Is it really necessary to pass the NormalDistribution object; can t it be always created within the class ,1
0,Math,denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils bracket,We are using the FDistributionImpl from the commons math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval Everything is working fine and the results are matching our reference calculations However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0 95 This results in an IllegalArgumentsException stating: Invalid endpoint parameters: lowerBound=0 0 initial=Infinity upperBound=1 7976931348623157E308 coming from org apache commons math analysis UnivariateRealSolverUtils bracket The problem is the initial parameter to that function wich is POSITIVE INFINITY and therefore not within the boundaries I already pinned down the problem to the FDistributions getInitialDomain  -method wich goes like: return getDenominatorDegreesOfFreedom   getDenominatorDegreesOfFreedom   - 2 0 ; Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE INFINITY The result of this operation is then directly passed into the UnivariateRealSolverUtils bracket   - method as second argument ,We are using the FDistributionImpl from the commons math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval Everything is working fine and the results are matching our reference calculations However the FDistribution behaves strange if a denominatorDegreeOfFreedom of  is used with an alphavalue of   This results in an IllegalArgumentsException stating: Invalid endpoint parameters: lowerBound=  initial=Infinity upperBound= E coming from org apache commons math analysis UnivariateRealSolverUtils bracket The problem is the initial parameter to that function wich is POSITIVE INFINITY and therefore not within the boundaries I already pinned down the problem to the FDistributions getInitialDomain  method wich goes like: return getDenominatorDegreesOfFreedom   getDenominatorDegreesOfFreedom      ; Obviously in case of denominatorDegreesOfFreedom ==  this must lead to a divisionbyzero resulting in POSTIVE INFINITY The result of this operation is then directly passed into the UnivariateRealSolverUtils bracket    method as second argument ,We are using the FDistributionImpl from the commons math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval Everything is working fine and the results are matching our reference calculations However the FDistribution behaves strange if a denominatorDegreeOfFreedom of is used with an alphavalue of This results in an IllegalArgumentsException stating: Invalid endpoint parameters: lowerBound= initial=Infinity upperBound= E coming from org apache commons math analysis UnivariateRealSolverUtils bracket The problem is the initial parameter to that function wich is POSITIVE INFINITY and therefore not within the boundaries I already pinned down the problem to the FDistributions getInitialDomain method wich goes like: return getDenominatorDegreesOfFreedom getDenominatorDegreesOfFreedom ; Obviously in case of denominatorDegreesOfFreedom == this must lead to a divisionbyzero resulting in POSTIVE INFINITY The result of this operation is then directly passed into the UnivariateRealSolverUtils bracket method as second argument ,1
0,Math,FastMath max 50 0f -50 0f  => -50 0f; should be 50 0f,FastMath max 50 0f -50 0f  => -50 0f; should be 50 0f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat   because that has a bug too - it tests doubles not floats ,FastMath max  f  f  =>  f; should be  f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat   because that has a bug too  it tests doubles not floats ,FastMath max f f => f; should be f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat because that has a bug too it tests doubles not floats ,1
0,Math,MathUtils binomialCoefficient n k  fails for large results,Probably due to rounding errors MathUtils binomialCoefficient n k  fails for results near Long MAX VALUE The existence of failures can be demonstrated by testing the recursive property: assertEquals MathUtils binomialCoefficient 65 32  MathUtils binomialCoefficient 65 33  MathUtils binomialCoefficient 66 33 ; Or by directly using the externally calculated and hopefully correct  expected value: assertEquals 7219428434016265740L MathUtils binomialCoefficient 66 33 ; I suggest a nonrecursive test implementation along the lines of MathUtilsTest java Exact implementation using BigInteger and the explicit formula n k  == k-1  n  1 n-k  public static long binomialCoefficient int n int k  { if k == 0 || k == n  return 1; BigInteger result = BigInteger ONE; for int i = k 1; i <= n; i   { result = result multiply BigInteger valueOf i ; } for int i = 1; i <= n - k; i   { result = result divide BigInteger valueOf i ; } if result compareTo BigInteger valueOf Long MAX VALUE  > 0  { throw new ArithmeticException Binomial coefficient overflow: n k ; } return result longValue  ; } Which would allow you to test the expected values directly: assertEquals binomialCoefficient 66 33  MathUtils binomialCoefficient 66 33 ;,Probably due to rounding errors MathUtils binomialCoefficient n k  fails for results near Long MAX VALUE The existence of failures can be demonstrated by testing the recursive property: assertEquals MathUtils binomialCoefficient    MathUtils binomialCoefficient    MathUtils binomialCoefficient   ; Or by directly using the externally calculated and hopefully correct  expected value: assertEquals L MathUtils binomialCoefficient   ; I suggest a nonrecursive test implementation along the lines of MathUtilsTest java Exact implementation using BigInteger and the explicit formula n k  == k  n   nk  public static long binomialCoefficient int n int k  { if k ==  || k == n  return ; BigInteger result = BigInteger ONE; for int i = k ; i <= n; i   { result = result multiply BigInteger valueOf i ; } for int i = ; i <= n  k; i   { result = result divide BigInteger valueOf i ; } if result compareTo BigInteger valueOf Long MAX VALUE  >   { throw new ArithmeticException Binomial coefficient overflow: n k ; } return result longValue  ; } Which would allow you to test the expected values directly: assertEquals binomialCoefficient    MathUtils binomialCoefficient   ;,Probably due to rounding errors MathUtils binomialCoefficient n k fails for results near Long MAX VALUE The existence of failures can be demonstrated by testing the recursive property: assertEquals MathUtils binomialCoefficient MathUtils binomialCoefficient MathUtils binomialCoefficient ; Or by directly using the externally calculated and hopefully correct expected value: assertEquals L MathUtils binomialCoefficient ; I suggest a nonrecursive test implementation along the lines of MathUtilsTest java Exact implementation using BigInteger and the explicit formula n k == k n nk public static long binomialCoefficient int n int k { if k == || k == n return ; BigInteger result = BigInteger ONE; for int i = k ; i <= n; i { result = result multiply BigInteger valueOf i ; } for int i = ; i <= n k; i { result = result divide BigInteger valueOf i ; } if result compareTo BigInteger valueOf Long MAX VALUE > { throw new ArithmeticException Binomial coefficient overflow: n k ; } return result longValue ; } Which would allow you to test the expected values directly: assertEquals binomialCoefficient MathUtils binomialCoefficient ;,1
0,Math,Bugs in BrentOptimizer ,I apologize for having provided a buggy implementation of Brent s optimization algorithm class BrentOptimizer in package optimization univariate   The unit tests didn t show that there was something wrong although from the changes xml file  I discovered that at the time Luc had noticed something weird in the implementation s behaviour Comparing with an implementation in Python I could figure out the fixes I ll modify BrentOptimizer and add a test I also propose to change the name of the unit test class from BrentMinimizerTest to BrentOptimizerTest ,I apologize for having provided a buggy implementation of Brent s optimization algorithm class BrentOptimizer in package optimization univariate   The unit tests didn t show that there was something wrong although from the changes xml file  I discovered that at the time Luc had noticed something weird in the implementation s behaviour Comparing with an implementation in Python I could figure out the fixes I ll modify BrentOptimizer and add a test I also propose to change the name of the unit test class from BrentMinimizerTest to BrentOptimizerTest ,I apologize for having provided a buggy implementation of Brent s optimization algorithm class BrentOptimizer in package optimization univariate The unit tests didn t show that there was something wrong although from the changes xml file I discovered that at the time Luc had noticed something weird in the implementation s behaviour Comparing with an implementation in Python I could figure out the fixes I ll modify BrentOptimizer and add a test I also propose to change the name of the unit test class from BrentMinimizerTest to BrentOptimizerTest ,1
0,Math,Special functions not very accurate,The Gamma and Beta functions return values in double precision but the default epsilon is set to 10e-9 I think that the default should be set to the highest possible accuracy as this is what I d expect to be returned by a double precision routine Note that the erf function already uses a call to Gamma regularizedGammaP with an epsilon of 1 0e-15 ,The Gamma and Beta functions return values in double precision but the default epsilon is set to e I think that the default should be set to the highest possible accuracy as this is what I d expect to be returned by a double precision routine Note that the erf function already uses a call to Gamma regularizedGammaP with an epsilon of  e ,The Gamma and Beta functions return values in double precision but the default epsilon is set to e I think that the default should be set to the highest possible accuracy as this is what I d expect to be returned by a double precision routine Note that the erf function already uses a call to Gamma regularizedGammaP with an epsilon of e ,1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Math,LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it,LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it This makes it hard to specify custom stopping criteria for the optimizer ,LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it This makes it hard to specify custom stopping criteria for the optimizer ,LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it This makes it hard to specify custom stopping criteria for the optimizer ,1
0,Math,ConvergenceException in normal CDF,NormalDistributionImpl::cumulativeProbability double x  throws ConvergenceException if x deviates too much from the mean For example when x= -100 mean=0 sd=1 Of course the value of the CDF is hard to evaluate in these cases but effectively it should be either zero or one ,NormalDistributionImpl::cumulativeProbability double x  throws ConvergenceException if x deviates too much from the mean For example when x=  mean= sd= Of course the value of the CDF is hard to evaluate in these cases but effectively it should be either zero or one ,NormalDistributionImpl::cumulativeProbability double x throws ConvergenceException if x deviates too much from the mean For example when x= mean= sd= Of course the value of the CDF is hard to evaluate in these cases but effectively it should be either zero or one ,1
0,Math,Truncation issue in KMeansPlusPlusClusterer,The for loop inside KMeansPlusPlusClusterer chooseInitialClusters defines a variable int sum = 0; This variable should have type double rather than int Using an int causes the method to truncate the distances between points to square roots of  integers It s especially bad when the distances between points are typically less than 1 As an aside in version 2 2 this bug manifested itself by making the clusterer return empty clusters I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed ,The for loop inside KMeansPlusPlusClusterer chooseInitialClusters defines a variable int sum = ; This variable should have type double rather than int Using an int causes the method to truncate the distances between points to square roots of  integers It s especially bad when the distances between points are typically less than  As an aside in version   this bug manifested itself by making the clusterer return empty clusters I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed ,The for loop inside KMeansPlusPlusClusterer chooseInitialClusters defines a variable int sum = ; This variable should have type double rather than int Using an int causes the method to truncate the distances between points to square roots of integers It s especially bad when the distances between points are typically less than As an aside in version this bug manifested itself by making the clusterer return empty clusters I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed ,1
0,Math,BSPTree class and recovery of a Euclidean 3D BRep,New to the work here Thanks for your efforts on this code I create a BSPTree from a BoundaryRep Brep  my test Brep is a cube as represented by a float array containing 8 3D points in x y z  order and an array of indices 12 triplets for the 12 faces of the cube  I construct a BSPMesh   as shown in the code below I can construct the PolyhedronsSet   but have problems extracting the faces from the BSPTree to reconstruct the BRep The attached code BSPMesh2 java  shows that a small change to 1 of the vertex positions causes corrects the problem Any ideas ,New to the work here Thanks for your efforts on this code I create a BSPTree from a BoundaryRep Brep  my test Brep is a cube as represented by a float array containing  D points in x y z  order and an array of indices  triplets for the  faces of the cube  I construct a BSPMesh   as shown in the code below I can construct the PolyhedronsSet   but have problems extracting the faces from the BSPTree to reconstruct the BRep The attached code BSPMesh java  shows that a small change to  of the vertex positions causes corrects the problem Any ideas ,New to the work here Thanks for your efforts on this code I create a BSPTree from a BoundaryRep Brep my test Brep is a cube as represented by a float array containing D points in x y z order and an array of indices triplets for the faces of the cube I construct a BSPMesh as shown in the code below I can construct the PolyhedronsSet but have problems extracting the faces from the BSPTree to reconstruct the BRep The attached code BSPMesh java shows that a small change to of the vertex positions causes corrects the problem Any ideas ,1
0,Math,Need range checks for elitismRate in ElitisticListPopulation constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,1
0,Math,chiSquare double[] expected long[] observed  is returning incorrect test statistic,ChiSquareTestImpl is returning incorrect chi-squared value An implicit assumption of public double chiSquare double[] expected long[] observed  is that the sum of expected and observed are equal That is in the code: for int i = 0; i < observed length; i   { dev = double  observed[i] - expected[i] ; sumSq = dev dev expected[i]; } this calculation is only correct if sum observed ==sum expected  When they are not equal then one must rescale the expected value by sum observed  sum expected  so that they are Ironically it is an example in the unit test ChiSquareTestTest that highlights the error: long[] observed1 = { 500 623 72 70 31 } ; double[] expected1 = { 485 541 82 61 37 } ; assertEquals chi-square test statistic 16 4131070362 testStatistic chiSquare expected1 observed1  1E-10 ; assertEquals chi-square p-value 0 002512096 testStatistic chiSquareTest expected1 observed1  1E-9 ; 16 413 is not correct because the expected values do not make sense they should be: 521 19403 581 37313 88 11940 65 55224 39 76119 so that the sum of expected equals 1296 which is the sum of observed Here is some R code r-project org  which proves it: > o1 [1] 500 623 72 70 31 > e1 [1] 485 541 82 61 37 > chisq test o1 p=e1 rescale p=TRUE  Chi-squared test for given probabilities data: o1 X-squared = 9 0233 df = 4 p-value = 0 06052 > chisq test o1 p=e1 rescale p=TRUE  observed [1] 500 623 72 70 31 > chisq test o1 p=e1 rescale p=TRUE  expected [1] 521 19403 581 37313 88 11940 65 55224 39 76119,ChiSquareTestImpl is returning incorrect chisquared value An implicit assumption of public double chiSquare double[] expected long[] observed  is that the sum of expected and observed are equal That is in the code: for int i = ; i < observed length; i   { dev = double  observed[i]  expected[i] ; sumSq = dev dev expected[i]; } this calculation is only correct if sum observed ==sum expected  When they are not equal then one must rescale the expected value by sum observed  sum expected  so that they are Ironically it is an example in the unit test ChiSquareTestTest that highlights the error: long[] observed = {      } ; double[] expected = {      } ; assertEquals chisquare test statistic   testStatistic chiSquare expected observed  E ; assertEquals chisquare pvalue   testStatistic chiSquareTest expected observed  E ;   is not correct because the expected values do not make sense they should be:           so that the sum of expected equals  which is the sum of observed Here is some R code rproject org  which proves it: > o []      > e []      > chisq test o p=e rescale p=TRUE  Chisquared test for given probabilities data: o Xsquared =   df =  pvalue =   > chisq test o p=e rescale p=TRUE  observed []      > chisq test o p=e rescale p=TRUE  expected []          ,ChiSquareTestImpl is returning incorrect chisquared value An implicit assumption of public double chiSquare double[] expected long[] observed is that the sum of expected and observed are equal That is in the code: for int i = ; i < observed length; i { dev = double observed[i] expected[i] ; sumSq = dev dev expected[i]; } this calculation is only correct if sum observed ==sum expected When they are not equal then one must rescale the expected value by sum observed sum expected so that they are Ironically it is an example in the unit test ChiSquareTestTest that highlights the error: long[] observed = { } ; double[] expected = { } ; assertEquals chisquare test statistic testStatistic chiSquare expected observed E ; assertEquals chisquare pvalue testStatistic chiSquareTest expected observed E ; is not correct because the expected values do not make sense they should be: so that the sum of expected equals which is the sum of observed Here is some R code rproject org which proves it: > o [] > e [] > chisq test o p=e rescale p=TRUE Chisquared test for given probabilities data: o Xsquared = df = pvalue = > chisq test o p=e rescale p=TRUE observed [] > chisq test o p=e rescale p=TRUE expected [] ,1
0,Math,PearsonsCorrelation getCorrelationPValues   precision limited by machine epsilon,Similar to the issue described in MATH-201 using PearsonsCorrelation getCorrelationPValues   with many treatments results in p-values that are continuous down to 2 2e-16 but that drop to 0 after that In MATH-201 the problem was described as such: > So in essence the p-value returned by TTestImpl tTest   is: > > 1 0 - cumulativeProbability t  - cumulativeProbabily -t  > > For large-ish t-statistics cumulativeProbabilty -t  can get quite small and cumulativeProbabilty t  can get very close to 1 0 When > cumulativeProbability -t  is less than the machine epsilon we get p-values equal to zero because: > > 1 0 - 1 0 0 0 = 0 0 The solution in MATH-201 was to modify the p-value calculation to this: > p = 2 0 cumulativeProbability -t  Here the problem is similar From PearsonsCorrelation getCorrelationPValues  : p = 2 1 - tDistribution cumulativeProbability t ; Directly calculating the p-value using identical code as PearsonsCorrelation getCorrelationPValues   but with the following change seems to solve the problem: p = 2 tDistribution cumulativeProbability -t ;,Similar to the issue described in MATH using PearsonsCorrelation getCorrelationPValues   with many treatments results in pvalues that are continuous down to  e but that drop to  after that In MATH the problem was described as such: > So in essence the pvalue returned by TTestImpl tTest   is: > >    cumulativeProbability t   cumulativeProbabily t  > > For largeish tstatistics cumulativeProbabilty t  can get quite small and cumulativeProbabilty t  can get very close to   When > cumulativeProbability t  is less than the machine epsilon we get pvalues equal to zero because: > >        =   The solution in MATH was to modify the pvalue calculation to this: > p =   cumulativeProbability t  Here the problem is similar From PearsonsCorrelation getCorrelationPValues  : p =    tDistribution cumulativeProbability t ; Directly calculating the pvalue using identical code as PearsonsCorrelation getCorrelationPValues   but with the following change seems to solve the problem: p =  tDistribution cumulativeProbability t ;,Similar to the issue described in MATH using PearsonsCorrelation getCorrelationPValues with many treatments results in pvalues that are continuous down to e but that drop to after that In MATH the problem was described as such: > So in essence the pvalue returned by TTestImpl tTest is: > > cumulativeProbability t cumulativeProbabily t > > For largeish tstatistics cumulativeProbabilty t can get quite small and cumulativeProbabilty t can get very close to When > cumulativeProbability t is less than the machine epsilon we get pvalues equal to zero because: > > = The solution in MATH was to modify the pvalue calculation to this: > p = cumulativeProbability t Here the problem is similar From PearsonsCorrelation getCorrelationPValues : p = tDistribution cumulativeProbability t ; Directly calculating the pvalue using identical code as PearsonsCorrelation getCorrelationPValues but with the following change seems to solve the problem: p = tDistribution cumulativeProbability t ;,1
0,Math,MultidimensionalCounter getCounts int  returns wrong array of indices,MultidimensionalCounter counter = new MultidimensionalCounter 2 4 ; for Integer i : counter  { int[] x = counter getCounts; System out println i Arrays toString ; } Output is: 0 [0 0] 1 [0 1] 2 [0 2] 3 [0 2] <=== should be [0 3] 4 [1 0] 5 [1 1] 6 [1 2] 7 [1 2] <=== should be [1 3],MultidimensionalCounter counter = new MultidimensionalCounter   ; for Integer i : counter  { int[] x = counter getCounts; System out println i Arrays toString ; } Output is:  [ ]  [ ]  [ ]  [ ] <=== should be [ ]  [ ]  [ ]  [ ]  [ ] <=== should be [ ],MultidimensionalCounter counter = new MultidimensionalCounter ; for Integer i : counter { int[] x = counter getCounts; System out println i Arrays toString ; } Output is: [ ] [ ] [ ] [ ] <=== should be [ ] [ ] [ ] [ ] [ ] <=== should be [ ],1
0,Math,[math] SimpleRegression getSumSquaredErrors,getSumSquaredErrors returns -ve value See test below: public void testSimpleRegression   { double[] y = { 8915 102 8919 302 8923 502} ; double[] x = { 1 107178495 1 107264895 1 107351295} ; double[] x2 = { 1 107178495E2 1 107264895E2 1 107351295E2} ; SimpleRegression reg = new SimpleRegression  ; for int i = 0; i < x length; i   { reg addData x[i] y[i] ; } assertTrue reg getSumSquaredErrors   >= 0 0 ; OK reg clear  ; for int i = 0; i < x length; i   { reg addData x2[i] y[i] ; } assertTrue reg getSumSquaredErrors   >= 0 0 ; FAIL },getSumSquaredErrors returns ve value See test below: public void testSimpleRegression   { double[] y = {      } ; double[] x = {      } ; double[] x = {  E  E  E} ; SimpleRegression reg = new SimpleRegression  ; for int i = ; i < x length; i   { reg addData x[i] y[i] ; } assertTrue reg getSumSquaredErrors   >=   ; OK reg clear  ; for int i = ; i < x length; i   { reg addData x[i] y[i] ; } assertTrue reg getSumSquaredErrors   >=   ; FAIL },getSumSquaredErrors returns ve value See test below: public void testSimpleRegression { double[] y = { } ; double[] x = { } ; double[] x = { E E E} ; SimpleRegression reg = new SimpleRegression ; for int i = ; i < x length; i { reg addData x[i] y[i] ; } assertTrue reg getSumSquaredErrors >= ; OK reg clear ; for int i = ; i < x length; i { reg addData x[i] y[i] ; } assertTrue reg getSumSquaredErrors >= ; FAIL },1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Math,GaussianFitter Unexpectedly Throws NotStrictlyPositiveException,Running the following: double[] observations = { 1 1143831578403364E-29 4 95281403484594E-28 1 1171347211930288E-26 1 7044813962636277E-25 1 9784716574832164E-24 1 8630236407866774E-23 1 4820532905097742E-22 1 0241963854632831E-21 6 275077366673128E-21 3 461808994532493E-20 1 7407124684715706E-19 8 056687953553974E-19 3 460193945992071E-18 1 3883326374011525E-17 5 233894983671116E-17 1 8630791465263745E-16 6 288759227922111E-16 2 0204433920597856E-15 6 198768938576155E-15 1 821419346860626E-14 5 139176445538471E-14 1 3956427429045787E-13 3 655705706448139E-13 9 253753324779779E-13 2 267636001476696E-12 5 3880460095836855E-12 1 2431632654852931E-11 } ; GaussianFitter g = new GaussianFitter new LevenbergMarquardtOptimizer  ; for int index = 0; index < 27; index   { g addObservedPoint index observations[index] ; } g fit  ; Results in: org apache commons math exception NotStrictlyPositiveException: -1 277 is smaller than or equal to the minimum 0  at org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java:184  at org apache commons math analysis function Gaussian Parametric value Gaussian java:129  I m guessing the initial guess for sigma is off ,Running the following: double[] observations = {  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E } ; GaussianFitter g = new GaussianFitter new LevenbergMarquardtOptimizer  ; for int index = ; index < ; index   { g addObservedPoint index observations[index] ; } g fit  ; Results in: org apache commons math exception NotStrictlyPositiveException:   is smaller than or equal to the minimum   at org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java:  at org apache commons math analysis function Gaussian Parametric value Gaussian java:  I m guessing the initial guess for sigma is off ,Running the following: double[] observations = { E E E E E E E E E E E E E E E E E E E E E E E E E E E } ; GaussianFitter g = new GaussianFitter new LevenbergMarquardtOptimizer ; for int index = ; index < ; index { g addObservedPoint index observations[index] ; } g fit ; Results in: org apache commons math exception NotStrictlyPositiveException: is smaller than or equal to the minimum at org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java: at org apache commons math analysis function Gaussian Parametric value Gaussian java: I m guessing the initial guess for sigma is off ,1
0,Math,Method getResult   in MultiStartUnivariateRealOptimizer ,In MultiStartUnivariateRealOptimizer package optimization   the method getResult returns the result of the last run of the underlying optimizer; this last result might not be the best one in which case it will not correspond to the value returned by the optimize method This is confusing and does not seem very useful I think that getResult should be defined as public double getResult   { return optima[0]; } and similarly public double getFunctionValue   { return optimaValues[0]; },In MultiStartUnivariateRealOptimizer package optimization   the method getResult returns the result of the last run of the underlying optimizer; this last result might not be the best one in which case it will not correspond to the value returned by the optimize method This is confusing and does not seem very useful I think that getResult should be defined as public double getResult   { return optima[]; } and similarly public double getFunctionValue   { return optimaValues[]; },In MultiStartUnivariateRealOptimizer package optimization the method getResult returns the result of the last run of the underlying optimizer; this last result might not be the best one in which case it will not correspond to the value returned by the optimize method This is confusing and does not seem very useful I think that getResult should be defined as public double getResult { return optima[]; } and similarly public double getFunctionValue { return optimaValues[]; },1
0,Math,MathUtils factorial n  fails for n >= 17,The result of MathUtils factorial n   for n = 17 18 19 is wrong probably because of rounding errors in the double calculations Replace the first line of MathUtilsTest testFactorial   by for int i = 1; i <= 20; i   { to check all valid arguments for the long result and see the failure I suggest implementing a simple loop to multiply the long result - or even using a precomputed long[] - instead of adding logarithms ,The result of MathUtils factorial n   for n =    is wrong probably because of rounding errors in the double calculations Replace the first line of MathUtilsTest testFactorial   by for int i = ; i <= ; i   { to check all valid arguments for the long result and see the failure I suggest implementing a simple loop to multiply the long result  or even using a precomputed long[]  instead of adding logarithms ,The result of MathUtils factorial n for n = is wrong probably because of rounding errors in the double calculations Replace the first line of MathUtilsTest testFactorial by for int i = ; i <= ; i { to check all valid arguments for the long result and see the failure I suggest implementing a simple loop to multiply the long result or even using a precomputed long[] instead of adding logarithms ,1
0,Math,MathUtils gcd u v  fails when u and v both contain a high power of 2,The test at the beginning of MathUtils gcd u v  for arguments equal to zero fails when u and v contain high enough powers of 2 so that their product overflows to zero assertEquals 3 1<<15  MathUtils gcd 3 1<<20  9 1<<15 ; Fix: Replace the test at the start of MathUtils gcd   if u v == 0  { by if u == 0 || v == 0  {,The test at the beginning of MathUtils gcd u v  for arguments equal to zero fails when u and v contain high enough powers of  so that their product overflows to zero assertEquals  <<  MathUtils gcd  <<   << ; Fix: Replace the test at the start of MathUtils gcd   if u v ==   { by if u ==  || v ==   {,The test at the beginning of MathUtils gcd u v for arguments equal to zero fails when u and v contain high enough powers of so that their product overflows to zero assertEquals << MathUtils gcd << << ; Fix: Replace the test at the start of MathUtils gcd if u v == { by if u == || v == {,1
0,Math,ConvergenceException in NormalDistributionImpl cumulativeProbability  ,I get a ConvergenceException in NormalDistributionImpl cumulativeProbability   for very large small parameters including Infinity -Infinity For instance in the following code:  Test public void testCumulative   { final NormalDistribution nd = new NormalDistributionImpl  ; for int i = 0; i < 500; i   { final double val = Math exp; try { System out println val = val cumulative = nd cumulativeProbability val ; } catch MathException e  { e printStackTrace  ; fail  ; } } } In version 2 0 I get no exception My suggestion is to change in the implementation of cumulativeProbability double  to catch all ConvergenceException and return for very large and very small values  not just MaxIterationsExceededException ,I get a ConvergenceException in NormalDistributionImpl cumulativeProbability   for very large small parameters including Infinity Infinity For instance in the following code:  Test public void testCumulative   { final NormalDistribution nd = new NormalDistributionImpl  ; for int i = ; i < ; i   { final double val = Math exp; try { System out println val = val cumulative = nd cumulativeProbability val ; } catch MathException e  { e printStackTrace  ; fail  ; } } } In version   I get no exception My suggestion is to change in the implementation of cumulativeProbability double  to catch all ConvergenceException and return for very large and very small values  not just MaxIterationsExceededException ,I get a ConvergenceException in NormalDistributionImpl cumulativeProbability for very large small parameters including Infinity Infinity For instance in the following code: Test public void testCumulative { final NormalDistribution nd = new NormalDistributionImpl ; for int i = ; i < ; i { final double val = Math exp; try { System out println val = val cumulative = nd cumulativeProbability val ; } catch MathException e { e printStackTrace ; fail ; } } } In version I get no exception My suggestion is to change in the implementation of cumulativeProbability double to catch all ConvergenceException and return for very large and very small values not just MaxIterationsExceededException ,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze   gives bad results with commons-math3-3 0 in a simple test problem It works well in commons-math-2 2 ,Methode SimplexSolver optimeze   gives bad results with commonsmath  in a simple test problem It works well in commonsmath  ,Methode SimplexSolver optimeze gives bad results with commonsmath in a simple test problem It works well in commonsmath ,1
0,Math,CMAESOptimizer does not enforce bounds,The CMAESOptimizer can exceed the bounds passed to optimize Looking at the generationLoop in doOptimize   it does a bounds check by calling isFeasible   but if checkFeasableCount is zero the default  then isFeasible   is never even called Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring This is against svn revision 1387637 I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help ,The CMAESOptimizer can exceed the bounds passed to optimize Looking at the generationLoop in doOptimize   it does a bounds check by calling isFeasible   but if checkFeasableCount is zero the default  then isFeasible   is never even called Also even with nonzero checkFeasableCount it may give up before finding an inbounds offspring and go forward with an outofbounds offspring This is against svn revision  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help ,The CMAESOptimizer can exceed the bounds passed to optimize Looking at the generationLoop in doOptimize it does a bounds check by calling isFeasible but if checkFeasableCount is zero the default then isFeasible is never even called Also even with nonzero checkFeasableCount it may give up before finding an inbounds offspring and go forward with an outofbounds offspring This is against svn revision I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help ,1
0,Math,CMAESOptimizer with bounds fits finely near lower bound and coarsely near upper bound ,When fitting with bounds the CMAESOptimizer fits finely near the lower bound and coarsely near the upper bound This is because it internally maps the fitted parameter range into the interval [0 1] The unit of least precision ulp  between floating point numbers is much smaller near zero than near one Thus fits have much better resolution near the lower bound which is mapped to zero  than the upper bound which is mapped to one  I will attach a example program to demonstrate ,When fitting with bounds the CMAESOptimizer fits finely near the lower bound and coarsely near the upper bound This is because it internally maps the fitted parameter range into the interval [ ] The unit of least precision ulp  between floating point numbers is much smaller near zero than near one Thus fits have much better resolution near the lower bound which is mapped to zero  than the upper bound which is mapped to one  I will attach a example program to demonstrate ,When fitting with bounds the CMAESOptimizer fits finely near the lower bound and coarsely near the upper bound This is because it internally maps the fitted parameter range into the interval [ ] The unit of least precision ulp between floating point numbers is much smaller near zero than near one Thus fits have much better resolution near the lower bound which is mapped to zero than the upper bound which is mapped to one I will attach a example program to demonstrate ,1
0,Math,Fraction percentageValue rare overflow,The percentageValue   method of the Fraction class works by first multiplying the Fraction by 100 then converting the Fraction to a double This causes overflows when the numerator is greater than Integer MAX VALUE 100 even when the value of the fraction is far below this value The patch changes the method to first convert to a double value and then multiply this value by 100 - the result should be the same but with less overflows An addition to the test for the method that covers this bug is also included ,The percentageValue   method of the Fraction class works by first multiplying the Fraction by  then converting the Fraction to a double This causes overflows when the numerator is greater than Integer MAX VALUE  even when the value of the fraction is far below this value The patch changes the method to first convert to a double value and then multiply this value by   the result should be the same but with less overflows An addition to the test for the method that covers this bug is also included ,The percentageValue method of the Fraction class works by first multiplying the Fraction by then converting the Fraction to a double This causes overflows when the numerator is greater than Integer MAX VALUE even when the value of the fraction is far below this value The patch changes the method to first convert to a double value and then multiply this value by the result should be the same but with less overflows An addition to the test for the method that covers this bug is also included ,1
0,Math,Line revert   is imprecise,Line revert   only maintains  10 digits for the direction This becomes an issue when the line s position is evaluated far from the origin A simple fix would be to use Vector3D negate   for the direction Also is there a reason why Line is not immutable It is just comprised of two vectors ,Line revert   only maintains   digits for the direction This becomes an issue when the line s position is evaluated far from the origin A simple fix would be to use VectorD negate   for the direction Also is there a reason why Line is not immutable It is just comprised of two vectors ,Line revert only maintains digits for the direction This becomes an issue when the line s position is evaluated far from the origin A simple fix would be to use VectorD negate for the direction Also is there a reason why Line is not immutable It is just comprised of two vectors ,1
0,Math,MultivariateNormalDistribution density double[]  returns wrong value when the dimension is odd,To reproduce: Assert assertEquals 0 398942280401433 new MultivariateNormalDistribution new double[]{0} new double[][]{{1}}  density new double[]{0}  1e-15 ;,To reproduce: Assert assertEquals   new MultivariateNormalDistribution new double[]{} new double[][]{{}}  density new double[]{}  e ;,To reproduce: Assert assertEquals new MultivariateNormalDistribution new double[]{} new double[][]{{}} density new double[]{} e ;,1
0,Math,event state not updated if an unrelated event triggers a RESET STATE during ODE integration,When an ODE solver manages several different event types there are some unwanted side effects If one event handler asks for a RESET STATE for integration state  when its eventOccurred method is called the other event handlers that did not trigger an event in the same step are not updated correctly due to an early return As a result when the next step is processed with a reset integration state the forgotten event still refer to the start date of the previous state This implies that when these event handlers will be checked for In some cases the function defining an event g double t double[] y  is called with state parameters y that are completely wrong In one case when the y array should have contained values between -1 and 1 one function call got values up to 1 0e20 The attached file reproduces the problem ,When an ODE solver manages several different event types there are some unwanted side effects If one event handler asks for a RESET STATE for integration state  when its eventOccurred method is called the other event handlers that did not trigger an event in the same step are not updated correctly due to an early return As a result when the next step is processed with a reset integration state the forgotten event still refer to the start date of the previous state This implies that when these event handlers will be checked for In some cases the function defining an event g double t double[] y  is called with state parameters y that are completely wrong In one case when the y array should have contained values between  and  one function call got values up to  e The attached file reproduces the problem ,When an ODE solver manages several different event types there are some unwanted side effects If one event handler asks for a RESET STATE for integration state when its eventOccurred method is called the other event handlers that did not trigger an event in the same step are not updated correctly due to an early return As a result when the next step is processed with a reset integration state the forgotten event still refer to the start date of the previous state This implies that when these event handlers will be checked for In some cases the function defining an event g double t double[] y is called with state parameters y that are completely wrong In one case when the y array should have contained values between and one function call got values up to e The attached file reproduces the problem ,1
0,Math,Bugs in RealVector ebeMultiply RealVector  and ebeDivide RealVector ,OpenMapRealVector ebeMultiply RealVector  and OpenMapRealVector ebeDivide RealVector  return wrong values when one entry of the specified RealVector is nan or infinity The bug is easy to understand Here is the current implementation of ebeMultiply public OpenMapRealVector ebeMultiply RealVector v  { checkVectorDimensions v getDimension  ; OpenMapRealVector res = new OpenMapRealVector this ; Iterator iter = entries iterator  ; while iter hasNext   { iter advance  ; res setEntry iter key   iter value   v getEntry iter key  ; } return res; } The assumption is that for any double x x 0d == 0d holds which is not true The bug is easy enough to identify but more complex to solve The only solution I can come up with is to loop through all entries of v instead of those entries which correspond to non-zero entries of this  I m afraid about performance losses ,OpenMapRealVector ebeMultiply RealVector  and OpenMapRealVector ebeDivide RealVector  return wrong values when one entry of the specified RealVector is nan or infinity The bug is easy to understand Here is the current implementation of ebeMultiply public OpenMapRealVector ebeMultiply RealVector v  { checkVectorDimensions v getDimension  ; OpenMapRealVector res = new OpenMapRealVector this ; Iterator iter = entries iterator  ; while iter hasNext   { iter advance  ; res setEntry iter key   iter value   v getEntry iter key  ; } return res; } The assumption is that for any double x x d == d holds which is not true The bug is easy enough to identify but more complex to solve The only solution I can come up with is to loop through all entries of v instead of those entries which correspond to nonzero entries of this  I m afraid about performance losses ,OpenMapRealVector ebeMultiply RealVector and OpenMapRealVector ebeDivide RealVector return wrong values when one entry of the specified RealVector is nan or infinity The bug is easy to understand Here is the current implementation of ebeMultiply public OpenMapRealVector ebeMultiply RealVector v { checkVectorDimensions v getDimension ; OpenMapRealVector res = new OpenMapRealVector this ; Iterator iter = entries iterator ; while iter hasNext { iter advance ; res setEntry iter key iter value v getEntry iter key ; } return res; } The assumption is that for any double x x d == d holds which is not true The bug is easy enough to identify but more complex to solve The only solution I can come up with is to loop through all entries of v instead of those entries which correspond to nonzero entries of this I m afraid about performance losses ,1
0,Math,FastMath [cosh sinh] do not support the same range of values as the Math counterparts,As reported by Jeff Hain: cosh double  and sinh double : Math cosh 709 783  = 8 991046692770538E307 FastMath cosh 709 783  = Infinity Math sinh 709 783  = 8 991046692770538E307 FastMath sinh 709 783  = Infinity ===> This is due to using exp x   2 for values of |x| above 20: the result sometimes should not overflow but exp x   does so we end up with some infinity ===> for values of |x| >= StrictMath log Double MAX VALUE  exp will overflow so you need to use that instead: for x positive: double t = exp x 0 5 ; return 0 5 t t; for x negative: double t = exp -x 0 5 ; return -0 5 t t;,As reported by Jeff Hain: cosh double  and sinh double : Math cosh    =  E FastMath cosh    = Infinity Math sinh    =  E FastMath sinh    = Infinity ===> This is due to using exp x    for values of |x| above : the result sometimes should not overflow but exp x   does so we end up with some infinity ===> for values of |x| >= StrictMath log Double MAX VALUE  exp will overflow so you need to use that instead: for x positive: double t = exp x   ; return   t t; for x negative: double t = exp x   ; return   t t;,As reported by Jeff Hain: cosh double and sinh double : Math cosh = E FastMath cosh = Infinity Math sinh = E FastMath sinh = Infinity ===> This is due to using exp x for values of |x| above : the result sometimes should not overflow but exp x does so we end up with some infinity ===> for values of |x| >= StrictMath log Double MAX VALUE exp will overflow so you need to use that instead: for x positive: double t = exp x ; return t t; for x negative: double t = exp x ; return t t;,1
0,Math,Negative value with restrictNonNegative,Problem: commons-math-2 2 SimplexSolver A variable with 0 coefficient may be assigned a negative value nevertheless restrictToNonnegative flag in call: SimplexSolver optimize function constraints GoalType MINIMIZE true ; Function 1 x 1 y 0 Constraints: 1 x 0 y = 1 Result: x = 1; y = -1; Probably variables with 0 coefficients are omitted at some point of computation and because of that the restrictions do not affect their values ,Problem: commonsmath  SimplexSolver A variable with  coefficient may be assigned a negative value nevertheless restrictToNonnegative flag in call: SimplexSolver optimize function constraints GoalType MINIMIZE true ; Function  x  y  Constraints:  x  y =  Result: x = ; y = ; Probably variables with  coefficients are omitted at some point of computation and because of that the restrictions do not affect their values ,Problem: commonsmath SimplexSolver A variable with coefficient may be assigned a negative value nevertheless restrictToNonnegative flag in call: SimplexSolver optimize function constraints GoalType MINIMIZE true ; Function x y Constraints: x y = Result: x = ; y = ; Probably variables with coefficients are omitted at some point of computation and because of that the restrictions do not affect their values ,1
0,Math,Bugs in Frequency API,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added - it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods - they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a non-Comparable object because the class cast exception is caught  however they just return 0 as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; 0 System out println f getPct OBJ ; 0 0 Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added  it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods  they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a nonComparable object because the class cast exception is caught  however they just return  as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ;  System out println f getPct OBJ ;   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return  or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object which should not allow a plain Object to be added it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object and getCumPct Object methods they will only work with objects that implement Comparable The getCount Object and getPct Object methods don t fail when given a nonComparable object because the class cast exception is caught however they just return as if the object was not present: final Object OBJ = new Object ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; System out println f getPct OBJ ; Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return or an Exception and applying the instanceof fix would also cause it to fail ,1
0,Math,Integer overflow in OpenMapRealMatrix,computeKey   has an integer overflow Since it is a sparse matrix this is quite easily encountered long before heap space is exhausted The attached code demonstrates the problem which could potentially be a security vulnerability for example if one was to use this matrix to store access control information  Workaround: never create an OpenMapRealMatrix with more cells than are addressable with an int ,computeKey   has an integer overflow Since it is a sparse matrix this is quite easily encountered long before heap space is exhausted The attached code demonstrates the problem which could potentially be a security vulnerability for example if one was to use this matrix to store access control information  Workaround: never create an OpenMapRealMatrix with more cells than are addressable with an int ,computeKey has an integer overflow Since it is a sparse matrix this is quite easily encountered long before heap space is exhausted The attached code demonstrates the problem which could potentially be a security vulnerability for example if one was to use this matrix to store access control information Workaround: never create an OpenMapRealMatrix with more cells than are addressable with an int ,1
0,Math,Brent solver doesn t throw IllegalArgumentException when initial guess has the wrong sign,Javadoc for public double solve final UnivariateRealFunction f final double min final double max final double initial  claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown This case isn t even checked ,Javadoc for public double solve final UnivariateRealFunction f final double min final double max final double initial  claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown This case isn t even checked ,Javadoc for public double solve final UnivariateRealFunction f final double min final double max final double initial claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown This case isn t even checked ,1
0,Math,Basic variable is not found correctly in simplex tableau,The last patch to SimplexTableau caused an automated test suite I m running at work to go down a new code path and uncover what is hopefully the last bug remaining in the Simplex code SimplexTableau was assuming an entry in the tableau had to be nonzero to indicate a basic variable which is incorrect - the entry should have a value equal to 1 ,The last patch to SimplexTableau caused an automated test suite I m running at work to go down a new code path and uncover what is hopefully the last bug remaining in the Simplex code SimplexTableau was assuming an entry in the tableau had to be nonzero to indicate a basic variable which is incorrect  the entry should have a value equal to  ,The last patch to SimplexTableau caused an automated test suite I m running at work to go down a new code path and uncover what is hopefully the last bug remaining in the Simplex code SimplexTableau was assuming an entry in the tableau had to be nonzero to indicate a basic variable which is incorrect the entry should have a value equal to ,1
0,Math,wrong result in eigen decomposition,Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version 2 0 public void testMathpbx02   { double[] mainTridiagonal = { 7484 860960227216 18405 28129035345 13855 225609560746 10016 708722343366 559 8117399576674 6750 190788301587 71 21428769782159 }; double[] secondaryTridiagonal = { -4175 088570476366 1975 7955858241994 5193 178422374075 1995 286659169179 75 34535882933804 -234 0808002076056 }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version 3 2 1 double[] refEigenValues = { 20654 744890306974412 16828 208208485466457 6893 155912634994820 6757 083016675340332 5887 799885688558788 64 309089923240379 57 992628792736340 }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] {-0 270356342026904 0 852811091326997 0 399639490702077 0 198794657813990 0 019739323307666 0 000106983022327 -0 000001216636321}  new ArrayRealVector new double[] {0 179995273578326 -0 402807848153042 0 701870993525734 0 555058211014888 0 068079148898236 0 000509139115227 -0 000007112235617}  new ArrayRealVector new double[] {-0 399582721284727 -0 056629954519333 -0 514406488522827 0 711168164518580 0 225548081276367 0 125943999652923 -0 004321507456014}  new ArrayRealVector new double[] {0 058515721572821 0 010200130057739 0 063516274916536 -0 090696087449378 -0 017148420432597 0 991318870265707 -0 034707338554096}  new ArrayRealVector new double[] {0 855205995537564 0 327134656629775 -0 265382397060548 0 282690729026706 0 105736068025572 -0 009138126622039 0 000367751821196}  new ArrayRealVector new double[] {-0 002913069901144 -0 005177515777101 0 041906334478672 -0 109315918416258 0 436192305456741 0 026307315639535 0 891797507436344}  new ArrayRealVector new double[] {-0 005738311176435 -0 010207611670378 0 082662420517928 -0 215733886094368 0 861606487840411 -0 025478530652759 -0 451080697503958}  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = 0; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i] 1 0e-3 ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  < 0  { assertEquals 0 refEigenVectors[i] add decomposition getEigenvector i  getNorm   1 0e-5 ; } else { assertEquals 0 refEigenVectors[i] subtract decomposition getEigenvector i  getNorm   1 0e-5 ; } } },Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version   public void testMathpbx   { double[] mainTridiagonal = {               }; double[] secondaryTridiagonal = {             }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version    double[] refEigenValues = {               }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = ; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i]  e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  <   { assertEquals  refEigenVectors[i] add decomposition getEigenvector i  getNorm    e ; } else { assertEquals  refEigenVectors[i] subtract decomposition getEigenvector i  getNorm    e ; } } },Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version public void testMathpbx { double[] mainTridiagonal = { }; double[] secondaryTridiagonal = { }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version double[] refEigenValues = { }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues ; for int i = ; i < refEigenValues length; i { assertEquals refEigenValues[i] eigenValues[i] e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i < { assertEquals refEigenVectors[i] add decomposition getEigenvector i getNorm e ; } else { assertEquals refEigenVectors[i] subtract decomposition getEigenvector i getNorm e ; } } },1
0,Math,Wrong parameter for first step size guess for Embedded Runge Kutta methods,In a space application using DOP853 i detected what seems to be a bad parameter in the call to the method initializeStep of class AdaptiveStepsizeIntegrator Here DormandPrince853Integrator is a subclass for EmbeddedRungeKuttaIntegrator which perform the call to initializeStep at the beginning of its method integrate   The problem comes from the array scale that is used as a parameter in the call off initializeStep   Following the theory described by Hairer in his book Solving Ordinary Differential Equations 1 : Nonstiff Problems the scaling should be : sci = Atol i |y0i| Rtoli Whereas EmbeddedRungeKuttaIntegrator uses : sci = Atoli Note that the Gragg-Bulirsch-Stoer integrator uses the good implementation sci = Atol i |y0i| Rtoli when he performs the call to the same method initializeStep   In the method initializeStep the error leads to a wrong step size h used to perform an Euler step Most of the time it is unvisible for the user But in my space application the Euler step with this wrong step size h much bigger than it should be  makes an exception occur my satellite hits the ground   To fix the bug one should use the same algorithm as in the rescale method in GraggBulirschStoerIntegrator For exemple : final double[] scale= new double[y0 length];; if vecAbsoluteTolerance == null  { for int i = 0; i < scale length; i  { final double yi = Math max Math abs y0[i]  Math abs y0[i] ; scale[i] = scalAbsoluteTolerance scalRelativeTolerance yi; } } else { for int i = 0; i < scale length; i  { final double yi = Math max Math abs y0[i]  Math abs y0[i] ; scale[i] = vecAbsoluteTolerance[i] vecRelativeTolerance[i] yi; } } hNew = initializeStep equations forward getOrder   scale stepStart y yDotK[0] yTmp yDotK[1] ; Sorry for the length of this message looking forward to hearing from you soon Vincent Morand,In a space application using DOP i detected what seems to be a bad parameter in the call to the method initializeStep of class AdaptiveStepsizeIntegrator Here DormandPrinceIntegrator is a subclass for EmbeddedRungeKuttaIntegrator which perform the call to initializeStep at the beginning of its method integrate   The problem comes from the array scale that is used as a parameter in the call off initializeStep   Following the theory described by Hairer in his book Solving Ordinary Differential Equations  : Nonstiff Problems the scaling should be : sci = Atol i |yi| Rtoli Whereas EmbeddedRungeKuttaIntegrator uses : sci = Atoli Note that the GraggBulirschStoer integrator uses the good implementation sci = Atol i |yi| Rtoli when he performs the call to the same method initializeStep   In the method initializeStep the error leads to a wrong step size h used to perform an Euler step Most of the time it is unvisible for the user But in my space application the Euler step with this wrong step size h much bigger than it should be  makes an exception occur my satellite hits the ground   To fix the bug one should use the same algorithm as in the rescale method in GraggBulirschStoerIntegrator For exemple : final double[] scale= new double[y length];; if vecAbsoluteTolerance == null  { for int i = ; i < scale length; i  { final double yi = Math max Math abs y[i]  Math abs y[i] ; scale[i] = scalAbsoluteTolerance scalRelativeTolerance yi; } } else { for int i = ; i < scale length; i  { final double yi = Math max Math abs y[i]  Math abs y[i] ; scale[i] = vecAbsoluteTolerance[i] vecRelativeTolerance[i] yi; } } hNew = initializeStep equations forward getOrder   scale stepStart y yDotK[] yTmp yDotK[] ; Sorry for the length of this message looking forward to hearing from you soon Vincent Morand,In a space application using DOP i detected what seems to be a bad parameter in the call to the method initializeStep of class AdaptiveStepsizeIntegrator Here DormandPrinceIntegrator is a subclass for EmbeddedRungeKuttaIntegrator which perform the call to initializeStep at the beginning of its method integrate The problem comes from the array scale that is used as a parameter in the call off initializeStep Following the theory described by Hairer in his book Solving Ordinary Differential Equations : Nonstiff Problems the scaling should be : sci = Atol i |yi| Rtoli Whereas EmbeddedRungeKuttaIntegrator uses : sci = Atoli Note that the GraggBulirschStoer integrator uses the good implementation sci = Atol i |yi| Rtoli when he performs the call to the same method initializeStep In the method initializeStep the error leads to a wrong step size h used to perform an Euler step Most of the time it is unvisible for the user But in my space application the Euler step with this wrong step size h much bigger than it should be makes an exception occur my satellite hits the ground To fix the bug one should use the same algorithm as in the rescale method in GraggBulirschStoerIntegrator For exemple : final double[] scale= new double[y length];; if vecAbsoluteTolerance == null { for int i = ; i < scale length; i { final double yi = Math max Math abs y[i] Math abs y[i] ; scale[i] = scalAbsoluteTolerance scalRelativeTolerance yi; } } else { for int i = ; i < scale length; i { final double yi = Math max Math abs y[i] Math abs y[i] ; scale[i] = vecAbsoluteTolerance[i] vecRelativeTolerance[i] yi; } } hNew = initializeStep equations forward getOrder scale stepStart y yDotK[] yTmp yDotK[] ; Sorry for the length of this message looking forward to hearing from you soon Vincent Morand,1
0,Math,LevenbergMarquardtOptimizer reports 0 iterations,The method LevenbergMarquardtOptimizer getIterations   does not report the correct number of iterations; It always returns 0 A quick look at the code shows that only SimplexOptimizer calls BaseOptimizer incrementEvaluationsCount   I ve put a test case below Notice how the evaluations count is correctly incremented but the iterations count is not  Test public void testGetIterations   { setup LevenbergMarquardtOptimizer otim = new LevenbergMarquardtOptimizer  ; action otim optimize new MaxEval 100  new Target new double[] { 1 }  new Weight new double[] { 1 }  new InitialGuess new double[] { 3 }  new ModelFunction new MultivariateVectorFunction   {  Override public double[] value double[] point  throws IllegalArgumentException { return new double[] { FastMath pow point[0] 4  }; } }  new ModelFunctionJacobian new MultivariateMatrixFunction   {  Override public double[][] value double[] point  throws IllegalArgumentException { return new double[][] { { 0 25 FastMath pow point[0] 3  } }; } } ; verify assertThat otim getEvaluations   greaterThan 1 ; assertThat otim getIterations   greaterThan 1 ; },The method LevenbergMarquardtOptimizer getIterations   does not report the correct number of iterations; It always returns  A quick look at the code shows that only SimplexOptimizer calls BaseOptimizer incrementEvaluationsCount   I ve put a test case below Notice how the evaluations count is correctly incremented but the iterations count is not  Test public void testGetIterations   { setup LevenbergMarquardtOptimizer otim = new LevenbergMarquardtOptimizer  ; action otim optimize new MaxEval   new Target new double[] {  }  new Weight new double[] {  }  new InitialGuess new double[] {  }  new ModelFunction new MultivariateVectorFunction   {  Override public double[] value double[] point  throws IllegalArgumentException { return new double[] { FastMath pow point[]   }; } }  new ModelFunctionJacobian new MultivariateMatrixFunction   {  Override public double[][] value double[] point  throws IllegalArgumentException { return new double[][] { {   FastMath pow point[]   } }; } } ; verify assertThat otim getEvaluations   greaterThan  ; assertThat otim getIterations   greaterThan  ; },The method LevenbergMarquardtOptimizer getIterations does not report the correct number of iterations; It always returns A quick look at the code shows that only SimplexOptimizer calls BaseOptimizer incrementEvaluationsCount I ve put a test case below Notice how the evaluations count is correctly incremented but the iterations count is not Test public void testGetIterations { setup LevenbergMarquardtOptimizer otim = new LevenbergMarquardtOptimizer ; action otim optimize new MaxEval new Target new double[] { } new Weight new double[] { } new InitialGuess new double[] { } new ModelFunction new MultivariateVectorFunction { Override public double[] value double[] point throws IllegalArgumentException { return new double[] { FastMath pow point[] }; } } new ModelFunctionJacobian new MultivariateMatrixFunction { Override public double[][] value double[] point throws IllegalArgumentException { return new double[][] { { FastMath pow point[] } }; } } ; verify assertThat otim getEvaluations greaterThan ; assertThat otim getIterations greaterThan ; },1
0,Math,Not expected UnboundedSolutionException,SimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem The number of exception thrown depends on the number of variables In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES COUNT = 2 and that will give almost good result and then set it to 15 and you ll get a massive of unbounded exceptions First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result The problem itself is well tested by it s authors mathematicians who I believe know what they developed  using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem The problem is formulated as min 1 t 0 L  for every r-th subject  s t -q r  QL >= 0 x r t - XL >= 0 L >= 0 where r = 1 R L = {l 1  l 2  l R } vector of R rows and 1 column  Q - coefficients matrix MxR X - coefficients matrix NxR,SimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem The number of exception thrown depends on the number of variables In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES COUNT =  and that will give almost good result and then set it to  and you ll get a massive of unbounded exceptions First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result The problem itself is well tested by it s authors mathematicians who I believe know what they developed  using Matlab  with no unbounded solutions on the same rules of creatnig random variables values What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem The problem is formulated as min  t  L  for every rth subject  s t q r  QL >=  x r t  XL >=  L >=  where r =  R L = {l   l   l R } vector of R rows and  column  Q  coefficients matrix MxR X  coefficients matrix NxR,SimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem The number of exception thrown depends on the number of variables In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES COUNT = and that will give almost good result and then set it to and you ll get a massive of unbounded exceptions First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result The problem itself is well tested by it s authors mathematicians who I believe know what they developed using Matlab with no unbounded solutions on the same rules of creatnig random variables values What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem The problem is formulated as min t L for every rth subject s t q r QL >= x r t XL >= L >= where r = R L = {l l l R } vector of R rows and column Q coefficients matrix MxR X coefficients matrix NxR,1
0,Math,Dfp Dfp multiply int x  does not comply with the general contract FieldElement multiply int n ,In class org apache commons math3 Dfp the method multiply int n  is limited to 0 <= n <= 9999 This is not consistent with the general contract of FieldElement multiply int n  where there should be no limitation on the values of n ,In class org apache commons math Dfp the method multiply int n  is limited to  <= n <=  This is not consistent with the general contract of FieldElement multiply int n  where there should be no limitation on the values of n ,In class org apache commons math Dfp the method multiply int n is limited to <= n <= This is not consistent with the general contract of FieldElement multiply int n where there should be no limitation on the values of n ,1
0,Math,Fraction specified with maxDenominator and a value very close to a simple fraction should not throw an overflow exception,An overflow exception is thrown when a Fraction is initialized with a maxDenominator from a double that is very close to a simple fraction For example: double d = 0 5000000001; Fraction f = new Fraction d 10 ; Patch with unit test on way ,An overflow exception is thrown when a Fraction is initialized with a maxDenominator from a double that is very close to a simple fraction For example: double d =  ; Fraction f = new Fraction d  ; Patch with unit test on way ,An overflow exception is thrown when a Fraction is initialized with a maxDenominator from a double that is very close to a simple fraction For example: double d = ; Fraction f = new Fraction d ; Patch with unit test on way ,1
0,Math,DerivativeStructure atan2 y x  does not handle special cases properly,The four special cases -0 for both x and y should give the same values as Math atan2 and FastMath atan2 However they give NaN for the value in all cases ,The four special cases  for both x and y should give the same values as Math atan and FastMath atan However they give NaN for the value in all cases ,The four special cases for both x and y should give the same values as Math atan and FastMath atan However they give NaN for the value in all cases ,1
0,Math,Wide bounds to CMAESOptimizer result in NaN parameters passed to fitness function,If you give large values as lower upper bounds for example -Double MAX VALUE as a lower bound  the optimizer can call the fitness function with parameters set to NaN My guess is this is due to FitnessFunction encode decode generating NaN when normalizing denormalizing parameters For example if the difference between the lower and upper bound is greater than Double MAX VALUE encode could divide infinity by infinity ,If you give large values as lower upper bounds for example Double MAX VALUE as a lower bound  the optimizer can call the fitness function with parameters set to NaN My guess is this is due to FitnessFunction encode decode generating NaN when normalizing denormalizing parameters For example if the difference between the lower and upper bound is greater than Double MAX VALUE encode could divide infinity by infinity ,If you give large values as lower upper bounds for example Double MAX VALUE as a lower bound the optimizer can call the fitness function with parameters set to NaN My guess is this is due to FitnessFunction encode decode generating NaN when normalizing denormalizing parameters For example if the difference between the lower and upper bound is greater than Double MAX VALUE encode could divide infinity by infinity ,1
0,Math,Fraction double int  constructor strange behaviour,The Fraction constructor Fraction double int  takes a double value and a int maximal denominator and approximates a fraction When the double value is a large negative number with many digits in the fractional part and the maximal denominator is a big positive integer in the 100 000s  two distinct bugs can manifest: 1: the constructor returns a positive Fraction Calling Fraction -33655 1677817278 371880  returns the fraction 410517235 243036 which both has the wrong sign and is far away from the absolute value of the given value 2: the constructor does not manage to reduce the Fraction properly Calling Fraction -43979 60679604749 366081  returns the fraction -1651878166 256677 which should have been reduced to -24654898 3831 I have as of yet not found a solution The constructor looks like this: public Fraction double value int maxDenominator  throws FractionConversionException { this value 0 maxDenominator 100 ; } Increasing the 100 value max iterations  does not fix the problem for all cases Changing the 0-value the epsilon maximum allowed error  to something small does not work either as this breaks the tests in FractionTest The problem is not neccissarily that the algorithm is unable to approximate a fraction correctly A solution where a FractionConversionException had been thrown in each of these examples would probably be the best solution if an improvement on the approximation algorithm turns out to be hard to find This bug has been found when trying to explore the idea of axiom-based testing http: bldl ii uib no testing html  Attached is a java test class FractionTestByAxiom junit goes into org apache commons math3 fraction  which shows these bugs through a simplified approach to this kind of testing and a text file describing some of the value maxDenominator combinations which causes one of these failures It is never specified in the documentation that the Fraction class guarantees that completely reduced rational numbers are constructed but a comment inside the equals method claims that since fractions are always in lowest terms numerators and can be compared directly for equality so it seems like this is the intention ,The Fraction constructor Fraction double int  takes a double value and a int maximal denominator and approximates a fraction When the double value is a large negative number with many digits in the fractional part and the maximal denominator is a big positive integer in the  s  two distinct bugs can manifest: : the constructor returns a positive Fraction Calling Fraction     returns the fraction   which both has the wrong sign and is far away from the absolute value of the given value : the constructor does not manage to reduce the Fraction properly Calling Fraction     returns the fraction   which should have been reduced to   I have as of yet not found a solution The constructor looks like this: public Fraction double value int maxDenominator  throws FractionConversionException { this value  maxDenominator  ; } Increasing the  value max iterations  does not fix the problem for all cases Changing the value the epsilon maximum allowed error  to something small does not work either as this breaks the tests in FractionTest The problem is not neccissarily that the algorithm is unable to approximate a fraction correctly A solution where a FractionConversionException had been thrown in each of these examples would probably be the best solution if an improvement on the approximation algorithm turns out to be hard to find This bug has been found when trying to explore the idea of axiombased testing http: bldl ii uib no testing html  Attached is a java test class FractionTestByAxiom junit goes into org apache commons math fraction  which shows these bugs through a simplified approach to this kind of testing and a text file describing some of the value maxDenominator combinations which causes one of these failures It is never specified in the documentation that the Fraction class guarantees that completely reduced rational numbers are constructed but a comment inside the equals method claims that since fractions are always in lowest terms numerators and can be compared directly for equality so it seems like this is the intention ,The Fraction constructor Fraction double int takes a double value and a int maximal denominator and approximates a fraction When the double value is a large negative number with many digits in the fractional part and the maximal denominator is a big positive integer in the s two distinct bugs can manifest: : the constructor returns a positive Fraction Calling Fraction returns the fraction which both has the wrong sign and is far away from the absolute value of the given value : the constructor does not manage to reduce the Fraction properly Calling Fraction returns the fraction which should have been reduced to I have as of yet not found a solution The constructor looks like this: public Fraction double value int maxDenominator throws FractionConversionException { this value maxDenominator ; } Increasing the value max iterations does not fix the problem for all cases Changing the value the epsilon maximum allowed error to something small does not work either as this breaks the tests in FractionTest The problem is not neccissarily that the algorithm is unable to approximate a fraction correctly A solution where a FractionConversionException had been thrown in each of these examples would probably be the best solution if an improvement on the approximation algorithm turns out to be hard to find This bug has been found when trying to explore the idea of axiombased testing http: bldl ii uib no testing html Attached is a java test class FractionTestByAxiom junit goes into org apache commons math fraction which shows these bugs through a simplified approach to this kind of testing and a text file describing some of the value maxDenominator combinations which causes one of these failures It is never specified in the documentation that the Fraction class guarantees that completely reduced rational numbers are constructed but a comment inside the equals method claims that since fractions are always in lowest terms numerators and can be compared directly for equality so it seems like this is the intention ,1
0,Math,DiscreteDistribution sample int  may throw an exception if first element of singletons of sub-class type,Creating an array with Array newInstance singletons get 0  getClass   sampleSize  in DiscreteDistribution sample int  is risky An exception will be thrown if: singleons get 0  is of type T1 an sub-class of T and DiscreteDistribution sample   returns an object which is of type T but not of type T1 To reproduce: List<Pair<Object Double>> list = new ArrayList<Pair<Object Double>>  ; list add new Pair<Object Double> new Object   {} new Double 0 ; list add new Pair<Object Double> new Object   {} new Double 1 ; new DiscreteDistribution<Object> list  sample 1 ; Attaching a patch ,Creating an array with Array newInstance singletons get   getClass   sampleSize  in DiscreteDistribution sample int  is risky An exception will be thrown if: singleons get   is of type T an subclass of T and DiscreteDistribution sample   returns an object which is of type T but not of type T To reproduce: List<Pair<Object Double>> list = new ArrayList<Pair<Object Double>>  ; list add new Pair<Object Double> new Object   {} new Double  ; list add new Pair<Object Double> new Object   {} new Double  ; new DiscreteDistribution<Object> list  sample  ; Attaching a patch ,Creating an array with Array newInstance singletons get getClass sampleSize in DiscreteDistribution sample int is risky An exception will be thrown if: singleons get is of type T an subclass of T and DiscreteDistribution sample returns an object which is of type T but not of type T To reproduce: List<Pair<Object Double>> list = new ArrayList<Pair<Object Double>> ; list add new Pair<Object Double> new Object {} new Double ; list add new Pair<Object Double> new Object {} new Double ; new DiscreteDistribution<Object> list sample ; Attaching a patch ,1
0,Math,Correlated random vector generator fails silently  when faced with zero rows in covariance matrix,The following three matrices which are basically permutations of each other  produce different results when sampling a multi-variate Gaussian with the help of CorrelatedRandomVectorGenerator sample covariances calculated in R based on 10 000 samples : Array2DRowRealMatrix { {0 0 0 0 0 0 0 0 0 0} {0 0 0 013445532 0 01039469 0 009881156 0 010499559} {0 0 0 01039469 0 023006616 0 008196856 0 010732709} {0 0 0 009881156 0 008196856 0 019023866 0 009210099} {0 0 0 010499559 0 010732709 0 009210099 0 019107243}} > cov data1  V1 V2 V3 V4 V5 V1 0 0 000000000 0 00000000 0 000000000 0 000000000 V2 0 0 013383931 0 01034401 0 009913271 0 010506733 V3 0 0 010344006 0 02309479 0 008374730 0 010759306 V4 0 0 009913271 0 00837473 0 019005488 0 009187287 V5 0 0 010506733 0 01075931 0 009187287 0 019021483 Array2DRowRealMatrix { {0 013445532 0 01039469 0 0 0 009881156 0 010499559} {0 01039469 0 023006616 0 0 0 008196856 0 010732709} {0 0 0 0 0 0 0 0 0 0} {0 009881156 0 008196856 0 0 0 019023866 0 009210099} {0 010499559 0 010732709 0 0 0 009210099 0 019107243}} > cov data2  V1 V2 V3 V4 V5 V1 0 006922905 0 010507692 0 0 005817399 0 010330529 V2 0 010507692 0 023428918 0 0 008273152 0 010735568 V3 0 000000000 0 000000000 0 0 000000000 0 000000000 V4 0 005817399 0 008273152 0 0 004929843 0 009048759 V5 0 010330529 0 010735568 0 0 009048759 0 018683544 Array2DRowRealMatrix{ {0 013445532 0 01039469 0 009881156 0 010499559} {0 01039469 0 023006616 0 008196856 0 010732709} {0 009881156 0 008196856 0 019023866 0 009210099} {0 010499559 0 010732709 0 009210099 0 019107243}} > cov data3  V1 V2 V3 V4 V1 0 013445047 0 010478862 0 009955904 0 010529542 V2 0 010478862 0 022910522 0 008610113 0 011046353 V3 0 009955904 0 008610113 0 019250975 0 009464442 V4 0 010529542 0 011046353 0 009464442 0 019260317 I ve traced this back to the RectangularCholeskyDecomposition which does not seem to handle the second matrix very well decompositions in the same order as the matrices above : CorrelatedRandomVectorGenerator getRootMatrix   = Array2DRowRealMatrix{{0 0 0 0 0 0 0 0 0 0} {0 0759577418122063 0 0876125188474239 0 0 0 0 0 0} {0 07764443622513505 0 05132821221460752 0 11976381821791235 0 0 0 0} {0 06662930527909404 0 05501661744114585 0 0016662506519307997 0 10749324207653632 0 0} {0 13822895138139477 0 0 0 0 0 0 0 0}} CorrelatedRandomVectorGenerator getRank   = 5 CorrelatedRandomVectorGenerator getRootMatrix   = Array2DRowRealMatrix{{0 0759577418122063 0 034512751379448724 0 0} {0 07764443622513505 0 13029949164628746 0 0} {0 0 0 0 0 0} {0 06662930527909404 0 023203936694855674 0 0} {0 13822895138139477 0 0 0 0}} CorrelatedRandomVectorGenerator getRank   = 3 CorrelatedRandomVectorGenerator getRootMatrix   = Array2DRowRealMatrix{{0 0759577418122063 0 034512751379448724 0 033913748226348225 0 07303890149947785} {0 07764443622513505 0 13029949164628746 0 0 0 0} {0 06662930527909404 0 023203936694855674 0 11851573313229945 0 0} {0 13822895138139477 0 0 0 0 0 0}} CorrelatedRandomVectorGenerator getRank   = 4 Clearly the rank of each of these matrices should be 4 The first matrix does not lead to incorrect results but the second one does Unfortunately I don t know enough about the Cholesky decomposition to find the flaw in the implementation and I could not find documentation for the rectangular variant also not at the links provided in the javadoc  ,The following three matrices which are basically permutations of each other  produce different results when sampling a multivariate Gaussian with the help of CorrelatedRandomVectorGenerator sample covariances calculated in R based on   samples : ArrayDRowRealMatrix { {         } {         } {         } {         } {         }} > cov data  V V V V V V          V          V          V          V          ArrayDRowRealMatrix { {         } {         } {         } {         } {         }} > cov data  V V V V V V          V          V          V          V          ArrayDRowRealMatrix{ {       } {       } {       } {       }} > cov data  V V V V V         V         V         V         I ve traced this back to the RectangularCholeskyDecomposition which does not seem to handle the second matrix very well decompositions in the same order as the matrices above : CorrelatedRandomVectorGenerator getRootMatrix   = ArrayDRowRealMatrix{{         } {         } {         } {         } {         }} CorrelatedRandomVectorGenerator getRank   =  CorrelatedRandomVectorGenerator getRootMatrix   = ArrayDRowRealMatrix{{     } {     } {     } {     } {     }} CorrelatedRandomVectorGenerator getRank   =  CorrelatedRandomVectorGenerator getRootMatrix   = ArrayDRowRealMatrix{{       } {       } {       } {       }} CorrelatedRandomVectorGenerator getRank   =  Clearly the rank of each of these matrices should be  The first matrix does not lead to incorrect results but the second one does Unfortunately I don t know enough about the Cholesky decomposition to find the flaw in the implementation and I could not find documentation for the rectangular variant also not at the links provided in the javadoc  ,The following three matrices which are basically permutations of each other produce different results when sampling a multivariate Gaussian with the help of CorrelatedRandomVectorGenerator sample covariances calculated in R based on samples : ArrayDRowRealMatrix { { } { } { } { } { }} > cov data V V V V V V V V V V ArrayDRowRealMatrix { { } { } { } { } { }} > cov data V V V V V V V V V V ArrayDRowRealMatrix{ { } { } { } { }} > cov data V V V V V V V V I ve traced this back to the RectangularCholeskyDecomposition which does not seem to handle the second matrix very well decompositions in the same order as the matrices above : CorrelatedRandomVectorGenerator getRootMatrix = ArrayDRowRealMatrix{{ } { } { } { } { }} CorrelatedRandomVectorGenerator getRank = CorrelatedRandomVectorGenerator getRootMatrix = ArrayDRowRealMatrix{{ } { } { } { } { }} CorrelatedRandomVectorGenerator getRank = CorrelatedRandomVectorGenerator getRootMatrix = ArrayDRowRealMatrix{{ } { } { } { }} CorrelatedRandomVectorGenerator getRank = Clearly the rank of each of these matrices should be The first matrix does not lead to incorrect results but the second one does Unfortunately I don t know enough about the Cholesky decomposition to find the flaw in the implementation and I could not find documentation for the rectangular variant also not at the links provided in the javadoc ,1
0,Math,In stat Frequency getPct Object  uses getCumPct Comparable  instead of getPct Comparable ,Drop in Replacement of 1 2 with 2 0 not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v  deprecated replaced by { link  getPct Comparable } as of 2 0  Deprecated public double getPct Object v  { return getCumPct Comparable< >  v ; },Drop in Replacement of   with   not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v  deprecated replaced by { link  getPct Comparable } as of    Deprecated public double getPct Object v  { return getCumPct Comparable< >  v ; },Drop in Replacement of with not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v deprecated replaced by { link getPct Comparable } as of Deprecated public double getPct Object v { return getCumPct Comparable< > v ; },1
0,Math,ArrayIndexOutOfBoundException in EigenDecompositionImpl,The following test triggers an ArrayIndexOutOfBoundException: public void testMath308   { double[] mainTridiagonal = { 22 330154644539597 46 65485522478641 17 393672330044705 54 46687435351116 80 17800767709437 }; double[] secondaryTridiagonal = { 13 04450406501361 -5 977590941539671 2 9040909856707517 7 1570352792841225 }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version 3 2 1 double[] refEigenValues = { 14 138204224043099 18 847969733754262 52 536278520113882 53 456697699894512 82 044413207204002 }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] { 0 584677060845929 -0 367177264979103 -0 721453187784497 0 052971054621812 -0 005740715188257 }  new ArrayRealVector new double[] { 0 713933751051495 -0 190582113553930 0 671410443368332 -0 056056055955050 0 006541576993581 }  new ArrayRealVector new double[] { 0 222368839324646 0 514921891363332 -0 021377019336614 0 801196801016305 -0 207446991247740 }  new ArrayRealVector new double[] { 0 314647769490148 0 750806415553905 -0 167700312025760 -0 537092972407375 0 143854968127780 }  new ArrayRealVector new double[] { -0 000462690386766 -0 002118073109055 0 011530080757413 0 252322434584915 0 967572088232592 }  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = 0; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i] 1 0e-6 ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  < 0  { assertEquals 0 refEigenVectors[i] add decomposition getEigenvector i  getNorm   1 0e-6 ; } else { assertEquals 0 refEigenVectors[i] subtract decomposition getEigenvector i  getNorm   1 0e-6 ; } } } Running the previous method as a Junit test triggers the exception when the EigenDecompositionImpl instance is built The first few lines of the stack trace are: java lang ArrayIndexOutOfBoundsException: -1 at org apache commons math linear EigenDecompositionImpl computeShiftIncrement EigenDecompositionImpl java:1545  at org apache commons math linear EigenDecompositionImpl goodStep EigenDecompositionImpl java:1072  at org apache commons math linear EigenDecompositionImpl processGeneralBlock EigenDecompositionImpl java:894  at org apache commons math linear EigenDecompositionImpl findEigenvalues EigenDecompositionImpl java:658  at org apache commons math linear EigenDecompositionImpl decompose EigenDecompositionImpl java:246  at org apache commons math linear EigenDecompositionImpl <init> EigenDecompositionImpl java:205  at org apache commons math linear EigenDecompositionImplTest testMath308 EigenDecompositionImplTest java:136  I m currently investigating this bug It is not a simple index translation error between the original fortran Lapack  and commons-math implementation ,The following test triggers an ArrayIndexOutOfBoundException: public void testMath   { double[] mainTridiagonal = {           }; double[] secondaryTridiagonal = {         }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version    double[] refEigenValues = {           }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] {           }  new ArrayRealVector new double[] {           }  new ArrayRealVector new double[] {           }  new ArrayRealVector new double[] {           }  new ArrayRealVector new double[] {           }  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = ; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i]  e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  <   { assertEquals  refEigenVectors[i] add decomposition getEigenvector i  getNorm    e ; } else { assertEquals  refEigenVectors[i] subtract decomposition getEigenvector i  getNorm    e ; } } } Running the previous method as a Junit test triggers the exception when the EigenDecompositionImpl instance is built The first few lines of the stack trace are: java lang ArrayIndexOutOfBoundsException:  at org apache commons math linear EigenDecompositionImpl computeShiftIncrement EigenDecompositionImpl java:  at org apache commons math linear EigenDecompositionImpl goodStep EigenDecompositionImpl java:  at org apache commons math linear EigenDecompositionImpl processGeneralBlock EigenDecompositionImpl java:  at org apache commons math linear EigenDecompositionImpl findEigenvalues EigenDecompositionImpl java:  at org apache commons math linear EigenDecompositionImpl decompose EigenDecompositionImpl java:  at org apache commons math linear EigenDecompositionImpl <init> EigenDecompositionImpl java:  at org apache commons math linear EigenDecompositionImplTest testMath EigenDecompositionImplTest java:  I m currently investigating this bug It is not a simple index translation error between the original fortran Lapack  and commonsmath implementation ,The following test triggers an ArrayIndexOutOfBoundException: public void testMath { double[] mainTridiagonal = { }; double[] secondaryTridiagonal = { }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version double[] refEigenValues = { }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues ; for int i = ; i < refEigenValues length; i { assertEquals refEigenValues[i] eigenValues[i] e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i < { assertEquals refEigenVectors[i] add decomposition getEigenvector i getNorm e ; } else { assertEquals refEigenVectors[i] subtract decomposition getEigenvector i getNorm e ; } } } Running the previous method as a Junit test triggers the exception when the EigenDecompositionImpl instance is built The first few lines of the stack trace are: java lang ArrayIndexOutOfBoundsException: at org apache commons math linear EigenDecompositionImpl computeShiftIncrement EigenDecompositionImpl java: at org apache commons math linear EigenDecompositionImpl goodStep EigenDecompositionImpl java: at org apache commons math linear EigenDecompositionImpl processGeneralBlock EigenDecompositionImpl java: at org apache commons math linear EigenDecompositionImpl findEigenvalues EigenDecompositionImpl java: at org apache commons math linear EigenDecompositionImpl decompose EigenDecompositionImpl java: at org apache commons math linear EigenDecompositionImpl <init> EigenDecompositionImpl java: at org apache commons math linear EigenDecompositionImplTest testMath EigenDecompositionImplTest java: I m currently investigating this bug It is not a simple index translation error between the original fortran Lapack and commonsmath implementation ,1
0,Math,testing for symmetric positive definite matrix in CholeskyDecomposition,I used this matrix: double[][] cv = { {0 40434286 0 09376327 0 30328980 0 04909388} {0 09376327 0 10400408 0 07137959 0 04762857} {0 30328980 0 07137959 0 30458776 0 04882449} {0 04909388 0 04762857 0 04882449 0 07543265} }; And it works fine because it is symmetric positive definite I tried this matrix: double[][] cv = { {0 40434286 -0 09376327 0 30328980 0 04909388} {-0 09376327 0 10400408 0 07137959 0 04762857} {0 30328980 0 07137959 0 30458776 0 04882449} {0 04909388 0 04762857 0 04882449 0 07543265} }; And it should throw an exception but it does not I tested the matrix in R and R s cholesky decomposition method returns that the matrix is not symmetric positive definite Obviously your code is not catching this appropriately By the way in my opinion  the use of exceptions to check these conditions is not the best design or use for exceptions If you are going to force the use to try and catch these exceptions at least provide methods to test the conditions prior to the possibility of the exception ,I used this matrix: double[][] cv = { {       } {       } {       } {       } }; And it works fine because it is symmetric positive definite I tried this matrix: double[][] cv = { {       } {       } {       } {       } }; And it should throw an exception but it does not I tested the matrix in R and R s cholesky decomposition method returns that the matrix is not symmetric positive definite Obviously your code is not catching this appropriately By the way in my opinion  the use of exceptions to check these conditions is not the best design or use for exceptions If you are going to force the use to try and catch these exceptions at least provide methods to test the conditions prior to the possibility of the exception ,I used this matrix: double[][] cv = { { } { } { } { } }; And it works fine because it is symmetric positive definite I tried this matrix: double[][] cv = { { } { } { } { } }; And it should throw an exception but it does not I tested the matrix in R and R s cholesky decomposition method returns that the matrix is not symmetric positive definite Obviously your code is not catching this appropriately By the way in my opinion the use of exceptions to check these conditions is not the best design or use for exceptions If you are going to force the use to try and catch these exceptions at least provide methods to test the conditions prior to the possibility of the exception ,1
0,Math,Brent solver returns the wrong value if either bracket endpoint is root,The solve final UnivariateRealFunction f final double min final double max final double initial  function returns yMin or yMax if min or max are deemed to be roots respectively instead of min or max ,The solve final UnivariateRealFunction f final double min final double max final double initial  function returns yMin or yMax if min or max are deemed to be roots respectively instead of min or max ,The solve final UnivariateRealFunction f final double min final double max final double initial function returns yMin or yMax if min or max are deemed to be roots respectively instead of min or max ,1
0,Math,Incomplete reinitialization with some events handling,I get a bug with event handling: I track 2 events that occur in the same step when the first one is accepted it resets the state but the reinitialization is not complete and the second one becomes unable to find its way I can t give my context which is rather large but I tried a patch that works for me unfortunately it breaks the unit tests ,I get a bug with event handling: I track  events that occur in the same step when the first one is accepted it resets the state but the reinitialization is not complete and the second one becomes unable to find its way I can t give my context which is rather large but I tried a patch that works for me unfortunately it breaks the unit tests ,I get a bug with event handling: I track events that occur in the same step when the first one is accepted it resets the state but the reinitialization is not complete and the second one becomes unable to find its way I can t give my context which is rather large but I tried a patch that works for me unfortunately it breaks the unit tests ,1
0,Math,Statistics setVarianceImpl makes getStandardDeviation produce NaN,Invoking SummaryStatistics setVarianceImpl new Variance true false  makes getStandardDeviation produce NaN The code to reproduce it: int[] scores = {1 2 3 4}; SummaryStatistics stats = new SummaryStatistics  ; stats setVarianceImpl new Variance false ; use population variance for int i : scores  { stats addValue i ; } double sd = stats getStandardDeviation  ; System out println sd ; A workaround suggested by Mikkel is: double sd = FastMath sqrt stats getSecondMoment   stats getN  ;,Invoking SummaryStatistics setVarianceImpl new Variance true false  makes getStandardDeviation produce NaN The code to reproduce it: int[] scores = {   }; SummaryStatistics stats = new SummaryStatistics  ; stats setVarianceImpl new Variance false ; use population variance for int i : scores  { stats addValue i ; } double sd = stats getStandardDeviation  ; System out println sd ; A workaround suggested by Mikkel is: double sd = FastMath sqrt stats getSecondMoment   stats getN  ;,Invoking SummaryStatistics setVarianceImpl new Variance true false makes getStandardDeviation produce NaN The code to reproduce it: int[] scores = { }; SummaryStatistics stats = new SummaryStatistics ; stats setVarianceImpl new Variance false ; use population variance for int i : scores { stats addValue i ; } double sd = stats getStandardDeviation ; System out println sd ; A workaround suggested by Mikkel is: double sd = FastMath sqrt stats getSecondMoment stats getN ;,1
0,Math,Simplex Solver arrives at incorrect solution,I have reduced the problem reported to me down to a minimal test case which I will attach ,I have reduced the problem reported to me down to a minimal test case which I will attach ,I have reduced the problem reported to me down to a minimal test case which I will attach ,1
0,Math,Errors in BOBYQAOptimizer when numberOfInterpolationPoints is greater than 2 dim 1,I ve been having trouble getting BOBYQA to minimize a function actually a non-linear least squares fit  so as one change I increased the number of interpolation points It seems that anything larger than 2 dim 1 causes an error typically at line 1662 interpolationPoints setEntry nfm ipt interpolationPoints getEntry ipt ipt ; I m guessing there is an off by one error in the translation from FORTRAN Changing the BOBYQAOptimizerTest as follows increasing number of interpolation points by one  will cause failures Bruce Index: src test java org apache commons math optimization direct BOBYQAOptimizerTest java ===================================================================   src test java org apache commons math optimization direct BOBYQAOptimizerTest java revision 1221065  src test java org apache commons math optimization direct BOBYQAOptimizerTest java working copy    -258 7 258 7   RealPointValuePair result = optim optimize 100000 func goal startPoint ; final double[] lB = boundaries == null null : boundaries[0]; final double[] uB = boundaries == null null : boundaries[1]; BOBYQAOptimizer optim = new BOBYQAOptimizer 2 dim 1 ; BOBYQAOptimizer optim = new BOBYQAOptimizer 2 dim 2 ; RealPointValuePair result = optim optimize maxEvaluations func goal startPoint lB uB ; System out println func getClass   getName   = optim getEvaluations   f  ;,I ve been having trouble getting BOBYQA to minimize a function actually a nonlinear least squares fit  so as one change I increased the number of interpolation points It seems that anything larger than  dim  causes an error typically at line  interpolationPoints setEntry nfm ipt interpolationPoints getEntry ipt ipt ; I m guessing there is an off by one error in the translation from FORTRAN Changing the BOBYQAOptimizerTest as follows increasing number of interpolation points by one  will cause failures Bruce Index: src test java org apache commons math optimization direct BOBYQAOptimizerTest java ===================================================================   src test java org apache commons math optimization direct BOBYQAOptimizerTest java revision   src test java org apache commons math optimization direct BOBYQAOptimizerTest java working copy          RealPointValuePair result = optim optimize  func goal startPoint ; final double[] lB = boundaries == null null : boundaries[]; final double[] uB = boundaries == null null : boundaries[]; BOBYQAOptimizer optim = new BOBYQAOptimizer  dim  ; BOBYQAOptimizer optim = new BOBYQAOptimizer  dim  ; RealPointValuePair result = optim optimize maxEvaluations func goal startPoint lB uB ; System out println func getClass   getName   = optim getEvaluations   f  ;,I ve been having trouble getting BOBYQA to minimize a function actually a nonlinear least squares fit so as one change I increased the number of interpolation points It seems that anything larger than dim causes an error typically at line interpolationPoints setEntry nfm ipt interpolationPoints getEntry ipt ipt ; I m guessing there is an off by one error in the translation from FORTRAN Changing the BOBYQAOptimizerTest as follows increasing number of interpolation points by one will cause failures Bruce Index: src test java org apache commons math optimization direct BOBYQAOptimizerTest java =================================================================== src test java org apache commons math optimization direct BOBYQAOptimizerTest java revision src test java org apache commons math optimization direct BOBYQAOptimizerTest java working copy RealPointValuePair result = optim optimize func goal startPoint ; final double[] lB = boundaries == null null : boundaries[]; final double[] uB = boundaries == null null : boundaries[]; BOBYQAOptimizer optim = new BOBYQAOptimizer dim ; BOBYQAOptimizer optim = new BOBYQAOptimizer dim ; RealPointValuePair result = optim optimize maxEvaluations func goal startPoint lB uB ; System out println func getClass getName = optim getEvaluations f ;,1
0,Math,BigFraction doubleValue   returns Double NaN for large numerators or denominators,The current implementation of doubleValue   divides numerator doubleValue   denominator doubleValue   BigInteger doubleValue   fails for any number greater than Double MAX VALUE So if the user has 308-digit numerator or denominator the resulting quotient fails even in cases where the result would be well inside Double s range I have a patch to fix it if I can figure out how to attach it here I will ,The current implementation of doubleValue   divides numerator doubleValue   denominator doubleValue   BigInteger doubleValue   fails for any number greater than Double MAX VALUE So if the user has digit numerator or denominator the resulting quotient fails even in cases where the result would be well inside Double s range I have a patch to fix it if I can figure out how to attach it here I will ,The current implementation of doubleValue divides numerator doubleValue denominator doubleValue BigInteger doubleValue fails for any number greater than Double MAX VALUE So if the user has digit numerator or denominator the resulting quotient fails even in cases where the result would be well inside Double s range I have a patch to fix it if I can figure out how to attach it here I will ,1
0,Math,inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials ,The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials Following code will be reproduce the problem System out println new BinomialDistributionImpl 1000000 0 5  inverseCumulativeProbability 0 5 ; This returns 499525 though it should be 499999 I m not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN As the result the checkedCumulativeProbability method doesn t work as expected ,The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials Following code will be reproduce the problem System out println new BinomialDistributionImpl     inverseCumulativeProbability   ; This returns  though it should be  I m not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN As the result the checkedCumulativeProbability method doesn t work as expected ,The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials Following code will be reproduce the problem System out println new BinomialDistributionImpl inverseCumulativeProbability ; This returns though it should be I m not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN As the result the checkedCumulativeProbability method doesn t work as expected ,1
0,Math,Fraction comparTo returns 0 for some differente fractions,If two different fractions evaluate to the same double due to limited precision the compareTo methode returns 0 as if they were identical value is roughly PI - 3 07e-18 Fraction pi1 = new Fraction 1068966896 340262731 ; value is roughly PI 1 936e-17 Fraction pi2 = new Fraction 411557987 131002976 ; System out println pi1 doubleValue   - pi2 doubleValue  ; exactly 0 0 due to limited IEEE754 precision System out println pi1 compareTo pi2 ; display 0 instead of a negative value,If two different fractions evaluate to the same double due to limited precision the compareTo methode returns  as if they were identical value is roughly PI   e Fraction pi = new Fraction   ; value is roughly PI  e Fraction pi = new Fraction   ; System out println pi doubleValue    pi doubleValue  ; exactly   due to limited IEEE precision System out println pi compareTo pi ; display  instead of a negative value,If two different fractions evaluate to the same double due to limited precision the compareTo methode returns as if they were identical value is roughly PI e Fraction pi = new Fraction ; value is roughly PI e Fraction pi = new Fraction ; System out println pi doubleValue pi doubleValue ; exactly due to limited IEEE precision System out println pi compareTo pi ; display instead of a negative value,1
0,Math,weight versus sigma in AbstractLeastSquares,In AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation In the method getRMS   these weights are multiplicative as they should unlike in getChiSquare   where it appears at the denominator If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi2 Once corrected getRMS   can even reduce public double getRMS   {return Math sqrt getChiSquare   rows ;},In AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation In the method getRMS   these weights are multiplicative as they should unlike in getChiSquare   where it appears at the denominator If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi Once corrected getRMS   can even reduce public double getRMS   {return Math sqrt getChiSquare   rows ;},In AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation In the method getRMS these weights are multiplicative as they should unlike in getChiSquare where it appears at the denominator If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi Once corrected getRMS can even reduce public double getRMS {return Math sqrt getChiSquare rows ;},1
0,Math,Miscellaneous issues concerning the optimization package,Revision 990792 contains changes triggered the following issues: MATH-394 MATH-397 MATH-404 This issue collects the currently still unsatisfactory code not necessarily sorted in order of annoyance : BrentOptimizer : a specific convergence checker must be used LevenbergMarquardtOptimizer also has specific convergence checks Trying to make convergence checking independent of the optimization algorithm creates problems conceptual and practical : See BrentOptimizer and LevenbergMarquardtOptimizer the algorithm passes points to the convergence checker but the actual meaning of the points can very well be different in the caller optimization algorithm  and the callee convergence checker  In PowellOptimizer the line search BrentOptimizer   tolerances depend on the tolerances within the main algorithm Since tolerances come with ConvergenceChecker and so can be changed at any time it is awkward to adapt the values within the line search optimizer without exposing its internals BrentOptimizer field  to the enclosing class PowellOptimizer   Given the numerous changes some Javadoc comments might be out-of-sync although I did try to update them all Class DirectSearchOptimizer in package optimization direct   inherits from class AbstractScalarOptimizer in package optimization general   Some interfaces are defined in package optimization but their base implementations abstract class that contain the boiler-plate code  are in package optimization general e g DifferentiableMultivariateVectorialOptimizer and BaseAbstractVectorialOptimizer   No check is performed to ensure the the convergence checker has been set see e g BrentOptimizer and PowellOptimizer  ; if it hasn t there will be a NPE The alternative is to initialize a default checker that will never be used in case the user had intended to explicitly sets the checker NonLinearConjugateGradientOptimizer : Ugly workaround for the checked ConvergenceException Everywhere we trail the checked FunctionEvaluationException although it is never used There remains some duplicate code such as the multi-start loop in the various MultiStart implementations  The ConvergenceChecker interface is very general the converged method can take any number of PointValuePair   However there remains a semantic problem: One cannot be sure that the list of points means the same thing for the caller of converged and within the implementation of the ConvergenceChecker that was independently set It is not clear whether it is wise to aggregate the counter of gradient evaluations to the function evaluation counter In LevenbergMarquartdOptimizer for example it would be unfair to do so Currently I had to remove all tests referring to gradient and Jacobian evaluations In AbstractLeastSquaresOptimizer and LevenbergMarquardtOptimizer occurences of OptimizationException were replaced by the unchecked ConvergenceException but in some cases it might not be the most appropriate one MultiStartUnivariateRealOptimizer : in the other classes MultiStartMultivariate   similar to this one the randomization is on the firts-guess value while in this class it is on the search interval I think that here also we should randomly choose the start value within the user-selected interval  The Javadoc utility raises warnings see output of mvn site   which I couldn t figure out how to correct Some previously existing classes and interfaces have become no more than a specialisation of new generics classes; it might be interesting to remove them in order to reduce the number of classes and thus limit the potential for confusion ,Revision  contains changes triggered the following issues: MATH MATH MATH This issue collects the currently still unsatisfactory code not necessarily sorted in order of annoyance : BrentOptimizer : a specific convergence checker must be used LevenbergMarquardtOptimizer also has specific convergence checks Trying to make convergence checking independent of the optimization algorithm creates problems conceptual and practical : See BrentOptimizer and LevenbergMarquardtOptimizer the algorithm passes points to the convergence checker but the actual meaning of the points can very well be different in the caller optimization algorithm  and the callee convergence checker  In PowellOptimizer the line search BrentOptimizer   tolerances depend on the tolerances within the main algorithm Since tolerances come with ConvergenceChecker and so can be changed at any time it is awkward to adapt the values within the line search optimizer without exposing its internals BrentOptimizer field  to the enclosing class PowellOptimizer   Given the numerous changes some Javadoc comments might be outofsync although I did try to update them all Class DirectSearchOptimizer in package optimization direct   inherits from class AbstractScalarOptimizer in package optimization general   Some interfaces are defined in package optimization but their base implementations abstract class that contain the boilerplate code  are in package optimization general e g DifferentiableMultivariateVectorialOptimizer and BaseAbstractVectorialOptimizer   No check is performed to ensure the the convergence checker has been set see e g BrentOptimizer and PowellOptimizer  ; if it hasn t there will be a NPE The alternative is to initialize a default checker that will never be used in case the user had intended to explicitly sets the checker NonLinearConjugateGradientOptimizer : Ugly workaround for the checked ConvergenceException Everywhere we trail the checked FunctionEvaluationException although it is never used There remains some duplicate code such as the multistart loop in the various MultiStart implementations  The ConvergenceChecker interface is very general the converged method can take any number of PointValuePair   However there remains a semantic problem: One cannot be sure that the list of points means the same thing for the caller of converged and within the implementation of the ConvergenceChecker that was independently set It is not clear whether it is wise to aggregate the counter of gradient evaluations to the function evaluation counter In LevenbergMarquartdOptimizer for example it would be unfair to do so Currently I had to remove all tests referring to gradient and Jacobian evaluations In AbstractLeastSquaresOptimizer and LevenbergMarquardtOptimizer occurences of OptimizationException were replaced by the unchecked ConvergenceException but in some cases it might not be the most appropriate one MultiStartUnivariateRealOptimizer : in the other classes MultiStartMultivariate   similar to this one the randomization is on the firtsguess value while in this class it is on the search interval I think that here also we should randomly choose the start value within the userselected interval  The Javadoc utility raises warnings see output of mvn site   which I couldn t figure out how to correct Some previously existing classes and interfaces have become no more than a specialisation of new generics classes; it might be interesting to remove them in order to reduce the number of classes and thus limit the potential for confusion ,Revision contains changes triggered the following issues: MATH MATH MATH This issue collects the currently still unsatisfactory code not necessarily sorted in order of annoyance : BrentOptimizer : a specific convergence checker must be used LevenbergMarquardtOptimizer also has specific convergence checks Trying to make convergence checking independent of the optimization algorithm creates problems conceptual and practical : See BrentOptimizer and LevenbergMarquardtOptimizer the algorithm passes points to the convergence checker but the actual meaning of the points can very well be different in the caller optimization algorithm and the callee convergence checker In PowellOptimizer the line search BrentOptimizer tolerances depend on the tolerances within the main algorithm Since tolerances come with ConvergenceChecker and so can be changed at any time it is awkward to adapt the values within the line search optimizer without exposing its internals BrentOptimizer field to the enclosing class PowellOptimizer Given the numerous changes some Javadoc comments might be outofsync although I did try to update them all Class DirectSearchOptimizer in package optimization direct inherits from class AbstractScalarOptimizer in package optimization general Some interfaces are defined in package optimization but their base implementations abstract class that contain the boilerplate code are in package optimization general e g DifferentiableMultivariateVectorialOptimizer and BaseAbstractVectorialOptimizer No check is performed to ensure the the convergence checker has been set see e g BrentOptimizer and PowellOptimizer ; if it hasn t there will be a NPE The alternative is to initialize a default checker that will never be used in case the user had intended to explicitly sets the checker NonLinearConjugateGradientOptimizer : Ugly workaround for the checked ConvergenceException Everywhere we trail the checked FunctionEvaluationException although it is never used There remains some duplicate code such as the multistart loop in the various MultiStart implementations The ConvergenceChecker interface is very general the converged method can take any number of PointValuePair However there remains a semantic problem: One cannot be sure that the list of points means the same thing for the caller of converged and within the implementation of the ConvergenceChecker that was independently set It is not clear whether it is wise to aggregate the counter of gradient evaluations to the function evaluation counter In LevenbergMarquartdOptimizer for example it would be unfair to do so Currently I had to remove all tests referring to gradient and Jacobian evaluations In AbstractLeastSquaresOptimizer and LevenbergMarquardtOptimizer occurences of OptimizationException were replaced by the unchecked ConvergenceException but in some cases it might not be the most appropriate one MultiStartUnivariateRealOptimizer : in the other classes MultiStartMultivariate similar to this one the randomization is on the firtsguess value while in this class it is on the search interval I think that here also we should randomly choose the start value within the userselected interval The Javadoc utility raises warnings see output of mvn site which I couldn t figure out how to correct Some previously existing classes and interfaces have become no more than a specialisation of new generics classes; it might be interesting to remove them in order to reduce the number of classes and thus limit the potential for confusion ,1
0,Math,Result of multiplying and equals for complex numbers is wrong,Hi The bug relates on complex numbers The methods multiply and equals of the class Complex are involved mathematic background: 0 i  -1 0i  = 0 -i  little java program output that shows the bug: ----------------------------------------------------------------------- import org apache commons math complex ; public class TestProg { public static void main String[] args  { ComplexFormat f = new ComplexFormat  ; Complex c1 = new Complex 0 1 ; Complex c2 = new Complex -1 0 ; Complex res = c1 multiply c2 ; Complex comp = new Complex 0 -1 ; System out println res: f format res ; System out println comp: f format comp ; System out println res=comp: res equals comp ; } } ----------------------------------------------------------------------- res: -0 - 1i comp: 0 - 1i res=comp: false ----------------------------------------------------------------------- I think the equals should return true The problem could either be the multiply method that gives -0 -1i  instead of 0 -1i  or if you think thats right the equals method has to be modified Good Luck Dieter,Hi The bug relates on complex numbers The methods multiply and equals of the class Complex are involved mathematic background:  i   i  =  i  little java program output that shows the bug:  import org apache commons math complex ; public class TestProg { public static void main String[] args  { ComplexFormat f = new ComplexFormat  ; Complex c = new Complex   ; Complex c = new Complex   ; Complex res = c multiply c ; Complex comp = new Complex   ; System out println res: f format res ; System out println comp: f format comp ; System out println res=comp: res equals comp ; } }  res:   i comp:   i res=comp: false  I think the equals should return true The problem could either be the multiply method that gives  i  instead of  i  or if you think thats right the equals method has to be modified Good Luck Dieter,Hi The bug relates on complex numbers The methods multiply and equals of the class Complex are involved mathematic background: i i = i little java program output that shows the bug: import org apache commons math complex ; public class TestProg { public static void main String[] args { ComplexFormat f = new ComplexFormat ; Complex c = new Complex ; Complex c = new Complex ; Complex res = c multiply c ; Complex comp = new Complex ; System out println res: f format res ; System out println comp: f format comp ; System out println res=comp: res equals comp ; } } res: i comp: i res=comp: false I think the equals should return true The problem could either be the multiply method that gives i instead of i or if you think thats right the equals method has to be modified Good Luck Dieter,1
0,Math,AbstractEstimator: getCovariances   and guessParametersErrors   crash when having bound parameters,the two methods getCovariances   and guessParametersErrors   from org apache commons math estimation AbstractEstimator crash with ArrayOutOfBounds exception when some of the parameters are bound The reason is that the Jacobian is calculated only for the unbound parameters in the code you loop through all parameters line  166: final int cols = problem getAllParameters   length; should be replaced by: final int cols = problem getUnboundParameters   length; similar changes could be done in guessParametersErrors   the dissadvantage of the above bug fix is that what is returned to the user is an array with smaller size than the number of all parameters Alternatively you can have some logic in the code which writes zeros for the elements of the covariance matrix corresponding to the bound parameters,the two methods getCovariances   and guessParametersErrors   from org apache commons math estimation AbstractEstimator crash with ArrayOutOfBounds exception when some of the parameters are bound The reason is that the Jacobian is calculated only for the unbound parameters in the code you loop through all parameters line  : final int cols = problem getAllParameters   length; should be replaced by: final int cols = problem getUnboundParameters   length; similar changes could be done in guessParametersErrors   the dissadvantage of the above bug fix is that what is returned to the user is an array with smaller size than the number of all parameters Alternatively you can have some logic in the code which writes zeros for the elements of the covariance matrix corresponding to the bound parameters,the two methods getCovariances and guessParametersErrors from org apache commons math estimation AbstractEstimator crash with ArrayOutOfBounds exception when some of the parameters are bound The reason is that the Jacobian is calculated only for the unbound parameters in the code you loop through all parameters line : final int cols = problem getAllParameters length; should be replaced by: final int cols = problem getUnboundParameters length; similar changes could be done in guessParametersErrors the dissadvantage of the above bug fix is that what is returned to the user is an array with smaller size than the number of all parameters Alternatively you can have some logic in the code which writes zeros for the elements of the covariance matrix corresponding to the bound parameters,1
0,Math,class Dfp toDouble method return -inf whan Dfp value is 0 zero ,I found a bug in the toDouble   method of the Dfp class If the Dfp s value is 0 zero the toDouble   method returns a negative infini This is because the double value returned has an exposant equal to 0xFFF and a significand is equal to 0 In the IEEE754 this is a -inf To be equal to zero the exposant and the significand must be equal to zero A simple test case is : ---------------------------------------------- import org apache commons math dfp DfpField; public class test {  param args public static void main String[] args  { DfpField field = new DfpField 100 ; System out println toDouble value of getZero   = field getZero   toDouble   \ntoDouble value of newDfp 0 0  = field newDfp 0 0  toDouble  ; } } May be the simplest way to fix it is to test the zero equality at the begin of the toDouble   method to be able to return the correctly signed zero ,I found a bug in the toDouble   method of the Dfp class If the Dfp s value is  zero the toDouble   method returns a negative infini This is because the double value returned has an exposant equal to xFFF and a significand is equal to  In the IEEE this is a inf To be equal to zero the exposant and the significand must be equal to zero A simple test case is :  import org apache commons math dfp DfpField; public class test {  param args public static void main String[] args  { DfpField field = new DfpField  ; System out println toDouble value of getZero   = field getZero   toDouble   \ntoDouble value of newDfp    = field newDfp    toDouble  ; } } May be the simplest way to fix it is to test the zero equality at the begin of the toDouble   method to be able to return the correctly signed zero ,I found a bug in the toDouble method of the Dfp class If the Dfp s value is zero the toDouble method returns a negative infini This is because the double value returned has an exposant equal to xFFF and a significand is equal to In the IEEE this is a inf To be equal to zero the exposant and the significand must be equal to zero A simple test case is : import org apache commons math dfp DfpField; public class test { param args public static void main String[] args { DfpField field = new DfpField ; System out println toDouble value of getZero = field getZero toDouble \ntoDouble value of newDfp = field newDfp toDouble ; } } May be the simplest way to fix it is to test the zero equality at the begin of the toDouble method to be able to return the correctly signed zero ,1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line 640 in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line  in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,1
0,Math,Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the same,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to 1 1  ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to    ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to ,1
0,Math,Mann-Whitney U Test Suffers From Integer Overflow With Large Data Sets,When performing a Mann-Whitney U Test on large data sets the attached test uses two 1500 element sets  intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,When performing a MannWhitney U Test on large data sets the attached test uses two  element sets  intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as pvalues of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,When performing a MannWhitney U Test on large data sets the attached test uses two element sets intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as pvalues of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,1
0,Math,[math] Complex Tanh for big numbers,Hi In Complex java the tanh is computed with the following formula: tanh a bi  = sinh 2a  cosh 2a cos 2b  [sin 2b  cosh 2a cos 2b ]i The problem that I m finding is that as soon as a is a big number both sinh 2a  and cosh 2a  are infinity and then the method tanh returns in the real part NaN infinity infinity  when it should return 1 0 Wouldn t it be appropiate to add something as in the FastMath library : if real>20 0 { return createComplex 1 0 0 0 ; } if real<-20 0 { return createComplex -1 0 0 0 ; } Best regards JBB,Hi In Complex java the tanh is computed with the following formula: tanh a bi  = sinh a  cosh a cos b  [sin b  cosh a cos b ]i The problem that I m finding is that as soon as a is a big number both sinh a  and cosh a  are infinity and then the method tanh returns in the real part NaN infinity infinity  when it should return   Wouldn t it be appropiate to add something as in the FastMath library : if real>  { return createComplex     ; } if real<  { return createComplex     ; } Best regards JBB,Hi In Complex java the tanh is computed with the following formula: tanh a bi = sinh a cosh a cos b [sin b cosh a cos b ]i The problem that I m finding is that as soon as a is a big number both sinh a and cosh a are infinity and then the method tanh returns in the real part NaN infinity infinity when it should return Wouldn t it be appropiate to add something as in the FastMath library : if real> { return createComplex ; } if real< { return createComplex ; } Best regards JBB,1
0,Math,too large first step with embedded Runge-Kutta integrators Dormand-Prince 8 5 3   ,Adaptive step size integrators compute the first step size by themselves if it is not provided For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range and in fact it tries afterward to go back and fails to stop  Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed ,Adaptive step size integrators compute the first step size by themselves if it is not provided For embedded RungeKutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range and in fact it tries afterward to go back and fails to stop  GraggBulirschStoer integrators do not have this problem the step size is checked and truncated if needed ,Adaptive step size integrators compute the first step size by themselves if it is not provided For embedded RungeKutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range and in fact it tries afterward to go back and fails to stop GraggBulirschStoer integrators do not have this problem the step size is checked and truncated if needed ,1
0,Math,[math] Function math fraction ProperFractionFormat parse String ParsePosition  return illogical result,Hello I find illogical returned result from function Fraction parse String source ParsePostion pos  in class ProperFractionFormat of the Fraction Package  of the Commons Math library Please see the following code segment for more details: ProperFractionFormat properFormat = new ProperFractionFormat  ; result = null; String source = 1 -1 2 ; ParsePosition pos = new ParsePosition 0 ; Test 1 : fail public void testParseNegative  { String source = -1 -2 3 ; ParsePosition pos = new ParsePosition 0 ; Fraction actual = properFormat parse source pos ; assertNull actual ; } Test2: success public void testParseNegative  { String source = -1 -2 3 ; ParsePosition pos = new ParsePosition 0 ; Fraction actual = properFormat parse source pos ; return Fraction 1 3 assertEquals 1 source getNumerator  ; assertEquals 3 source getDenominator  ; } Note: Similarly when I passed in the following inputs: input 2: source = 1 2 -3 pos = 0  input 3: source = -1 -2 3 pos = 0  Function Fraction parse String ParsePosition  returned Fraction 1 3 means the result Fraction had numerator = 1 and denominator = 3 for all 3 inputs above I think the function does not handle parsing the numberator denominator properly incase input string provide invalid numerator denominator Thank you ,Hello I find illogical returned result from function Fraction parse String source ParsePostion pos  in class ProperFractionFormat of the Fraction Package  of the Commons Math library Please see the following code segment for more details: ProperFractionFormat properFormat = new ProperFractionFormat  ; result = null; String source =    ; ParsePosition pos = new ParsePosition  ; Test  : fail public void testParseNegative  { String source =    ; ParsePosition pos = new ParsePosition  ; Fraction actual = properFormat parse source pos ; assertNull actual ; } Test: success public void testParseNegative  { String source =    ; ParsePosition pos = new ParsePosition  ; Fraction actual = properFormat parse source pos ; return Fraction   assertEquals  source getNumerator  ; assertEquals  source getDenominator  ; } Note: Similarly when I passed in the following inputs: input : source =    pos =   input : source =    pos =   Function Fraction parse String ParsePosition  returned Fraction   means the result Fraction had numerator =  and denominator =  for all  inputs above I think the function does not handle parsing the numberator denominator properly incase input string provide invalid numerator denominator Thank you ,Hello I find illogical returned result from function Fraction parse String source ParsePostion pos in class ProperFractionFormat of the Fraction Package of the Commons Math library Please see the following code segment for more details: ProperFractionFormat properFormat = new ProperFractionFormat ; result = null; String source = ; ParsePosition pos = new ParsePosition ; Test : fail public void testParseNegative { String source = ; ParsePosition pos = new ParsePosition ; Fraction actual = properFormat parse source pos ; assertNull actual ; } Test: success public void testParseNegative { String source = ; ParsePosition pos = new ParsePosition ; Fraction actual = properFormat parse source pos ; return Fraction assertEquals source getNumerator ; assertEquals source getDenominator ; } Note: Similarly when I passed in the following inputs: input : source = pos = input : source = pos = Function Fraction parse String ParsePosition returned Fraction means the result Fraction had numerator = and denominator = for all inputs above I think the function does not handle parsing the numberator denominator properly incase input string provide invalid numerator denominator Thank you ,1
0,Math,MathUtils gcd Integer MIN VALUE 0  should throw an Exception instead of returning Integer MIN VALUE,The gcd method should throw an Exception for gcd Integer MIN VALUE 0  like for gcd Integer MIN VALUE Integer MIN VALUE  The method should only return nonnegative results ,The gcd method should throw an Exception for gcd Integer MIN VALUE   like for gcd Integer MIN VALUE Integer MIN VALUE  The method should only return nonnegative results ,The gcd method should throw an Exception for gcd Integer MIN VALUE like for gcd Integer MIN VALUE Integer MIN VALUE The method should only return nonnegative results ,1
0,Math,numerical problems in rotation creation,building a rotation from the following vector pairs leads to NaN: u1 = -4921140 837095533 -2 1512094250440013E7 -890093 279426377 u2 = -2 7238580938724895E9 -2 169664921341876E9 6 749688708885301E10 v1 = 1 0 0 v2 = 0 0 1 The constructor first changes the v1 v2  pair into v1 v2   ensuring the following scalar products hold: <v1 |v1 > == <u1|u1> <v2 |v2 > == <u2|u2> <u1 |u2> == <v1 |v2 > Once the v1 v2   pair has been computed we compute the cross product: k = v1 - u1  v2 - u2  and the scalar product: c = <k | u1 u2 > By construction c is positive or null and the quaternion axis we want to build is q = k [2 sqrt c ] c should be null only if some of the vectors are aligned and this is dealt with later in the algorithm However there are numerical problems with the vector above with the way these computations are done as shown by the following comparisons showing the result we get from our Java code and the result we get from manual computation with the same formulas but with enhanced precision: commons math: k = 38514476 5 -84 -1168590144 high precision: k = 38514410 36093388 -0 374075245201180409222711 -1168590152 10599715208 and it becomes worse when computing c because the vectors are almost orthogonal to each other hence inducing additional cancellations We get: commons math c = -1 2397173627587605E20 high precision: c = 558382746168463196 7079627 We have lost ALL significant digits in cancellations and even the sign is wrong ,building a rotation from the following vector pairs leads to NaN: u =    E   u =  E  E  E v =    v =    The constructor first changes the v v  pair into v v   ensuring the following scalar products hold: <v |v > == <u|u> <v |v > == <u|u> <u |u> == <v |v > Once the v v   pair has been computed we compute the cross product: k = v  u  v  u  and the scalar product: c = <k | u u > By construction c is positive or null and the quaternion axis we want to build is q = k [ sqrt c ] c should be null only if some of the vectors are aligned and this is dealt with later in the algorithm However there are numerical problems with the vector above with the way these computations are done as shown by the following comparisons showing the result we get from our Java code and the result we get from manual computation with the same formulas but with enhanced precision: commons math: k =     high precision: k =       and it becomes worse when computing c because the vectors are almost orthogonal to each other hence inducing additional cancellations We get: commons math c =  E high precision: c =   We have lost ALL significant digits in cancellations and even the sign is wrong ,building a rotation from the following vector pairs leads to NaN: u = E u = E E E v = v = The constructor first changes the v v pair into v v ensuring the following scalar products hold: <v |v > == <u|u> <v |v > == <u|u> <u |u> == <v |v > Once the v v pair has been computed we compute the cross product: k = v u v u and the scalar product: c = <k | u u > By construction c is positive or null and the quaternion axis we want to build is q = k [ sqrt c ] c should be null only if some of the vectors are aligned and this is dealt with later in the algorithm However there are numerical problems with the vector above with the way these computations are done as shown by the following comparisons showing the result we get from our Java code and the result we get from manual computation with the same formulas but with enhanced precision: commons math: k = high precision: k = and it becomes worse when computing c because the vectors are almost orthogonal to each other hence inducing additional cancellations We get: commons math c = E high precision: c = We have lost ALL significant digits in cancellations and even the sign is wrong ,1
0,Math,java lang StringIndexOutOfBoundsException in ComplexFormat parse String source ParsePosition pos ,The parse String source ParsePosition pos  method in the ComplexFormat class does not check whether the imaginary character is set or not which produces StringIndexOutOfBoundsException in the substring method : line 375 of ComplexFormat  parse imaginary character int n = getImaginaryCharacter   length  ; startIndex = pos getIndex  ; int endIndex = startIndex n; if source substring startIndex endIndex  compareTo getImaginaryCharacter   = 0  { I encoutered this exception typing in a JTextFied with ComplexFormat set to look up an AbstractFormatter If only the user types the imaginary part of the complex number first he gets this exception Solution: Before setting to n length of the imaginary character check if the source contains it My proposal: int n = 0; if source contains getImaginaryCharacter   n = getImaginaryCharacter   length  ; F S ,The parse String source ParsePosition pos  method in the ComplexFormat class does not check whether the imaginary character is set or not which produces StringIndexOutOfBoundsException in the substring method : line  of ComplexFormat  parse imaginary character int n = getImaginaryCharacter   length  ; startIndex = pos getIndex  ; int endIndex = startIndex n; if source substring startIndex endIndex  compareTo getImaginaryCharacter   =   { I encoutered this exception typing in a JTextFied with ComplexFormat set to look up an AbstractFormatter If only the user types the imaginary part of the complex number first he gets this exception Solution: Before setting to n length of the imaginary character check if the source contains it My proposal: int n = ; if source contains getImaginaryCharacter   n = getImaginaryCharacter   length  ; F S ,The parse String source ParsePosition pos method in the ComplexFormat class does not check whether the imaginary character is set or not which produces StringIndexOutOfBoundsException in the substring method : line of ComplexFormat parse imaginary character int n = getImaginaryCharacter length ; startIndex = pos getIndex ; int endIndex = startIndex n; if source substring startIndex endIndex compareTo getImaginaryCharacter = { I encoutered this exception typing in a JTextFied with ComplexFormat set to look up an AbstractFormatter If only the user types the imaginary part of the complex number first he gets this exception Solution: Before setting to n length of the imaginary character check if the source contains it My proposal: int n = ; if source contains getImaginaryCharacter n = getImaginaryCharacter length ; F S ,1
0,Math,Vector3D crossProduct is sensitive to numerical cancellation,Cross product implementation uses the naive formulas y1 z2 - y2 z1   These formulas fail when vectors are almost colinear like in the following example: Vector3D v1 = new Vector3D 9070467121 0 4535233560 0 1 ; Vector3D v2 = new Vector3D 9070467123 0 4535233561 0 1 ; System out println Vector3D crossProduct v1 v2 ; The previous code displays { -1 2 0 } instead of the correct answer { -1 2 1 },Cross product implementation uses the naive formulas y z  y z   These formulas fail when vectors are almost colinear like in the following example: VectorD v = new VectorD      ; VectorD v = new VectorD      ; System out println VectorD crossProduct v v ; The previous code displays {    } instead of the correct answer {    },Cross product implementation uses the naive formulas y z y z These formulas fail when vectors are almost colinear like in the following example: VectorD v = new VectorD ; VectorD v = new VectorD ; System out println VectorD crossProduct v v ; The previous code displays { } instead of the correct answer { },1
0,Math,BrentSolver throws IllegalArgumentException,I am getting this exception: java lang IllegalArgumentException: Function values at endpoints do not have different signs Endpoints: [-100000 0 1 7976931348623157E308] Values: [0 0 -101945 04630982173] at org apache commons math analysis BrentSolver solve BrentSolver java:99  at org apache commons math analysis BrentSolver solve BrentSolver java:62  The exception should not be thrown with values [0 0 -101945 04630982173] because 0 0 is positive According to Brent Worden the algorithm should stop and return 0 as the root instead of throwing an exception The problem comes from this method: public double solve double min double max  throws MaxIterationsExceededException FunctionEvaluationException { clearResult  ; verifyInterval min max ; double yMin = f value min ; double yMax = f value max ; Verify bracketing if yMin yMax >= 0  { throw new IllegalArgumentException Function values at endpoints do not have different signs Endpoints: [ min max ] Values: [ yMin yMax ]  ; } solve using only the first endpoint as initial guess return solve min yMin max yMax min yMin ; } One way to fix it would be to add this code after the assignment of yMin and yMax: if yMin ==0 || yMax == 0  { return 0; },I am getting this exception: java lang IllegalArgumentException: Function values at endpoints do not have different signs Endpoints: [   E] Values: [   ] at org apache commons math analysis BrentSolver solve BrentSolver java:  at org apache commons math analysis BrentSolver solve BrentSolver java:  The exception should not be thrown with values [   ] because   is positive According to Brent Worden the algorithm should stop and return  as the root instead of throwing an exception The problem comes from this method: public double solve double min double max  throws MaxIterationsExceededException FunctionEvaluationException { clearResult  ; verifyInterval min max ; double yMin = f value min ; double yMax = f value max ; Verify bracketing if yMin yMax >=   { throw new IllegalArgumentException Function values at endpoints do not have different signs Endpoints: [ min max ] Values: [ yMin yMax ]  ; } solve using only the first endpoint as initial guess return solve min yMin max yMax min yMin ; } One way to fix it would be to add this code after the assignment of yMin and yMax: if yMin == || yMax ==   { return ; },I am getting this exception: java lang IllegalArgumentException: Function values at endpoints do not have different signs Endpoints: [ E] Values: [ ] at org apache commons math analysis BrentSolver solve BrentSolver java: at org apache commons math analysis BrentSolver solve BrentSolver java: The exception should not be thrown with values [ ] because is positive According to Brent Worden the algorithm should stop and return as the root instead of throwing an exception The problem comes from this method: public double solve double min double max throws MaxIterationsExceededException FunctionEvaluationException { clearResult ; verifyInterval min max ; double yMin = f value min ; double yMax = f value max ; Verify bracketing if yMin yMax >= { throw new IllegalArgumentException Function values at endpoints do not have different signs Endpoints: [ min max ] Values: [ yMin yMax ] ; } solve using only the first endpoint as initial guess return solve min yMin max yMax min yMin ; } One way to fix it would be to add this code after the assignment of yMin and yMax: if yMin == || yMax == { return ; },1
0,Math,NaN in equals methods,In MathUtils some equals methods will return true if both argument are NaN Unless I m mistaken this contradicts the IEEE standard If nobody objects I m going to make the changes ,In MathUtils some equals methods will return true if both argument are NaN Unless I m mistaken this contradicts the IEEE standard If nobody objects I m going to make the changes ,In MathUtils some equals methods will return true if both argument are NaN Unless I m mistaken this contradicts the IEEE standard If nobody objects I m going to make the changes ,1
0,Math,Inconsistent result from Levenberg-Marquardt,Levenberg-Marquardt its method doOptimize  returns a VectorialPointValuePair However the class holds the optimum point the vector of the objective function the cost and residuals The value returns by doOptimize does not always corresponds to the point which leads to the residuals and cost,LevenbergMarquardt its method doOptimize  returns a VectorialPointValuePair However the class holds the optimum point the vector of the objective function the cost and residuals The value returns by doOptimize does not always corresponds to the point which leads to the residuals and cost,LevenbergMarquardt its method doOptimize returns a VectorialPointValuePair However the class holds the optimum point the vector of the objective function the cost and residuals The value returns by doOptimize does not always corresponds to the point which leads to the residuals and cost,1
0,Math,Bugs in Frequency API,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added - it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods - they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a non-Comparable object because the class cast exception is caught  however they just return 0 as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; 0 System out println f getPct OBJ ; 0 0 Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added  it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods  they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a nonComparable object because the class cast exception is caught  however they just return  as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ;  System out println f getPct OBJ ;   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return  or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object which should not allow a plain Object to be added it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object and getCumPct Object methods they will only work with objects that implement Comparable The getCount Object and getPct Object methods don t fail when given a nonComparable object because the class cast exception is caught however they just return as if the object was not present: final Object OBJ = new Object ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; System out println f getPct OBJ ; Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return or an Exception and applying the instanceof fix would also cause it to fail ,1
0,Math,Division by zero,In class Complex division by zero always returns NaN I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF See here ,In class Complex division by zero always returns NaN I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF See here ,In class Complex division by zero always returns NaN I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF See here ,1
0,Math,NPE in KMeansPlusPlusClusterer unittest,When running this unittest I am facing this NPE: java lang NullPointerException at org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java:91  This is the unittest: package org fao fisheries chronicles calcuation cluster; import static org junit Assert assertEquals; import static org junit Assert assertTrue; import java util Arrays; import java util List; import java util Random; import org apache commons math stat clustering Cluster; import org apache commons math stat clustering EuclideanIntegerPoint; import org apache commons math stat clustering KMeansPlusPlusClusterer; import org fao fisheries chronicles input CsvImportProcess; import org fao fisheries chronicles input Top200Csv; import org junit Test; public class ClusterAnalysisTest {  Test public void testPerformClusterAnalysis2   { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint> new Random 1746432956321l ; EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { new EuclideanIntegerPoint new int[] { 1959 325100 }   new EuclideanIntegerPoint new int[] { 1960 373200 }   }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer cluster Arrays asList points  1 1 ; assertEquals 1 clusters size  ; } },When running this unittest I am facing this NPE: java lang NullPointerException at org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java:  This is the unittest: package org fao fisheries chronicles calcuation cluster; import static org junit Assert assertEquals; import static org junit Assert assertTrue; import java util Arrays; import java util List; import java util Random; import org apache commons math stat clustering Cluster; import org apache commons math stat clustering EuclideanIntegerPoint; import org apache commons math stat clustering KMeansPlusPlusClusterer; import org fao fisheries chronicles input CsvImportProcess; import org fao fisheries chronicles input TopCsv; import org junit Test; public class ClusterAnalysisTest {  Test public void testPerformClusterAnalysis   { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint> new Random l ; EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { new EuclideanIntegerPoint new int[] {   }   new EuclideanIntegerPoint new int[] {   }   }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer cluster Arrays asList points    ; assertEquals  clusters size  ; } },When running this unittest I am facing this NPE: java lang NullPointerException at org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java: This is the unittest: package org fao fisheries chronicles calcuation cluster; import static org junit Assert assertEquals; import static org junit Assert assertTrue; import java util Arrays; import java util List; import java util Random; import org apache commons math stat clustering Cluster; import org apache commons math stat clustering EuclideanIntegerPoint; import org apache commons math stat clustering KMeansPlusPlusClusterer; import org fao fisheries chronicles input CsvImportProcess; import org fao fisheries chronicles input TopCsv; import org junit Test; public class ClusterAnalysisTest { Test public void testPerformClusterAnalysis { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint> new Random l ; EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { new EuclideanIntegerPoint new int[] { } new EuclideanIntegerPoint new int[] { } }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer cluster Arrays asList points ; assertEquals clusters size ; } },1
0,Math,One of Variance evaluate   methods does not work correctly,The method org apache commons math stat descriptive moment Variance evaluate double[] values double[] weights double mean int begin int length  does not work properly Looks loke it ignores the length parameter and grabs the whole dataset Similar method in Mean class seems to work I did not check other methods taking the part of the array; they may have the same problem Workaround: I had to shrink my arrays and use the method without the length ,The method org apache commons math stat descriptive moment Variance evaluate double[] values double[] weights double mean int begin int length  does not work properly Looks loke it ignores the length parameter and grabs the whole dataset Similar method in Mean class seems to work I did not check other methods taking the part of the array; they may have the same problem Workaround: I had to shrink my arrays and use the method without the length ,The method org apache commons math stat descriptive moment Variance evaluate double[] values double[] weights double mean int begin int length does not work properly Looks loke it ignores the length parameter and grabs the whole dataset Similar method in Mean class seems to work I did not check other methods taking the part of the array; they may have the same problem Workaround: I had to shrink my arrays and use the method without the length ,1
0,Math,SimplexSolver not working as expected ,I guess but I could be wrong  that SimplexSolver does not always return the optimal solution nor satisfies all the constraints Consider this LP: max: 0 8 x0 0 2 x1 0 7 x2 0 3 x3 0 6 x4 0 4 x5; r1: x0 x2 x4 = 23 0; r2: x1 x3 x5 = 23 0; r3: x0 >= 10 0; r4: x2 >= 8 0; r5: x4 >= 5 0; LPSolve returns 25 8 with x0 = 10 0 x1 = 0 0 x2 = 8 0 x3 = 0 0 x4 = 5 0 x5 = 23 0; The same LP expressed in Apache commons math is: LinearObjectiveFunction f = new LinearObjectiveFunction new double[] { 0 8 0 2 0 7 0 3 0 6 0 4 } 0  ; Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>  ; constraints add new LinearConstraint new double[] { 1 0 1 0 1 0 } Relationship EQ 23 0 ; constraints add new LinearConstraint new double[] { 0 1 0 1 0 1 } Relationship EQ 23 0 ; constraints add new LinearConstraint new double[] { 1 0 0 0 0 0 } Relationship GEQ 10 0 ; constraints add new LinearConstraint new double[] { 0 0 1 0 0 0 } Relationship GEQ 8 0 ; constraints add new LinearConstraint new double[] { 0 0 0 0 1 0 } Relationship GEQ 5 0 ; RealPointValuePair solution = new SimplexSolver   optimize f constraints GoalType MAXIMIZE true ; that returns 22 20 with x0 = 15 0 x1 = 23 0 x2 = 8 0 x3 = 0 0 x4 = 0 0 x5 = 0 0; Is it possible SimplexSolver is buggy that way The returned value is 22 20 instead of 25 8 and the last constraint x4 >= 5 0  is not satisfied Am I using the interface wrongly ,I guess but I could be wrong  that SimplexSolver does not always return the optimal solution nor satisfies all the constraints Consider this LP: max:   x   x   x   x   x   x; r: x x x =  ; r: x x x =  ; r: x >=  ; r: x >=  ; r: x >=  ; LPSolve returns   with x =   x =   x =   x =   x =   x =  ; The same LP expressed in Apache commons math is: LinearObjectiveFunction f = new LinearObjectiveFunction new double[] {             }   ; Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>  ; constraints add new LinearConstraint new double[] {       } Relationship EQ   ; constraints add new LinearConstraint new double[] {       } Relationship EQ   ; constraints add new LinearConstraint new double[] {       } Relationship GEQ   ; constraints add new LinearConstraint new double[] {       } Relationship GEQ   ; constraints add new LinearConstraint new double[] {       } Relationship GEQ   ; RealPointValuePair solution = new SimplexSolver   optimize f constraints GoalType MAXIMIZE true ; that returns   with x =   x =   x =   x =   x =   x =  ; Is it possible SimplexSolver is buggy that way The returned value is   instead of   and the last constraint x >=    is not satisfied Am I using the interface wrongly ,I guess but I could be wrong that SimplexSolver does not always return the optimal solution nor satisfies all the constraints Consider this LP: max: x x x x x x; r: x x x = ; r: x x x = ; r: x >= ; r: x >= ; r: x >= ; LPSolve returns with x = x = x = x = x = x = ; The same LP expressed in Apache commons math is: LinearObjectiveFunction f = new LinearObjectiveFunction new double[] { } ; Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint> ; constraints add new LinearConstraint new double[] { } Relationship EQ ; constraints add new LinearConstraint new double[] { } Relationship EQ ; constraints add new LinearConstraint new double[] { } Relationship GEQ ; constraints add new LinearConstraint new double[] { } Relationship GEQ ; constraints add new LinearConstraint new double[] { } Relationship GEQ ; RealPointValuePair solution = new SimplexSolver optimize f constraints GoalType MAXIMIZE true ; that returns with x = x = x = x = x = x = ; Is it possible SimplexSolver is buggy that way The returned value is instead of and the last constraint x >= is not satisfied Am I using the interface wrongly ,1
0,Math,getLInfNorm   uses wrong formula in both ArrayRealVector and OpenMapRealVector in different ways ,the L infinity norm of a finite dimensional vector is just the max of the absolute value of its entries The current implementation in ArrayRealVector has a typo: public double getLInfNorm   { double max = 0; for double a : data  { max = Math max max Math abs a ; } return max; } the = should just be an = There is sadly a unit test assuring us that this is the correct behavior effectively a regression-only test not a test for correctness  Worse the implementation in OpenMapRealVector is not even positive semi-definite: public double getLInfNorm   { double max = 0; Iterator iter = entries iterator  ; while iter hasNext   { iter advance  ; max = iter value  ; } return max; } I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator  : public double getLInfNorm   { double norm = 0; Iterator<Entry> it = sparseIterator  ; Entry e; while it hasNext     e = it next   = null  { norm = Math max norm Math abs e getValue  ; } return norm; } Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future ,the L infinity norm of a finite dimensional vector is just the max of the absolute value of its entries The current implementation in ArrayRealVector has a typo: public double getLInfNorm   { double max = ; for double a : data  { max = Math max max Math abs a ; } return max; } the = should just be an = There is sadly a unit test assuring us that this is the correct behavior effectively a regressiononly test not a test for correctness  Worse the implementation in OpenMapRealVector is not even positive semidefinite: public double getLInfNorm   { double max = ; Iterator iter = entries iterator  ; while iter hasNext   { iter advance  ; max = iter value  ; } return max; } I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator  : public double getLInfNorm   { double norm = ; Iterator<Entry> it = sparseIterator  ; Entry e; while it hasNext     e = it next   = null  { norm = Math max norm Math abs e getValue  ; } return norm; } Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future ,the L infinity norm of a finite dimensional vector is just the max of the absolute value of its entries The current implementation in ArrayRealVector has a typo: public double getLInfNorm { double max = ; for double a : data { max = Math max max Math abs a ; } return max; } the = should just be an = There is sadly a unit test assuring us that this is the correct behavior effectively a regressiononly test not a test for correctness Worse the implementation in OpenMapRealVector is not even positive semidefinite: public double getLInfNorm { double max = ; Iterator iter = entries iterator ; while iter hasNext { iter advance ; max = iter value ; } return max; } I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator : public double getLInfNorm { double norm = ; Iterator<Entry> it = sparseIterator ; Entry e; while it hasNext e = it next = null { norm = Math max norm Math abs e getValue ; } return norm; } Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future ,1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Math,MultiDirectional optimzation loops forver if started at the correct solution,MultiDirectional iterateSimplex loops forever if the starting point is the correct solution see the attached test case testMultiDirectionalCorrectStart  as an example ,MultiDirectional iterateSimplex loops forever if the starting point is the correct solution see the attached test case testMultiDirectionalCorrectStart  as an example ,MultiDirectional iterateSimplex loops forever if the starting point is the correct solution see the attached test case testMultiDirectionalCorrectStart as an example ,1
0,Math, BrentOptimizer not always reporting the best point,BrentOptimizer package o a c m optimization univariate   does not check that the point it is going to return is indeed the best one it has encountered Indeed the last evaluated point might be slightly worse than the one before last ,BrentOptimizer package o a c m optimization univariate   does not check that the point it is going to return is indeed the best one it has encountered Indeed the last evaluated point might be slightly worse than the one before last ,BrentOptimizer package o a c m optimization univariate does not check that the point it is going to return is indeed the best one it has encountered Indeed the last evaluated point might be slightly worse than the one before last ,1
0,Math, BrentOptimizer not always reporting the best point,BrentOptimizer package o a c m optimization univariate   does not check that the point it is going to return is indeed the best one it has encountered Indeed the last evaluated point might be slightly worse than the one before last ,BrentOptimizer package o a c m optimization univariate   does not check that the point it is going to return is indeed the best one it has encountered Indeed the last evaluated point might be slightly worse than the one before last ,BrentOptimizer package o a c m optimization univariate does not check that the point it is going to return is indeed the best one it has encountered Indeed the last evaluated point might be slightly worse than the one before last ,1
0,Math,NPE when calling SubLine intersection   with non-intersecting lines,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,1
0,Math,FastMath pow deviates from Math pow for negative finite base values with an exponent 2 52 < y < 2 53,As reported by Jeff Hain: pow double double : Math pow -1 0 5 000000000000001E15  = -1 0 FastMath pow -1 0 5 000000000000001E15  = 1 0 ===> This is due to considering that power is an even integer if it is >= 2 52 while you need to test that it is >= 2 53 for it ===> replace if y >= TWO POWER 52 || y <= -TWO POWER 52  with if y >= 2 TWO POWER 52 || y <= -2 TWO POWER 52  and that solves it ,As reported by Jeff Hain: pow double double : Math pow    E  =   FastMath pow    E  =   ===> This is due to considering that power is an even integer if it is >=   while you need to test that it is >=   for it ===> replace if y >= TWO POWER  || y <= TWO POWER   with if y >=  TWO POWER  || y <=  TWO POWER   and that solves it ,As reported by Jeff Hain: pow double double : Math pow E = FastMath pow E = ===> This is due to considering that power is an even integer if it is >= while you need to test that it is >= for it ===> replace if y >= TWO POWER || y <= TWO POWER with if y >= TWO POWER || y <= TWO POWER and that solves it ,1
0,Math,ArrayIndexOutOfBoundsException in MathArrays linearCombination,When MathArrays linearCombination is passed arguments with length 1 it throws an ArrayOutOfBoundsException This is caused by this line: double prodHighNext = prodHigh[1]; linearCombination should check the length of the arguments and fall back to simple multiplication if length == 1 ,When MathArrays linearCombination is passed arguments with length  it throws an ArrayOutOfBoundsException This is caused by this line: double prodHighNext = prodHigh[]; linearCombination should check the length of the arguments and fall back to simple multiplication if length ==  ,When MathArrays linearCombination is passed arguments with length it throws an ArrayOutOfBoundsException This is caused by this line: double prodHighNext = prodHigh[]; linearCombination should check the length of the arguments and fall back to simple multiplication if length == ,1
0,Math,GammaDistribution cloning broken,Serializing a GammaDistribution and deserializing it does not result in a cloned distribution that produces the same samples Cause: GammaDistribution inherits from AbstractRealDistribution which implements Serializable AbstractRealDistribution has random in which we have a Well19937c instance which inherits from AbstractWell AbstractWell implements Serializable AbstractWell inherits from BitsStreamGenerator which is not Serializable but does have a private field nextGaussian Solution: Make BitStreamGenerator implement Serializable as well This probably affects other distributions as well ,Serializing a GammaDistribution and deserializing it does not result in a cloned distribution that produces the same samples Cause: GammaDistribution inherits from AbstractRealDistribution which implements Serializable AbstractRealDistribution has random in which we have a Wellc instance which inherits from AbstractWell AbstractWell implements Serializable AbstractWell inherits from BitsStreamGenerator which is not Serializable but does have a private field nextGaussian Solution: Make BitStreamGenerator implement Serializable as well This probably affects other distributions as well ,Serializing a GammaDistribution and deserializing it does not result in a cloned distribution that produces the same samples Cause: GammaDistribution inherits from AbstractRealDistribution which implements Serializable AbstractRealDistribution has random in which we have a Wellc instance which inherits from AbstractWell AbstractWell implements Serializable AbstractWell inherits from BitsStreamGenerator which is not Serializable but does have a private field nextGaussian Solution: Make BitStreamGenerator implement Serializable as well This probably affects other distributions as well ,1
0,Math,bug in inverseCumulativeProbability   for Normal Distribution, version Revision: 617953 Date: 2008-02-02 22:54:00 -0700 Sat 02 Feb 2008  public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision: 506600 Date: 2007-02-12 12:35:59 -0700 Mon 12 Feb 2007  public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution 0 1 ; double result = normal inverseCumulativeProbability 0 9772498680518209 ; gives the exception below It should return approx  2 0000 normal inverseCumulativeProbability 0 977249868051820 ; works fine These also give errors: 0 9986501019683698 should return 3 0000   0 9999683287581673 should return 4 0000   org apache commons math MathException: Number of iterations=1 maximum iterations=2 147 483 647 initial=1 lower bound=0 upper bound=179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final a value=0 final b value=2 f a =-0 477 f b =0 at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:103  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java:145 , version Revision:  Date:  ::  Sat  Feb   public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision:  Date:  ::  Mon  Feb   public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution   ; double result = normal inverseCumulativeProbability   ; gives the exception below It should return approx    normal inverseCumulativeProbability   ; works fine These also give errors:   should return       should return     org apache commons math MathException: Number of iterations= maximum iterations=    initial= lower bound= upper bound=                                                                                                       final a value= final b value= f a =  f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: , version Revision: Date: :: Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision: Date: :: Mon Feb public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory ; NormalDistribution normal = factory createNormalDistribution ; double result = normal inverseCumulativeProbability ; gives the exception below It should return approx normal inverseCumulativeProbability ; works fine These also give errors: should return should return org apache commons math MathException: Number of iterations= maximum iterations= initial= lower bound= upper bound= final a value= final b value= f a = f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java: at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: ,1
0,Math,ODE integrator goes past specified end of integration range,End of integration range in ODE solving is handled as an event In some cases numerical accuracy in events detection leads to error in events location The following test case shows the end event is not handled properly and an integration that should cover a 60s range in fact covers a 160s range more than twice the specified range public void testMissedEvent   throws IntegratorException DerivativeException { final double t0 = 1878250320 0000029; final double t = 1878250379 9999986; FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations   { public int getDimension   { return 1; } public void computeDerivatives double t double[] y double[] yDot  throws DerivativeException { yDot[0] = y[0] 1 0e-6; } }; DormandPrince853Integrator integrator = new DormandPrince853Integrator 0 0 100 0 1 0e-10 1 0e-10 ; double[] y = { 1 0 }; integrator setInitialStepSize 60 0 ; double finalT = integrator integrate ode t0 y t y ; Assert assertEquals t finalT 1 0e-6 ; },End of integration range in ODE solving is handled as an event In some cases numerical accuracy in events detection leads to error in events location The following test case shows the end event is not handled properly and an integration that should cover a s range in fact covers a s range more than twice the specified range public void testMissedEvent   throws IntegratorException DerivativeException { final double t =  ; final double t =  ; FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations   { public int getDimension   { return ; } public void computeDerivatives double t double[] y double[] yDot  throws DerivativeException { yDot[] = y[]  e; } }; DormandPrinceIntegrator integrator = new DormandPrinceIntegrator      e  e ; double[] y = {   }; integrator setInitialStepSize   ; double finalT = integrator integrate ode t y t y ; Assert assertEquals t finalT  e ; },End of integration range in ODE solving is handled as an event In some cases numerical accuracy in events detection leads to error in events location The following test case shows the end event is not handled properly and an integration that should cover a s range in fact covers a s range more than twice the specified range public void testMissedEvent throws IntegratorException DerivativeException { final double t = ; final double t = ; FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations { public int getDimension { return ; } public void computeDerivatives double t double[] y double[] yDot throws DerivativeException { yDot[] = y[] e; } }; DormandPrinceIntegrator integrator = new DormandPrinceIntegrator e e ; double[] y = { }; integrator setInitialStepSize ; double finalT = integrator integrate ode t y t y ; Assert assertEquals t finalT e ; },1
0,Math,NaN singular value from SVD,The following jython code Start code from org apache commons math linear import Alist = [[1 0 2 0 3 0] [2 0 3 0 4 0] [3 0 5 0 7 0]] A = Array2DRowRealMatrix Alist  decomp = SingularValueDecompositionImpl A  print decomp getSingularValues   End code prints array d [11 218599757513008 0 3781791648535976 nan]  The last singular value should be something very close to 0 since the matrix is rank deficient When i use the result from getSolver   to solve a system i end up with a bunch of NaNs in the solution I assumed i would get back a least squares solution Does this SVD implementation require that the matrix be full rank If so then i would expect an exception to be thrown from the constructor or one of the methods ,The following jython code Start code from org apache commons math linear import Alist = [[     ] [     ] [     ]] A = ArrayDRowRealMatrix Alist  decomp = SingularValueDecompositionImpl A  print decomp getSingularValues   End code prints array d [    nan]  The last singular value should be something very close to  since the matrix is rank deficient When i use the result from getSolver   to solve a system i end up with a bunch of NaNs in the solution I assumed i would get back a least squares solution Does this SVD implementation require that the matrix be full rank If so then i would expect an exception to be thrown from the constructor or one of the methods ,The following jython code Start code from org apache commons math linear import Alist = [[ ] [ ] [ ]] A = ArrayDRowRealMatrix Alist decomp = SingularValueDecompositionImpl A print decomp getSingularValues End code prints array d [ nan] The last singular value should be something very close to since the matrix is rank deficient When i use the result from getSolver to solve a system i end up with a bunch of NaNs in the solution I assumed i would get back a least squares solution Does this SVD implementation require that the matrix be full rank If so then i would expect an exception to be thrown from the constructor or one of the methods ,1
0,Math,SimplexSolver not working as expected 2,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: 7 a 3 b; Constraints R1: 3 a -5 c <= 0; R2: 2 a -5 d <= 0; R3: 2 b -5 c <= 0; R4: 3 b -5 d <= 0; R5: 3 a 2 b <= 5; R6: 2 a 3 b <= 5; Variable bounds a <= 1; b <= 1; ===================== Results correct : a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {7 3 0 0} 0 ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {1 0 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {0 1 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {3 0 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {2 0 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 2 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 3 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {3 2 0 0} Relationship LEQ 5 ; podmienky add new LinearConstraint new double[] {2 3 0 0} Relationship LEQ 5 ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = 1 b = 0 5 value = 8 5 P S I used the latest software from the repository including MATH-286 fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max:  a  b; Constraints R:  a  c <= ; R:  a  d <= ; R:  b  c <= ; R:  b  d <= ; R:  a  b <= ; R:  a  b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a =  b =  value =  Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {   }  ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a =  b =   value =   P S I used the latest software from the repository including MATH fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: a b; Constraints R: a c <= ; R: a d <= ; R: b c <= ; R: b d <= ; R: a b <= ; R: a b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a = b = value = Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] { } ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint> ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; SimplexSolver solver = new SimplexSolver ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = b = value = P S I used the latest software from the repository including MATH fix ,1
0,Math,MathRuntimeException with simple ebeMultiply on OpenMapRealVector,The following piece of code import org apache commons math linear OpenMapRealVector; import org apache commons math linear RealVector; public class DemoBugOpenMapRealVector { public static void main String[] args  { final RealVector u = new OpenMapRealVector 3 1E-6 ; u setEntry 0 1  ; u setEntry 1 0  ; u setEntry 2 2  ; final RealVector v = new OpenMapRealVector 3 1E-6 ; v setEntry 0 0  ; v setEntry 1 3  ; v setEntry 2 0  ; System out println u ; System out println v ; System out println u ebeMultiply v ; } } raises an exception org apache commons math linear OpenMapRealVector 7170a9b6 Exception in thread main org apache commons math MathRuntimeException 6: map has been modified while iterating at org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java:373  at org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java:564  at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java:372  at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java:1  at DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java:17 ,The following piece of code import org apache commons math linear OpenMapRealVector; import org apache commons math linear RealVector; public class DemoBugOpenMapRealVector { public static void main String[] args  { final RealVector u = new OpenMapRealVector  E ; u setEntry    ; u setEntry    ; u setEntry    ; final RealVector v = new OpenMapRealVector  E ; v setEntry    ; v setEntry    ; v setEntry    ; System out println u ; System out println v ; System out println u ebeMultiply v ; } } raises an exception org apache commons math linear OpenMapRealVector ab Exception in thread main org apache commons math MathRuntimeException : map has been modified while iterating at org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java:  at org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java:  at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java:  at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java:  at DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java: ,The following piece of code import org apache commons math linear OpenMapRealVector; import org apache commons math linear RealVector; public class DemoBugOpenMapRealVector { public static void main String[] args { final RealVector u = new OpenMapRealVector E ; u setEntry ; u setEntry ; u setEntry ; final RealVector v = new OpenMapRealVector E ; v setEntry ; v setEntry ; v setEntry ; System out println u ; System out println v ; System out println u ebeMultiply v ; } } raises an exception org apache commons math linear OpenMapRealVector ab Exception in thread main org apache commons math MathRuntimeException : map has been modified while iterating at org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java: at org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java: at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java: at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java: at DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java: ,1
0,Math,BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundary,In some cases the aging feature in BracketingNthOrderBrentSolver fails It attempts to balance the bracketing points by targeting a non-zero value instead of the real root However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket In the real used case for a large program I had a bracket point xA = 12500 0 yA = 3 7e-16 agingA = 0 which is the really good  estimate of the zero on one side of the root and xB = 12500 03 yB = -7 0e-5 agingB = 97 This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates xA yA  and never updates xB yB  ,In some cases the aging feature in BracketingNthOrderBrentSolver fails It attempts to balance the bracketing points by targeting a nonzero value instead of the real root However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket In the real used case for a large program I had a bracket point xA =   yA =  e agingA =  which is the really good  estimate of the zero on one side of the root and xB =   yB =  e agingB =  This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates xA yA  and never updates xB yB  ,In some cases the aging feature in BracketingNthOrderBrentSolver fails It attempts to balance the bracketing points by targeting a nonzero value instead of the real root However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket In the real used case for a large program I had a bracket point xA = yA = e agingA = which is the really good estimate of the zero on one side of the root and xB = yB = e agingB = This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates xA yA and never updates xB yB ,1
0,Math,Division by zero,In class Complex division by zero always returns NaN I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF See here ,In class Complex division by zero always returns NaN I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF See here ,In class Complex division by zero always returns NaN I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF See here ,1
0,Math,during ODE integration the last event in a pair of very close event may not be detected,When an events follows a previous one very closely it may be ignored The occurrence of the bug depends on the side of the bracketing interval that was selected For example consider a switching function that is increasing around first event around t = 90 reaches its maximum and is decreasing around the second event around t = 135 If an integration step spans from 67 5 and 112 5 the switching function values at start and end of step will have opposite signs so the first event will be detected The solver will find the event really occurs at 90 0 and will therefore truncate the step at 90 0 The next step will start from where the first step ends i e it will start at 90 0 Let s say this step spans from 90 0 to 153 0 The switching function switches once again in this step If the solver for the first event converged to a value slightly before 90 0 say 89 9999999  then the switch will not be detected because g 89 9999999  and g 153 0  are both negative This bug was introduced as of r781157 2009-06-02  when special handling of events very close to step start was added ,When an events follows a previous one very closely it may be ignored The occurrence of the bug depends on the side of the bracketing interval that was selected For example consider a switching function that is increasing around first event around t =  reaches its maximum and is decreasing around the second event around t =  If an integration step spans from   and   the switching function values at start and end of step will have opposite signs so the first event will be detected The solver will find the event really occurs at   and will therefore truncate the step at   The next step will start from where the first step ends i e it will start at   Let s say this step spans from   to   The switching function switches once again in this step If the solver for the first event converged to a value slightly before   say    then the switch will not be detected because g    and g    are both negative This bug was introduced as of r   when special handling of events very close to step start was added ,When an events follows a previous one very closely it may be ignored The occurrence of the bug depends on the side of the bracketing interval that was selected For example consider a switching function that is increasing around first event around t = reaches its maximum and is decreasing around the second event around t = If an integration step spans from and the switching function values at start and end of step will have opposite signs so the first event will be detected The solver will find the event really occurs at and will therefore truncate the step at The next step will start from where the first step ends i e it will start at Let s say this step spans from to The switching function switches once again in this step If the solver for the first event converged to a value slightly before say then the switch will not be detected because g and g are both negative This bug was introduced as of r when special handling of events very close to step start was added ,1
0,Math,HypergeometricDistribution sample suffers from integer overflow,Hi I have an application which broke when ported from commons math 2 2 to 3 2 It looks like the HypergeometricDistribution sample   method doesn t work as well as it used to with large integer values – the example code below should return a sample between 0 and 50 but usually returns -50 import org apache commons math3 distribution HypergeometricDistribution; public class Foo { public static void main String[] args  { HypergeometricDistribution a = new HypergeometricDistribution 43130568 42976365 50 ; System out printf d d n a getSupportLowerBound   a getSupportUpperBound  ; Prints 0 50 System out printf d n a sample  ; Prints -50 } } In the debugger I traced it as far as an integer overflow in HypergeometricDistribution getNumericalMean   – instead of doing return double  getSampleSize   getNumberOfSuccesses   double  getPopulationSize  ; it could do: return getSampleSize   double  getNumberOfSuccesses   double  getPopulationSize  ; This seemed to fix it based on a quick test ,Hi I have an application which broke when ported from commons math   to   It looks like the HypergeometricDistribution sample   method doesn t work as well as it used to with large integer values – the example code below should return a sample between  and  but usually returns  import org apache commons math distribution HypergeometricDistribution; public class Foo { public static void main String[] args  { HypergeometricDistribution a = new HypergeometricDistribution    ; System out printf d d n a getSupportLowerBound   a getSupportUpperBound  ; Prints   System out printf d n a sample  ; Prints  } } In the debugger I traced it as far as an integer overflow in HypergeometricDistribution getNumericalMean   – instead of doing return double  getSampleSize   getNumberOfSuccesses   double  getPopulationSize  ; it could do: return getSampleSize   double  getNumberOfSuccesses   double  getPopulationSize  ; This seemed to fix it based on a quick test ,Hi I have an application which broke when ported from commons math to It looks like the HypergeometricDistribution sample method doesn t work as well as it used to with large integer values – the example code below should return a sample between and but usually returns import org apache commons math distribution HypergeometricDistribution; public class Foo { public static void main String[] args { HypergeometricDistribution a = new HypergeometricDistribution ; System out printf d d n a getSupportLowerBound a getSupportUpperBound ; Prints System out printf d n a sample ; Prints } } In the debugger I traced it as far as an integer overflow in HypergeometricDistribution getNumericalMean – instead of doing return double getSampleSize getNumberOfSuccesses double getPopulationSize ; it could do: return getSampleSize double getNumberOfSuccesses double getPopulationSize ; This seemed to fix it based on a quick test ,1
0,Math,new multivariate vector optimizers cannot be used with large number of weights,When using the Weigth class to pass a large number of weights to multivariate vector optimizers an nxn full matrix is created and copied  when a n elements vector is used This exhausts memory when n is large This happens for example when using curve fitters even simple curve fitters like polynomial ones for low degree  with large number of points I encountered this with curve fitting on 41200 points which created a matrix with 1 7 billion elements ,When using the Weigth class to pass a large number of weights to multivariate vector optimizers an nxn full matrix is created and copied  when a n elements vector is used This exhausts memory when n is large This happens for example when using curve fitters even simple curve fitters like polynomial ones for low degree  with large number of points I encountered this with curve fitting on  points which created a matrix with   billion elements ,When using the Weigth class to pass a large number of weights to multivariate vector optimizers an nxn full matrix is created and copied when a n elements vector is used This exhausts memory when n is large This happens for example when using curve fitters even simple curve fitters like polynomial ones for low degree with large number of points I encountered this with curve fitting on points which created a matrix with billion elements ,1
0,Math,Complex ZERO reciprocal   returns NaN but should return INF ,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math3 complex Complex; Method: reciprocal    version Id: Complex java 1416643 2012-12-03 19:37:14Z tn,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal    version Id: Complex java   ::Z tn,Complex ZERO reciprocal returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal version Id: Complex java ::Z tn,1
0,Math,new multivariate vector optimizers cannot be used with large number of weights,When using the Weigth class to pass a large number of weights to multivariate vector optimizers an nxn full matrix is created and copied  when a n elements vector is used This exhausts memory when n is large This happens for example when using curve fitters even simple curve fitters like polynomial ones for low degree  with large number of points I encountered this with curve fitting on 41200 points which created a matrix with 1 7 billion elements ,When using the Weigth class to pass a large number of weights to multivariate vector optimizers an nxn full matrix is created and copied  when a n elements vector is used This exhausts memory when n is large This happens for example when using curve fitters even simple curve fitters like polynomial ones for low degree  with large number of points I encountered this with curve fitting on  points which created a matrix with   billion elements ,When using the Weigth class to pass a large number of weights to multivariate vector optimizers an nxn full matrix is created and copied when a n elements vector is used This exhausts memory when n is large This happens for example when using curve fitters even simple curve fitters like polynomial ones for low degree with large number of points I encountered this with curve fitting on points which created a matrix with billion elements ,1
0,Math,Fix and then deprecate isSupportXxxInclusive in RealDistribution interface,The conclusion from [1] was never implemented We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4 0 we should agree on a precise definition and fix the code to match it in the mean time The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite i e not infinite  not NaN value is returned [1] http: markmail org message dxuxh7eybl7xejde,The conclusion from [] was never implemented We should deprecate these properties from the RealDistribution interface but since removal will have to wait until   we should agree on a precise definition and fix the code to match it in the mean time The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite i e not infinite  not NaN value is returned [] http: markmail org message dxuxheyblxejde,The conclusion from [] was never implemented We should deprecate these properties from the RealDistribution interface but since removal will have to wait until we should agree on a precise definition and fix the code to match it in the mean time The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite i e not infinite not NaN value is returned [] http: markmail org message dxuxheyblxejde,1
0,Math, HarmonicFitter ParameterGuesser sometimes fails to return sensible values,The inner class ParameterGuesser in HarmonicFitter package o a c m optimization fitting   fails to compute a usable guess for the amplitude parameter ,The inner class ParameterGuesser in HarmonicFitter package o a c m optimization fitting   fails to compute a usable guess for the amplitude parameter ,The inner class ParameterGuesser in HarmonicFitter package o a c m optimization fitting fails to compute a usable guess for the amplitude parameter ,1
0,Time,Errors creating parsing dates with specific time zones ,The results are out of 572 time zones 130 fail and 30 throw exceptions The failures are the most interesting When I query DateTimeZone to get its time zone ids I will get a time zone like America Atka When I take that id and create a date time with it its time zone id is America Adak It is like there are multiple list of time zones in Joda time and they are out of sync ,The results are out of  time zones  fail and  throw exceptions The failures are the most interesting When I query DateTimeZone to get its time zone ids I will get a time zone like America Atka When I take that id and create a date time with it its time zone id is America Adak It is like there are multiple list of time zones in Joda time and they are out of sync ,The results are out of time zones fail and throw exceptions The failures are the most interesting When I query DateTimeZone to get its time zone ids I will get a time zone like America Atka When I take that id and create a date time with it its time zone id is America Adak It is like there are multiple list of time zones in Joda time and they are out of sync ,1
0,Time,GJChronology rejects valid Julian dates,The 2nd statement fails with org joda time IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1 28] Given that I left the cutover date at the default October 15 1582  isn t 1500 02 29 a valid date in the GJChronology ,The nd statement fails with org joda time IllegalFieldValueException: Value  for dayOfMonth must be in the range [ ] Given that I left the cutover date at the default October    isn t    a valid date in the GJChronology ,The nd statement fails with org joda time IllegalFieldValueException: Value for dayOfMonth must be in the range [ ] Given that I left the cutover date at the default October isn t a valid date in the GJChronology ,1
0,Time,Different behaviour of PeriodFormatter,When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones Shoul the hour be set to the daylight hour or the standard hour for all time zones I can t find anything that documents this behavior My test code below returns different results for different time zones The very last assertion fails on the Australia time zone cutover ,When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones Shoul the hour be set to the daylight hour or the standard hour for all time zones I can t find anything that documents this behavior My test code below returns different results for different time zones The very last assertion fails on the Australia time zone cutover ,When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones Shoul the hour be set to the daylight hour or the standard hour for all time zones I can t find anything that documents this behavior My test code below returns different results for different time zones The very last assertion fails on the Australia time zone cutover ,1
0,Time,Ensure there is a max min valid offset,DateTimeZone does not apply a max min value for an offset However the parse method is limited to 23:59 Make 23:59:59 999 the maximum ,DateTimeZone does not apply a max min value for an offset However the parse method is limited to : Make ::  the maximum ,DateTimeZone does not apply a max min value for an offset However the parse method is limited to : Make :: the maximum ,1
0,Time,NPE in DateTimeZoneBuilder,When a DateTimeZone is build with duplicate-named recurring saving time in a first thread all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone create   When a second thread does the same an NPE is generated in ZoneInfoCompiler verbose   The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler will initialize cVerbose only for the first thread and not for the subsequent ones The NPE is caused by the autoboxing in: A better approach could be to remove the initialization and test for null:,When a DateTimeZone is build with duplicatenamed recurring saving time in a first thread all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone create   When a second thread does the same an NPE is generated in ZoneInfoCompiler verbose   The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler will initialize cVerbose only for the first thread and not for the subsequent ones The NPE is caused by the autoboxing in: A better approach could be to remove the initialization and test for null:,When a DateTimeZone is build with duplicatenamed recurring saving time in a first thread all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone create When a second thread does the same an NPE is generated in ZoneInfoCompiler verbose The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler will initialize cVerbose only for the first thread and not for the subsequent ones The NPE is caused by the autoboxing in: A better approach could be to remove the initialization and test for null:,1
0,Time,DateTimeFormat parseInto sometimes miscalculates year 2 2 ,The following code which can be added to org joda time format TestDateTimeFormatter  breaks because the input mutable date time s millis appear to be mishandled and the year for the parse is changed to 1999 ,The following code which can be added to org joda time format TestDateTimeFormatter  breaks because the input mutable date time s millis appear to be mishandled and the year for the parse is changed to  ,The following code which can be added to org joda time format TestDateTimeFormatter breaks because the input mutable date time s millis appear to be mishandled and the year for the parse is changed to ,1
0,Time,DateTimeFormatter parseInto broken when no year in format,In Joda Time 2 0 the default year was set to 2000 so that Feb 29 could be parsed correctly However parseInto now overwrites the given instant s year with 2000 or whatever iDefaultYear is set to  The correct behavior would seem to be to use the given instant s year instead of iDefaultYear This does mean that Feb 29 might not be parseable if the instant s year is not a leap year but in this case the caller asked for that in a sense ,In Joda Time   the default year was set to  so that Feb  could be parsed correctly However parseInto now overwrites the given instant s year with  or whatever iDefaultYear is set to  The correct behavior would seem to be to use the given instant s year instead of iDefaultYear This does mean that Feb  might not be parseable if the instant s year is not a leap year but in this case the caller asked for that in a sense ,In Joda Time the default year was set to so that Feb could be parsed correctly However parseInto now overwrites the given instant s year with or whatever iDefaultYear is set to The correct behavior would seem to be to use the given instant s year instead of iDefaultYear This does mean that Feb might not be parseable if the instant s year is not a leap year but in this case the caller asked for that in a sense ,1
0,Time,Questionable behaviour of GJChronology when dates pass 1BC,I expect the following test to pass: However I never provided 0 for the year myself I thought it was the job of the framework to skip over non-existent year 0 for me to return 1 BC ,I expect the following test to pass: However I never provided  for the year myself I thought it was the job of the framework to skip over nonexistent year  for me to return  BC ,I expect the following test to pass: However I never provided for the year myself I thought it was the job of the framework to skip over nonexistent year for me to return BC ,1
0,Time,Bug on withLaterOffsetAtOverlap method,On the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should and not even working at all   ,On the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should and not even working at all   ,On the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should and not even working at all ,1
0,Time,Partial with fails with NPE,Fails with yearOfCentury year and yearOfEra Probably because weekyear has a null range duration type ,Fails with yearOfCentury year and yearOfEra Probably because weekyear has a null range duration type ,Fails with yearOfCentury year and yearOfEra Probably because weekyear has a null range duration type ,1
0,Time,Days daysBetween throw exception for MonthDay with 29 February,Is there a way to avoid this happening I understand fiddling around with the leap year you re bound to get issues ,Is there a way to avoid this happening I understand fiddling around with the leap year you re bound to get issues ,Is there a way to avoid this happening I understand fiddling around with the leap year you re bound to get issues ,1
0,Time, withHourOfDay   sets hour inconsistantly on DST transition ,When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones Shoul the hour be set to the daylight hour or the standard hour for all time zones I can t find anything that documents this behavior My test code below returns different results for different time zones The very last assertion fails on the Australia time zone cutover ,When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones Shoul the hour be set to the daylight hour or the standard hour for all time zones I can t find anything that documents this behavior My test code below returns different results for different time zones The very last assertion fails on the Australia time zone cutover ,When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones Shoul the hour be set to the daylight hour or the standard hour for all time zones I can t find anything that documents this behavior My test code below returns different results for different time zones The very last assertion fails on the Australia time zone cutover ,1
0,Time,DateTimeZone forOffsetHoursMinutes cannot handle negative offset < 1 hour,DateTimeZone forOffsetHoursMinutes h m  cannot handle negative offset < 1 hour like -0:30 due to argument range checking I used forOffsetMillis   instead This should probably be mentioned in the documentation or negative minutes be accepted ,DateTimeZone forOffsetHoursMinutes h m  cannot handle negative offset <  hour like : due to argument range checking I used forOffsetMillis   instead This should probably be mentioned in the documentation or negative minutes be accepted ,DateTimeZone forOffsetHoursMinutes h m cannot handle negative offset < hour like : due to argument range checking I used forOffsetMillis instead This should probably be mentioned in the documentation or negative minutes be accepted ,1
0,Time,Incorrect date parsed when week and month used together,It should print 2011-01-03 but it is printing 2010-01-04 ,It should print  but it is printing  ,It should print but it is printing ,1
0,Time,Incorrect mapping of the MET time zone,This timezone is mapped to Asia Tehran in DateTimeZone It should be middle europena time ,This timezone is mapped to Asia Tehran in DateTimeZone It should be middle europena time ,This timezone is mapped to Asia Tehran in DateTimeZone It should be middle europena time ,1
0,Time,Constructing invalid Partials,Partials can be constructed by invoking a constructor Partial DateTimeFieldType[] int[]  or by merging together a set of partials using with each constructed by calling Partial DateTimeFieldType int  However the above doesn t work in all cases: I suppose the Partials should not allow to be constructed in either case Is that right There s also a related issue probably stems from the fact that the Partial is invalid :,Partials can be constructed by invoking a constructor Partial DateTimeFieldType[] int[]  or by merging together a set of partials using with each constructed by calling Partial DateTimeFieldType int  However the above doesn t work in all cases: I suppose the Partials should not allow to be constructed in either case Is that right There s also a related issue probably stems from the fact that the Partial is invalid :,Partials can be constructed by invoking a constructor Partial DateTimeFieldType[] int[] or by merging together a set of partials using with each constructed by calling Partial DateTimeFieldType int However the above doesn t work in all cases: I suppose the Partials should not allow to be constructed in either case Is that right There s also a related issue probably stems from the fact that the Partial is invalid :,1
0,Time,possibly a bug in org joda time field FieldUtils safeMultiply,It seems to me that as currently written in joda-time-2 1 jar org joda time field FieldUtils safeMultiply long val1 int scalar  doesn t detect the overflow if the long val1 == Long MIN VALUE and the int scalar == -1 The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,It seems to me that as currently written in jodatime  jar org joda time field FieldUtils safeMultiply long val int scalar  doesn t detect the overflow if the long val == Long MIN VALUE and the int scalar ==  The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,It seems to me that as currently written in jodatime jar org joda time field FieldUtils safeMultiply long val int scalar doesn t detect the overflow if the long val == Long MIN VALUE and the int scalar == The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,1
0,Time,addDays 0  changes value of MutableDateTime,Upon DST transition from summer to winter time zone adding the amount of zero days to a mutable date time object changes the value of the object The methods addMonths and addYears show the same problem; addSeconds addMinutes and addHours are ok I have tested with version 2 3 However if I repeat the test with Joda 1 5 2 the invocation of addDays 0  does not change the date s value ,Upon DST transition from summer to winter time zone adding the amount of zero days to a mutable date time object changes the value of the object The methods addMonths and addYears show the same problem; addSeconds addMinutes and addHours are ok I have tested with version   However if I repeat the test with Joda    the invocation of addDays   does not change the date s value ,Upon DST transition from summer to winter time zone adding the amount of zero days to a mutable date time object changes the value of the object The methods addMonths and addYears show the same problem; addSeconds addMinutes and addHours are ok I have tested with version However if I repeat the test with Joda the invocation of addDays does not change the date s value ,1
0,Time,Check Calendar ERA in LocalDate fromCalendarFields,None,None,None,1
0,Time,Partial with fails with NPE,Fails with yearOfCentury year and yearOfEra Probably because weekyear has a null range duration type ,Fails with yearOfCentury year and yearOfEra Probably because weekyear has a null range duration type ,Fails with yearOfCentury year and yearOfEra Probably because weekyear has a null range duration type ,1
0,Time,Negative millis display incorrectly in Period toString,The last line should produce PT-0 100S instead of PT0 100S ,The last line should produce PT S instead of PT S ,The last line should produce PT S instead of PT S ,1
0,Time,none standard PeriodType without year throws exception,I tried to get a Period only for months and weeks with following code: This throws following exception: Even removing the year component with withYearsRemoved   throws the same exception:,I tried to get a Period only for months and weeks with following code: This throws following exception: Even removing the year component with withYearsRemoved   throws the same exception:,I tried to get a Period only for months and weeks with following code: This throws following exception: Even removing the year component with withYearsRemoved throws the same exception:,1
0,Time,Unable to add days to a MonthDay set to the ISO leap date,It s not possible to add days to a MonthDay set to the ISO leap date February 29th  This is even more bizarre given the exact error message thrown ,It s not possible to add days to a MonthDay set to the ISO leap date February th  This is even more bizarre given the exact error message thrown ,It s not possible to add days to a MonthDay set to the ISO leap date February th This is even more bizarre given the exact error message thrown ,1
0,Time,Duration toPeriod with fixed time zones ,I have a question concerning the conversion of a Duration to Period I m not sure if this is a bug or if there is a different way to do this The basis of the problem is that using Duration toPeriod   uses the chronology of the default time zone to do the conversion This can cause different results from a timezone with DST and one without This can be reproduced easily with this test In the joda code Duration toPeriod   uses a period constructor that takes the chronology but null is passed in so the chronology of the default time zone is used which leads to this behavior The javadoc of toPeriod   states that only precise fields of hours minutes seconds and millis will be converted But for a fixed timezone days and weeks are also precise which is stated in the javadoc for toPeriod Chronology chrono  In our app we need consistent behavior regardless of the default time zone which is to have all the extra hours put into the hours bucket Since Duration is supposed to be a time zone independent length of time I don t think we should have to do any chronology manipulation to get this to work ,I have a question concerning the conversion of a Duration to Period I m not sure if this is a bug or if there is a different way to do this The basis of the problem is that using Duration toPeriod   uses the chronology of the default time zone to do the conversion This can cause different results from a timezone with DST and one without This can be reproduced easily with this test In the joda code Duration toPeriod   uses a period constructor that takes the chronology but null is passed in so the chronology of the default time zone is used which leads to this behavior The javadoc of toPeriod   states that only precise fields of hours minutes seconds and millis will be converted But for a fixed timezone days and weeks are also precise which is stated in the javadoc for toPeriod Chronology chrono  In our app we need consistent behavior regardless of the default time zone which is to have all the extra hours put into the hours bucket Since Duration is supposed to be a time zone independent length of time I don t think we should have to do any chronology manipulation to get this to work ,I have a question concerning the conversion of a Duration to Period I m not sure if this is a bug or if there is a different way to do this The basis of the problem is that using Duration toPeriod uses the chronology of the default time zone to do the conversion This can cause different results from a timezone with DST and one without This can be reproduced easily with this test In the joda code Duration toPeriod uses a period constructor that takes the chronology but null is passed in so the chronology of the default time zone is used which leads to this behavior The javadoc of toPeriod states that only precise fields of hours minutes seconds and millis will be converted But for a fixed timezone days and weeks are also precise which is stated in the javadoc for toPeriod Chronology chrono In our app we need consistent behavior regardless of the default time zone which is to have all the extra hours put into the hours bucket Since Duration is supposed to be a time zone independent length of time I don t think we should have to do any chronology manipulation to get this to work ,1
0,Time,DateTimeZone getOffsetFromLocal error during DST transition,This may be a failure of my understanding but the comments in DateTimeZone getOffsetFromLocal lead me to believe that if an ambiguous local time is given the offset corresponding to the later of the two possible UTC instants will be returned - i e the greater offset This doesn t appear to tally with my experience In fall 2009 America Los Angeles changed from -7 to -8 at 2am wall time on November 11 Thus 2am became 1am - so 1:30am is ambiguous I would therefore expect that constructing a DateTime for November 11th 1:30am would give an instant corresponding with the later value i e 9:30am UTC  ,This may be a failure of my understanding but the comments in DateTimeZone getOffsetFromLocal lead me to believe that if an ambiguous local time is given the offset corresponding to the later of the two possible UTC instants will be returned  i e the greater offset This doesn t appear to tally with my experience In fall  America Los Angeles changed from  to  at am wall time on November  Thus am became am  so :am is ambiguous I would therefore expect that constructing a DateTime for November th :am would give an instant corresponding with the later value i e :am UTC  ,This may be a failure of my understanding but the comments in DateTimeZone getOffsetFromLocal lead me to believe that if an ambiguous local time is given the offset corresponding to the later of the two possible UTC instants will be returned i e the greater offset This doesn t appear to tally with my experience In fall America Los Angeles changed from to at am wall time on November Thus am became am so :am is ambiguous I would therefore expect that constructing a DateTime for November th :am would give an instant corresponding with the later value i e :am UTC ,1
0,Lang,StrBuilder replaceAll and StrBuilder deleteAll can throw ArrayIndexOutOfBoundsException ,StrBuilder replaceAll and StrBuilder deleteAll can thrown ArrayIndexOutOfBoundsException s Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder deleteAll   - added to testDeleteAll String  : sb = new StrBuilder \n BLAH \nDo more stuff\neven more stuff\n BLAH \n  ; sb deleteAll \n BLAH  ; assertEquals \nDo more stuff\neven more stuff\n sb toString  ; this causes the following error: java lang ArrayIndexOutOfBoundsException at java lang System arraycopy Native Method  at org apache commons lang text StrBuilder deleteImpl StrBuilder java:1114  at org apache commons lang text StrBuilder deleteAll StrBuilder java:1188  at org apache commons lang text StrBuilderTest testDeleteAll String StrBuilderTest java:606  at sun reflect NativeMethodAccessorImpl invoke0 Native Method  at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java:39  at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java:25  at java lang reflect Method invoke Method java:585  at junit framework TestCase runTest TestCase java:154  at junit framework TestCase runBare TestCase java:127  at junit framework TestResult 1 protect TestResult java:106  at junit framework TestResult runProtected TestResult java:124  at junit framework TestResult run TestResult java:109  at junit framework TestCase run TestCase java:118  at junit framework TestSuite runTest TestSuite java:208  at junit framework TestSuite run TestSuite java:203  at org eclipse jdt internal junit runner junit3 JUnit3TestReference run JUnit3TestReference java:128  at org eclipse jdt internal junit runner TestExecution run TestExecution java:38  at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java:460  at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java:673  at org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java:386  at org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java:196  StrBuilder replaceAll   - added to testReplaceAll String String  : sb = new StrBuilder \n BLAH \nDo more stuff\neven more stuff\n BLAH \n  ; sb replaceAll \n BLAH  ; assertEquals \nDo more stuff\neven more stuff\n sb toString  ; this causes the exception: java lang ArrayIndexOutOfBoundsException at java lang System arraycopy Native Method  at org apache commons lang text StrBuilder replaceImpl StrBuilder java:1256  at org apache commons lang text StrBuilder replaceAll StrBuilder java:1339  at org apache commons lang text StrBuilderTest testReplaceAll String String StrBuilderTest java:763  at sun reflect NativeMethodAccessorImpl invoke0 Native Method  at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java:39  at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java:25  at java lang reflect Method invoke Method java:585  at junit framework TestCase runTest TestCase java:154  at junit framework TestCase runBare TestCase java:127  at junit framework TestResult 1 protect TestResult java:106  at junit framework TestResult runProtected TestResult java:124  at junit framework TestResult run TestResult java:109  at junit framework TestCase run TestCase java:118  at junit framework TestSuite runTest TestSuite java:208  at junit framework TestSuite run TestSuite java:203  at org eclipse jdt internal junit runner junit3 JUnit3TestReference run JUnit3TestReference java:128  at org eclipse jdt internal junit runner TestExecution run TestExecution java:38  at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java:460  at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java:673  at org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java:386  at org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java:196 ,StrBuilder replaceAll and StrBuilder deleteAll can thrown ArrayIndexOutOfBoundsException s Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder deleteAll    added to testDeleteAll String  : sb = new StrBuilder \n BLAH \nDo more stuff\neven more stuff\n BLAH \n  ; sb deleteAll \n BLAH  ; assertEquals \nDo more stuff\neven more stuff\n sb toString  ; this causes the following error: java lang ArrayIndexOutOfBoundsException at java lang System arraycopy Native Method  at org apache commons lang text StrBuilder deleteImpl StrBuilder java:  at org apache commons lang text StrBuilder deleteAll StrBuilder java:  at org apache commons lang text StrBuilderTest testDeleteAll String StrBuilderTest java:  at sun reflect NativeMethodAccessorImpl invoke Native Method  at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java:  at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java:  at java lang reflect Method invoke Method java:  at junit framework TestCase runTest TestCase java:  at junit framework TestCase runBare TestCase java:  at junit framework TestResult  protect TestResult java:  at junit framework TestResult runProtected TestResult java:  at junit framework TestResult run TestResult java:  at junit framework TestCase run TestCase java:  at junit framework TestSuite runTest TestSuite java:  at junit framework TestSuite run TestSuite java:  at org eclipse jdt internal junit runner junit JUnitTestReference run JUnitTestReference java:  at org eclipse jdt internal junit runner TestExecution run TestExecution java:  at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java:  at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java:  at org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java:  at org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java:  StrBuilder replaceAll    added to testReplaceAll String String  : sb = new StrBuilder \n BLAH \nDo more stuff\neven more stuff\n BLAH \n  ; sb replaceAll \n BLAH  ; assertEquals \nDo more stuff\neven more stuff\n sb toString  ; this causes the exception: java lang ArrayIndexOutOfBoundsException at java lang System arraycopy Native Method  at org apache commons lang text StrBuilder replaceImpl StrBuilder java:  at org apache commons lang text StrBuilder replaceAll StrBuilder java:  at org apache commons lang text StrBuilderTest testReplaceAll String String StrBuilderTest java:  at sun reflect NativeMethodAccessorImpl invoke Native Method  at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java:  at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java:  at java lang reflect Method invoke Method java:  at junit framework TestCase runTest TestCase java:  at junit framework TestCase runBare TestCase java:  at junit framework TestResult  protect TestResult java:  at junit framework TestResult runProtected TestResult java:  at junit framework TestResult run TestResult java:  at junit framework TestCase run TestCase java:  at junit framework TestSuite runTest TestSuite java:  at junit framework TestSuite run TestSuite java:  at org eclipse jdt internal junit runner junit JUnitTestReference run JUnitTestReference java:  at org eclipse jdt internal junit runner TestExecution run TestExecution java:  at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java:  at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java:  at org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java:  at org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java: ,StrBuilder replaceAll and StrBuilder deleteAll can thrown ArrayIndexOutOfBoundsException s Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder deleteAll added to testDeleteAll String : sb = new StrBuilder \n BLAH \nDo more stuff\neven more stuff\n BLAH \n ; sb deleteAll \n BLAH ; assertEquals \nDo more stuff\neven more stuff\n sb toString ; this causes the following error: java lang ArrayIndexOutOfBoundsException at java lang System arraycopy Native Method at org apache commons lang text StrBuilder deleteImpl StrBuilder java: at org apache commons lang text StrBuilder deleteAll StrBuilder java: at org apache commons lang text StrBuilderTest testDeleteAll String StrBuilderTest java: at sun reflect NativeMethodAccessorImpl invoke Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java: at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java: at java lang reflect Method invoke Method java: at junit framework TestCase runTest TestCase java: at junit framework TestCase runBare TestCase java: at junit framework TestResult protect TestResult java: at junit framework TestResult runProtected TestResult java: at junit framework TestResult run TestResult java: at junit framework TestCase run TestCase java: at junit framework TestSuite runTest TestSuite java: at junit framework TestSuite run TestSuite java: at org eclipse jdt internal junit runner junit JUnitTestReference run JUnitTestReference java: at org eclipse jdt internal junit runner TestExecution run TestExecution java: at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java: at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java: at org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java: at org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java: StrBuilder replaceAll added to testReplaceAll String String : sb = new StrBuilder \n BLAH \nDo more stuff\neven more stuff\n BLAH \n ; sb replaceAll \n BLAH ; assertEquals \nDo more stuff\neven more stuff\n sb toString ; this causes the exception: java lang ArrayIndexOutOfBoundsException at java lang System arraycopy Native Method at org apache commons lang text StrBuilder replaceImpl StrBuilder java: at org apache commons lang text StrBuilder replaceAll StrBuilder java: at org apache commons lang text StrBuilderTest testReplaceAll String String StrBuilderTest java: at sun reflect NativeMethodAccessorImpl invoke Native Method at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java: at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java: at java lang reflect Method invoke Method java: at junit framework TestCase runTest TestCase java: at junit framework TestCase runBare TestCase java: at junit framework TestResult protect TestResult java: at junit framework TestResult runProtected TestResult java: at junit framework TestResult run TestResult java: at junit framework TestCase run TestCase java: at junit framework TestSuite runTest TestSuite java: at junit framework TestSuite run TestSuite java: at org eclipse jdt internal junit runner junit JUnitTestReference run JUnitTestReference java: at org eclipse jdt internal junit runner TestExecution run TestExecution java: at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java: at org eclipse jdt internal junit runner RemoteTestRunner runTests RemoteTestRunner java: at org eclipse jdt internal junit runner RemoteTestRunner run RemoteTestRunner java: at org eclipse jdt internal junit runner RemoteTestRunner main RemoteTestRunner java: ,1
0,Lang,Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException,There s a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight Object obj int width char padChar  { if width > 0  { ensureCapacity size width ; String str = obj == null getNullText   : obj toString  ; int strLen = str length  ; if strLen >= width  { ==> str getChars 0 strLen buffer size ; <==== BUG: it should be str getChars 0 width buffer size ; } else { int padLen = width - strLen; str getChars 0 strLen buffer size ; for int i = 0; i < padLen; i   { buffer[size strLen i] = padChar; } } size = width; } return this; } This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width It s counterpart method appendFixedWidthPadLeft seems to be ok ,There s a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight Object obj int width char padChar  { if width >   { ensureCapacity size width ; String str = obj == null getNullText   : obj toString  ; int strLen = str length  ; if strLen >= width  { ==> str getChars  strLen buffer size ; <==== BUG: it should be str getChars  width buffer size ; } else { int padLen = width  strLen; str getChars  strLen buffer size ; for int i = ; i < padLen; i   { buffer[size strLen i] = padChar; } } size = width; } return this; } This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width It s counterpart method appendFixedWidthPadLeft seems to be ok ,There s a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight Object obj int width char padChar { if width > { ensureCapacity size width ; String str = obj == null getNullText : obj toString ; int strLen = str length ; if strLen >= width { ==> str getChars strLen buffer size ; <==== BUG: it should be str getChars width buffer size ; } else { int padLen = width strLen; str getChars strLen buffer size ; for int i = ; i < padLen; i { buffer[size strLen i] = padChar; } } size = width; } return this; } This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width It s counterpart method appendFixedWidthPadLeft seems to be ok ,1
0,Lang,FastDateFormat getDateInstance   and getDateTimeInstance   assume Locale getDefault   won t change,The FastDateFormat getDateInstance   and getDateTimeInstance   methods create the HashMap key from various items including the locale If the locale is null then it is not made part of the key but the stored object is created using the current default locale If the Locale is changed subsequently then the wrong locale is applied Patch for test case to follow ,The FastDateFormat getDateInstance   and getDateTimeInstance   methods create the HashMap key from various items including the locale If the locale is null then it is not made part of the key but the stored object is created using the current default locale If the Locale is changed subsequently then the wrong locale is applied Patch for test case to follow ,The FastDateFormat getDateInstance and getDateTimeInstance methods create the HashMap key from various items including the locale If the locale is null then it is not made part of the key but the stored object is created using the current default locale If the Locale is changed subsequently then the wrong locale is applied Patch for test case to follow ,1
0,Lang,NullPointerException in isAvailableLocale Locale ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source  and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source and if availableLocaleSet hasn t been called it will cause a NullPointerException ,1
0,Lang,Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments,The thread local in org apache commons lang3 builder ToStringStyle is created but never removed and no API is provided to remove it If a webapp s use of LANG triggers the loading of this class a reference chain will be created that will cause a memory leak on web application reload See http: markmail org thread uetw2fdrsqgbh2cv for more info ,The thread local in org apache commons lang builder ToStringStyle is created but never removed and no API is provided to remove it If a webapp s use of LANG triggers the loading of this class a reference chain will be created that will cause a memory leak on web application reload See http: markmail org thread uetwfdrsqgbhcv for more info ,The thread local in org apache commons lang builder ToStringStyle is created but never removed and no API is provided to remove it If a webapp s use of LANG triggers the loading of this class a reference chain will be created that will cause a memory leak on web application reload See http: markmail org thread uetwfdrsqgbhcv for more info ,1
0,Lang,ArrayUtils add T[] array T element  can create unexpected ClassCastException,ArrayUtils add T[] array T element  can create an unexpected ClassCastException For example the following code compiles without a warning: String[] sa = ArrayUtils add stringArray aString ; and works fine provided at least one of the parameters is non-null However if both parameters are null the add   method returns an Object[] array hence the Exception If both parameters are null it s not possible to determine the correct array type to return so it seems to me this should be disallowed I think the method ought to be changed to throw IllegalParameterException when both parameters are null ,ArrayUtils add T[] array T element  can create an unexpected ClassCastException For example the following code compiles without a warning: String[] sa = ArrayUtils add stringArray aString ; and works fine provided at least one of the parameters is nonnull However if both parameters are null the add   method returns an Object[] array hence the Exception If both parameters are null it s not possible to determine the correct array type to return so it seems to me this should be disallowed I think the method ought to be changed to throw IllegalParameterException when both parameters are null ,ArrayUtils add T[] array T element can create an unexpected ClassCastException For example the following code compiles without a warning: String[] sa = ArrayUtils add stringArray aString ; and works fine provided at least one of the parameters is nonnull However if both parameters are null the add method returns an Object[] array hence the Exception If both parameters are null it s not possible to determine the correct array type to return so it seems to me this should be disallowed I think the method ought to be changed to throw IllegalParameterException when both parameters are null ,1
0,Lang,FastDateFormat mRules is not transient or serializable,Reported by FindBugs Either we need to make the Rule interface Serializable or make mRules transient and add deserializing code to kick off init   ,Reported by FindBugs Either we need to make the Rule interface Serializable or make mRules transient and add deserializing code to kick off init   ,Reported by FindBugs Either we need to make the Rule interface Serializable or make mRules transient and add deserializing code to kick off init ,1
0,Lang,BooleanUtils toBoolean   - invalid drop-thru in case statement causes StringIndexOutOfBoundsException,The method BooleanUtils toBoolean   has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case 3 should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean   has a case statement; case  drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case  should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean has a case statement; case drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru ; The end of case should return false Patch to follow for source and unit test ,1
0,Lang,NumberUtils createNumber throws NumberFormatException for one digit long,NumberUtils createNumber throws a NumberFormatException when parsing 1l 2l etc It works fine if you try to parse 01l or 02l The condition isDigits numeric substring 1  line 455 return false as numeric substring 1  is an empty string for 1l ,NumberUtils createNumber throws a NumberFormatException when parsing l l etc It works fine if you try to parse l or l The condition isDigits numeric substring   line  return false as numeric substring   is an empty string for l ,NumberUtils createNumber throws a NumberFormatException when parsing l l etc It works fine if you try to parse l or l The condition isDigits numeric substring line return false as numeric substring is an empty string for l ,1
0,Lang,StrBuilder contains usages of thisBuf length when they should use size,While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf length and unless I m mistaken they shouldn t ,While fixing LANG I noticed that there are two other places in StrBuilder that reference thisBuf length and unless I m mistaken they shouldn t ,While fixing LANG I noticed that there are two other places in StrBuilder that reference thisBuf length and unless I m mistaken they shouldn t ,1
0,Lang,Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments,The thread local in org apache commons lang3 builder ToStringStyle is created but never removed and no API is provided to remove it If a webapp s use of LANG triggers the loading of this class a reference chain will be created that will cause a memory leak on web application reload See http: markmail org thread uetw2fdrsqgbh2cv for more info ,The thread local in org apache commons lang builder ToStringStyle is created but never removed and no API is provided to remove it If a webapp s use of LANG triggers the loading of this class a reference chain will be created that will cause a memory leak on web application reload See http: markmail org thread uetwfdrsqgbhcv for more info ,The thread local in org apache commons lang builder ToStringStyle is created but never removed and no API is provided to remove it If a webapp s use of LANG triggers the loading of this class a reference chain will be created that will cause a memory leak on web application reload See http: markmail org thread uetwfdrsqgbhcv for more info ,1
0,Lang,ClassUtils toClass Object[]  throws NPE on null array element,see summary,see summary,see summary,1
0,Lang,StringUtils join throws NPE when toString returns null for one of objects in collection,Try StringUtils join new Object[]{ new Object   {  Override public String toString   { return null; } } }  ; ToString should probably never return null but it does in javax mail internet InternetAddress,Try StringUtils join new Object[]{ new Object   {  Override public String toString   { return null; } } }  ; ToString should probably never return null but it does in javax mail internet InternetAddress,Try StringUtils join new Object[]{ new Object { Override public String toString { return null; } } } ; ToString should probably never return null but it does in javax mail internet InternetAddress,1
0,Lang,FastDateFormat formats year differently than SimpleDateFormat in Java 7,Starting with Java 7 does SimpleDateFormat format a year pattern of Y or YYY as 2003 instead of 03 as in former Java releases According Javadoc this pattern should have been always been formatted as number therefore the new behavior seems to be a bug fix in the JDK FastDateFormat is adjusted to behave the same ,Starting with Java  does SimpleDateFormat format a year pattern of Y or YYY as  instead of  as in former Java releases According Javadoc this pattern should have been always been formatted as number therefore the new behavior seems to be a bug fix in the JDK FastDateFormat is adjusted to behave the same ,Starting with Java does SimpleDateFormat format a year pattern of Y or YYY as instead of as in former Java releases According Javadoc this pattern should have been always been formatted as number therefore the new behavior seems to be a bug fix in the JDK FastDateFormat is adjusted to behave the same ,1
0,Lang,NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed in,NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in One example of such a String is 1eE ,NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in One example of such a String is eE ,NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in One example of such a String is eE ,1
0,Lang,FastDateParser does not handle unterminated quotes correctly,FDP does not handled unterminated quotes the same way as SimpleDateFormat For example: Format: d d Date: d3 This should fail to parse the format and date but it actually works The format is parsed as: Pattern: d \p {IsNd}  ,FDP does not handled unterminated quotes the same way as SimpleDateFormat For example: Format: d d Date: d This should fail to parse the format and date but it actually works The format is parsed as: Pattern: d \p {IsNd}  ,FDP does not handled unterminated quotes the same way as SimpleDateFormat For example: Format: d d Date: d This should fail to parse the format and date but it actually works The format is parsed as: Pattern: d \p {IsNd} ,1
0,Lang,RandomStringUtils throws confusing IAE when end <= start,RandomUtils invokes Random nextInt where n = end - start If end <= start then Random throws: java lang IllegalArgumentException: n must be positive This is confusing and does not identify the source of the problem ,RandomUtils invokes Random nextInt where n = end  start If end <= start then Random throws: java lang IllegalArgumentException: n must be positive This is confusing and does not identify the source of the problem ,RandomUtils invokes Random nextInt where n = end start If end <= start then Random throws: java lang IllegalArgumentException: n must be positive This is confusing and does not identify the source of the problem ,1
0,Lang,NumberUtils createNumber - bad behaviour for leading -- ,NumberUtils createNumber checks for a leading -- in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading  in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,1
0,Lang,SystemUtils getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime Dalvik VM,Can be replicated in the Android emulator quite easily Stack trace: at org apache commons lang builder ToStringBuilder <clinit> ToStringBuilder java:98  E AndroidRuntime 1681 : 17 more E AndroidRuntime 1681 : Caused by: java lang ExceptionInInitializerError E AndroidRuntime 1681 : at org apache commons lang builder ToStringStyle MultiLineToStringStyle <init> ToStringStyle java:2276  E AndroidRuntime 1681 : at org apache commons lang builder ToStringStyle <clinit> ToStringStyle java:94  E AndroidRuntime 1681 : 18 more E AndroidRuntime 1681 : Caused by: java lang StringIndexOutOfBoundsException E AndroidRuntime 1681 : at java lang String substring String java:1571  E AndroidRuntime 1681 : at org apache commons lang SystemUtils getJavaVersionAsFloat SystemUtils java:1153  E AndroidRuntime 1681 : at org apache commons lang SystemUtils <clinit> SystemUtils java:818 ,Can be replicated in the Android emulator quite easily Stack trace: at org apache commons lang builder ToStringBuilder <clinit> ToStringBuilder java:  E AndroidRuntime  :  more E AndroidRuntime  : Caused by: java lang ExceptionInInitializerError E AndroidRuntime  : at org apache commons lang builder ToStringStyle MultiLineToStringStyle <init> ToStringStyle java:  E AndroidRuntime  : at org apache commons lang builder ToStringStyle <clinit> ToStringStyle java:  E AndroidRuntime  :  more E AndroidRuntime  : Caused by: java lang StringIndexOutOfBoundsException E AndroidRuntime  : at java lang String substring String java:  E AndroidRuntime  : at org apache commons lang SystemUtils getJavaVersionAsFloat SystemUtils java:  E AndroidRuntime  : at org apache commons lang SystemUtils <clinit> SystemUtils java: ,Can be replicated in the Android emulator quite easily Stack trace: at org apache commons lang builder ToStringBuilder <clinit> ToStringBuilder java: E AndroidRuntime : more E AndroidRuntime : Caused by: java lang ExceptionInInitializerError E AndroidRuntime : at org apache commons lang builder ToStringStyle MultiLineToStringStyle <init> ToStringStyle java: E AndroidRuntime : at org apache commons lang builder ToStringStyle <clinit> ToStringStyle java: E AndroidRuntime : more E AndroidRuntime : Caused by: java lang StringIndexOutOfBoundsException E AndroidRuntime : at java lang String substring String java: E AndroidRuntime : at org apache commons lang SystemUtils getJavaVersionAsFloat SystemUtils java: E AndroidRuntime : at org apache commons lang SystemUtils <clinit> SystemUtils java: ,1
0,Lang,NumberUtils does not handle upper-case hex: 0X and -0X,NumberUtils createNumber   should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer decode   handles both upper and lower case hex ,NumberUtils createNumber   should work equally for x and X; currently X generates a NumberFormatException Integer decode   handles both upper and lower case hex ,NumberUtils createNumber should work equally for x and X; currently X generates a NumberFormatException Integer decode handles both upper and lower case hex ,1
0,Lang,StringEscapeUtils escapeHtml incorrectly converts unicode characters above U 00FFFF into 2 characters,Characters that are represented as a 2 characters internaly by java are incorrectly converted by the function The following test displays the problem quite nicely: import org apache commons lang ; public class J2 { public static void main String[] args  throws Exception { this is the utf8 representation of the character: COUNTING ROD UNIT DIGIT THREE in unicode codepoint: U 1D362 byte[] data = new byte[] { byte 0xF0 byte 0x9D byte 0x8D byte 0xA2 } ; output is:  55348; 57186; should be:  119650; System out println StringEscapeUtils escapeHtml new String data UTF8    ; } } Should be very quick to fix feel free to drop me an email if you want a patch ,Characters that are represented as a  characters internaly by java are incorrectly converted by the function The following test displays the problem quite nicely: import org apache commons lang ; public class J { public static void main String[] args  throws Exception { this is the utf representation of the character: COUNTING ROD UNIT DIGIT THREE in unicode codepoint: U D byte[] data = new byte[] { byte xF byte xD byte xD byte xA } ; output is:  ; ; should be:  ; System out println StringEscapeUtils escapeHtml new String data UTF    ; } } Should be very quick to fix feel free to drop me an email if you want a patch ,Characters that are represented as a characters internaly by java are incorrectly converted by the function The following test displays the problem quite nicely: import org apache commons lang ; public class J { public static void main String[] args throws Exception { this is the utf representation of the character: COUNTING ROD UNIT DIGIT THREE in unicode codepoint: U D byte[] data = new byte[] { byte xF byte xD byte xD byte xA } ; output is: ; ; should be: ; System out println StringEscapeUtils escapeHtml new String data UTF ; } } Should be very quick to fix feel free to drop me an email if you want a patch ,1
0,Lang,WordUtils abbreviate bug when lower is greater than str length,In WordUtils abbreviate upper is adjusted to the length of the string then to lower But lower is never adjusted to the length of the string so if lower is greater than str lengt   upper will be too Then str substring 0 upper  throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string,In WordUtils abbreviate upper is adjusted to the length of the string then to lower But lower is never adjusted to the length of the string so if lower is greater than str lengt   upper will be too Then str substring  upper  throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string,In WordUtils abbreviate upper is adjusted to the length of the string then to lower But lower is never adjusted to the length of the string so if lower is greater than str lengt upper will be too Then str substring upper throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string,1
0,Lang,StringIndexOutOfBoundsException in CharSequenceTranslator,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uD83D\uDE30 is a surrogate pair  Test public void testEscapeSurrogatePairs   throws Exception { assertEquals \uD83D\uDE30 StringEscapeUtils escapeCsv \uD83D\uDE30  ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range: 2 at java lang String charAt String java:658  at java lang Character codePointAt Character java:4668  at org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java:95  at org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java:59  at org apache commons lang3 StringEscapeUtils escapeCsv StringEscapeUtils java:556  Patch attached the method affected: public final void translate CharSequence input Writer out  throws IOException,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uDD\uDE is a surrogate pair  Test public void testEscapeSurrogatePairs   throws Exception { assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE  ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range:  at java lang String charAt String java:  at java lang Character codePointAt Character java:  at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java:  at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java:  at org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java:  Patch attached the method affected: public final void translate CharSequence input Writer out  throws IOException,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uDD\uDE is a surrogate pair Test public void testEscapeSurrogatePairs throws Exception { assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range: at java lang String charAt String java: at java lang Character codePointAt Character java: at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java: at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java: at org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java: Patch attached the method affected: public final void translate CharSequence input Writer out throws IOException,1
0,Lang,StringEscapeUtils escapeXML   can t process UTF-16 supplementary characters,Supplementary characters in UTF-16 are those whose code points are above 0xffff that is require more than 1 Java char to be encoded as explained here: http: java sun com developer technicalArticles Intl Supplementary Currently StringEscapeUtils escapeXML   isn t aware of this coding scheme and treats each char as one character which is not always right A possible solution in class Entities would be: public void escape Writer writer String str  throws IOException { int len = str length  ; for int i = 0; i < len; i   { int code = str codePointAt; String entityName = this entityName code ; if entityName = null  { writer write    ; writer write entityName ; writer write ;  ; } else if code > 0x7F  { writer write    ; writer write code ; writer write ;  ; } else { writer write char  code ; } if code > 0xffff  { i ; } } } Besides fixing escapeXML   this will also affect HTML escaping functions I guess that s a good thing but please remember I have only tested escapeXML   ,Supplementary characters in UTF are those whose code points are above xffff that is require more than  Java char to be encoded as explained here: http: java sun com developer technicalArticles Intl Supplementary Currently StringEscapeUtils escapeXML   isn t aware of this coding scheme and treats each char as one character which is not always right A possible solution in class Entities would be: public void escape Writer writer String str  throws IOException { int len = str length  ; for int i = ; i < len; i   { int code = str codePointAt; String entityName = this entityName code ; if entityName = null  { writer write    ; writer write entityName ; writer write ;  ; } else if code > xF  { writer write    ; writer write code ; writer write ;  ; } else { writer write char  code ; } if code > xffff  { i ; } } } Besides fixing escapeXML   this will also affect HTML escaping functions I guess that s a good thing but please remember I have only tested escapeXML   ,Supplementary characters in UTF are those whose code points are above xffff that is require more than Java char to be encoded as explained here: http: java sun com developer technicalArticles Intl Supplementary Currently StringEscapeUtils escapeXML isn t aware of this coding scheme and treats each char as one character which is not always right A possible solution in class Entities would be: public void escape Writer writer String str throws IOException { int len = str length ; for int i = ; i < len; i { int code = str codePointAt; String entityName = this entityName code ; if entityName = null { writer write ; writer write entityName ; writer write ; ; } else if code > xF { writer write ; writer write code ; writer write ; ; } else { writer write char code ; } if code > xffff { i ; } } } Besides fixing escapeXML this will also affect HTML escaping functions I guess that s a good thing but please remember I have only tested escapeXML ,1
0,Lang,StringEscapeUtils escapeXml input  outputs wrong results when an input contains characters in Supplementary Planes ,Hello I use StringEscapeUtils escapeXml input  to escape special characters for XML This method outputs wrong results when input contains characters in Supplementary Planes String str1 = \uD842\uDFB7 A ; String str2 = StringEscapeUtils escapeXml str1 ; The value of str2 must be equal to the one of str1 because str1 does not contain characters to be escaped However str2 is diffrent from str1 System out println URLEncoder encode str1 UTF-16BE  ; D8 42 DF B7A System out println URLEncoder encode str2 UTF-16BE  ; D8 42 DF B7 FF FD The cause of this problem is that the loop to translate input character by character is wrong In CharSequenceTranslator translate CharSequence input Writer out  loop counter i moves from 0 to Character codePointCount input 0 input length   but it should move from 0 to input length   ,Hello I use StringEscapeUtils escapeXml input  to escape special characters for XML This method outputs wrong results when input contains characters in Supplementary Planes String str = \uD\uDFB A ; String str = StringEscapeUtils escapeXml str ; The value of str must be equal to the one of str because str does not contain characters to be escaped However str is diffrent from str System out println URLEncoder encode str UTFBE  ; D  DF BA System out println URLEncoder encode str UTFBE  ; D  DF B FF FD The cause of this problem is that the loop to translate input character by character is wrong In CharSequenceTranslator translate CharSequence input Writer out  loop counter i moves from  to Character codePointCount input  input length   but it should move from  to input length   ,Hello I use StringEscapeUtils escapeXml input to escape special characters for XML This method outputs wrong results when input contains characters in Supplementary Planes String str = \uD\uDFB A ; String str = StringEscapeUtils escapeXml str ; The value of str must be equal to the one of str because str does not contain characters to be escaped However str is diffrent from str System out println URLEncoder encode str UTFBE ; D DF BA System out println URLEncoder encode str UTFBE ; D DF B FF FD The cause of this problem is that the loop to translate input character by character is wrong In CharSequenceTranslator translate CharSequence input Writer out loop counter i moves from to Character codePointCount input input length but it should move from to input length ,1
0,Lang,NumberUtils does not handle Long Hex numbers,NumberUtils createLong   does not handle hex numbers but createInteger   handles hex and octal This seems odd NumberUtils createNumber   assumes that hex numbers can only be Integer Again why not handle bigger Hex numbers == It is trivial to fix createLong   - just use Long decode   instead of valueOf   It s not clear why this was not done originally - the decode   method was added to both Integer and Long in Java 1 2 Fixing createNumber   is also fairly easy - if the hex string has more than 8 digits use Long Should we allow for leading zeros in an Integer If not the length check is trivial ,NumberUtils createLong   does not handle hex numbers but createInteger   handles hex and octal This seems odd NumberUtils createNumber   assumes that hex numbers can only be Integer Again why not handle bigger Hex numbers == It is trivial to fix createLong    just use Long decode   instead of valueOf   It s not clear why this was not done originally  the decode   method was added to both Integer and Long in Java   Fixing createNumber   is also fairly easy  if the hex string has more than  digits use Long Should we allow for leading zeros in an Integer If not the length check is trivial ,NumberUtils createLong does not handle hex numbers but createInteger handles hex and octal This seems odd NumberUtils createNumber assumes that hex numbers can only be Integer Again why not handle bigger Hex numbers == It is trivial to fix createLong just use Long decode instead of valueOf It s not clear why this was not done originally the decode method was added to both Integer and Long in Java Fixing createNumber is also fairly easy if the hex string has more than digits use Long Should we allow for leading zeros in an Integer If not the length check is trivial ,1
0,Lang,FastDateParser does not handle white-space properly,The SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,1
0,Lang,StringIndexOutOfBoundsException when calling unescapeHtml4  03  ,When calling unescapeHtml4   on the String  03 or any String that contains these characters  an Exception is thrown: Exception in thread main java lang StringIndexOutOfBoundsException: String index out of range: 4 at java lang String charAt String java:686  at org apache commons lang3 text translate NumericEntityUnescaper translate NumericEntityUnescaper java:49  at org apache commons lang3 text translate AggregateTranslator translate AggregateTranslator java:53  at org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java:88  at org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java:60  at org apache commons lang3 StringEscapeUtils unescapeHtml4 StringEscapeUtils java:351 ,When calling unescapeHtml   on the String   or any String that contains these characters  an Exception is thrown: Exception in thread main java lang StringIndexOutOfBoundsException: String index out of range:  at java lang String charAt String java:  at org apache commons lang text translate NumericEntityUnescaper translate NumericEntityUnescaper java:  at org apache commons lang text translate AggregateTranslator translate AggregateTranslator java:  at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java:  at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java:  at org apache commons lang StringEscapeUtils unescapeHtml StringEscapeUtils java: ,When calling unescapeHtml on the String or any String that contains these characters an Exception is thrown: Exception in thread main java lang StringIndexOutOfBoundsException: String index out of range: at java lang String charAt String java: at org apache commons lang text translate NumericEntityUnescaper translate NumericEntityUnescaper java: at org apache commons lang text translate AggregateTranslator translate AggregateTranslator java: at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java: at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java: at org apache commons lang StringEscapeUtils unescapeHtml StringEscapeUtils java: ,1
0,Lang,FastDateFormat format   outputs incorrect week of year because locale isn t respected,FastDateFormat apparently doesn t respect the locale it was sent on creation when outputting week in year e g ww   in format   It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which depending on the year  may result in the incorrect week number being output Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right: import java util Calendar; import java util Date; import java util Locale; import java text SimpleDateFormat; import org apache commons lang time FastDateFormat; public class FastDateFormatWeekBugDemo { public static void main String[] args  { Locale setDefault new Locale en US  ; Locale locale = new Locale sv SE  ; Calendar cal = Calendar getInstance  ; setting locale here doesn t change outcome cal set 2010 0 1 12 0 0 ; Date d = cal getTime  ; System out println Target date: d ; FastDateFormat fdf = FastDateFormat getInstance EEEE week ww locale ; SimpleDateFormat sdf = new SimpleDateFormat EEEE week ww locale ; System out println FastDateFormat: fdf format d ; will output FastDateFormat: fredag week 01 System out println SimpleDateFormat: sdf format d ; will output SimpleDateFormat: fredag week 53 } } If sv SE is passed to Locale setDefault   instead of en US both FastDateFormat and SimpleDateFormat output the correct week number ,FastDateFormat apparently doesn t respect the locale it was sent on creation when outputting week in year e g ww   in format   It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which depending on the year  may result in the incorrect week number being output Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right: import java util Calendar; import java util Date; import java util Locale; import java text SimpleDateFormat; import org apache commons lang time FastDateFormat; public class FastDateFormatWeekBugDemo { public static void main String[] args  { Locale setDefault new Locale en US  ; Locale locale = new Locale sv SE  ; Calendar cal = Calendar getInstance  ; setting locale here doesn t change outcome cal set       ; Date d = cal getTime  ; System out println Target date: d ; FastDateFormat fdf = FastDateFormat getInstance EEEE week ww locale ; SimpleDateFormat sdf = new SimpleDateFormat EEEE week ww locale ; System out println FastDateFormat: fdf format d ; will output FastDateFormat: fredag week  System out println SimpleDateFormat: sdf format d ; will output SimpleDateFormat: fredag week  } } If sv SE is passed to Locale setDefault   instead of en US both FastDateFormat and SimpleDateFormat output the correct week number ,FastDateFormat apparently doesn t respect the locale it was sent on creation when outputting week in year e g ww in format It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which depending on the year may result in the incorrect week number being output Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right: import java util Calendar; import java util Date; import java util Locale; import java text SimpleDateFormat; import org apache commons lang time FastDateFormat; public class FastDateFormatWeekBugDemo { public static void main String[] args { Locale setDefault new Locale en US ; Locale locale = new Locale sv SE ; Calendar cal = Calendar getInstance ; setting locale here doesn t change outcome cal set ; Date d = cal getTime ; System out println Target date: d ; FastDateFormat fdf = FastDateFormat getInstance EEEE week ww locale ; SimpleDateFormat sdf = new SimpleDateFormat EEEE week ww locale ; System out println FastDateFormat: fdf format d ; will output FastDateFormat: fredag week System out println SimpleDateFormat: sdf format d ; will output SimpleDateFormat: fredag week } } If sv SE is passed to Locale setDefault instead of en US both FastDateFormat and SimpleDateFormat output the correct week number ,1
0,Lang,FastDateFormat s z pattern does not respect timezone of Calendar instances passed to format  ,The work on LANG-462 has introduced a time zone formatting bug in FastDateFormat in commons-lang3 The problem can be seen by this snippet: Always prints timezone name of machine s default timezone ignoring TZ set on calendar even though the printed time itself respects calendar s TZ Calendar myCal = Calendar getInstance TimeZone getTimeZone US Central  ; System out println FastDateFormat getInstance h:mma z   format myCal ; If you happen to be in US Central this will print the right thing but just try it with US Eastern US Pacific etc It will print the time in the correct timezone but the timezone name at the end the z pattern  will always be the system default timezone This is a regression against commons-lang 2 x Basically when the forced time zone code was removed the TimeZoneNameRule class stopped respecting the Calendar instance s timezone and instead now always uses the mTimeZone of the FastDateFormat instance itself which is only supposed to be used when formatting timezone-less objects such as Date or long  The removal of the forced time zone stuff is surely the right thing to do it was a mess  I think the fix is to change the TimeZoneNameRule inner class to not take a TimeZone instance but rather to use the TimeZone on the Calendar instance passed into appendTo   just like TimeZoneNumberRule does Presumably then for efficiency one would use the getTimeZoneDisplay   package-static method to quickly retrieve the required timezone s display name ,The work on LANG has introduced a time zone formatting bug in FastDateFormat in commonslang The problem can be seen by this snippet: Always prints timezone name of machine s default timezone ignoring TZ set on calendar even though the printed time itself respects calendar s TZ Calendar myCal = Calendar getInstance TimeZone getTimeZone US Central  ; System out println FastDateFormat getInstance h:mma z   format myCal ; If you happen to be in US Central this will print the right thing but just try it with US Eastern US Pacific etc It will print the time in the correct timezone but the timezone name at the end the z pattern  will always be the system default timezone This is a regression against commonslang  x Basically when the forced time zone code was removed the TimeZoneNameRule class stopped respecting the Calendar instance s timezone and instead now always uses the mTimeZone of the FastDateFormat instance itself which is only supposed to be used when formatting timezoneless objects such as Date or long  The removal of the forced time zone stuff is surely the right thing to do it was a mess  I think the fix is to change the TimeZoneNameRule inner class to not take a TimeZone instance but rather to use the TimeZone on the Calendar instance passed into appendTo   just like TimeZoneNumberRule does Presumably then for efficiency one would use the getTimeZoneDisplay   packagestatic method to quickly retrieve the required timezone s display name ,The work on LANG has introduced a time zone formatting bug in FastDateFormat in commonslang The problem can be seen by this snippet: Always prints timezone name of machine s default timezone ignoring TZ set on calendar even though the printed time itself respects calendar s TZ Calendar myCal = Calendar getInstance TimeZone getTimeZone US Central ; System out println FastDateFormat getInstance h:mma z format myCal ; If you happen to be in US Central this will print the right thing but just try it with US Eastern US Pacific etc It will print the time in the correct timezone but the timezone name at the end the z pattern will always be the system default timezone This is a regression against commonslang x Basically when the forced time zone code was removed the TimeZoneNameRule class stopped respecting the Calendar instance s timezone and instead now always uses the mTimeZone of the FastDateFormat instance itself which is only supposed to be used when formatting timezoneless objects such as Date or long The removal of the forced time zone stuff is surely the right thing to do it was a mess I think the fix is to change the TimeZoneNameRule inner class to not take a TimeZone instance but rather to use the TimeZone on the Calendar instance passed into appendTo just like TimeZoneNumberRule does Presumably then for efficiency one would use the getTimeZoneDisplay packagestatic method to quickly retrieve the required timezone s display name ,1
0,Lang,DateUtils isSameLocalTime does not work correct,Hi I think I found a bug in the DateUtils class in the method isSameLocalTime Example: Calendar a = Calendar getInstance  ; a setTimeInMillis 1297364400000L ; Calendar b = Calendar getInstance  ; b setTimeInMillis 1297321200000L ; Assert assertFalse DateUtils isSameLocalTime a b ; This is because the method compares cal1 get Calendar HOUR  == cal2 get Calendar HOUR  but I think it has to be cal1 get Calendar HOUR OF DAY  == cal2 get Calendar HOUR OF DAY ,Hi I think I found a bug in the DateUtils class in the method isSameLocalTime Example: Calendar a = Calendar getInstance  ; a setTimeInMillis L ; Calendar b = Calendar getInstance  ; b setTimeInMillis L ; Assert assertFalse DateUtils isSameLocalTime a b ; This is because the method compares cal get Calendar HOUR  == cal get Calendar HOUR  but I think it has to be cal get Calendar HOUR OF DAY  == cal get Calendar HOUR OF DAY ,Hi I think I found a bug in the DateUtils class in the method isSameLocalTime Example: Calendar a = Calendar getInstance ; a setTimeInMillis L ; Calendar b = Calendar getInstance ; b setTimeInMillis L ; Assert assertFalse DateUtils isSameLocalTime a b ; This is because the method compares cal get Calendar HOUR == cal get Calendar HOUR but I think it has to be cal get Calendar HOUR OF DAY == cal get Calendar HOUR OF DAY ,1
0,Lang,NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in ,Seems to be similar to LANG-300 except that if you don t place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead ,Seems to be similar to LANG except that if you don t place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead ,Seems to be similar to LANG except that if you don t place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead ,1
0,Lang,ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes,When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur Example that will cause error: ExtendedMessageFormatTest java private static Map<String Object> formatRegistry = new HashMap<String Object>  ; static { formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory  ; } public static void main String[] args  { ExtendedMessageFormat mf = new ExtendedMessageFormat it s a {dummy} test formatRegistry ; String formattedPattern = mf format new String[] { great } ; System out println formattedPattern ; } } The following change starting at line 421 on the 2 4 release seems to fix the problem: ExtendedMessageFormat java CURRENT Broken : if escapingOn   c[start] == QUOTE  { return appendTo == null null : appendTo append QUOTE ; } WORKING: if escapingOn   c[start] == QUOTE  { next pos ; return appendTo == null null : appendTo append QUOTE ; },When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur Example that will cause error: ExtendedMessageFormatTest java private static Map<String Object> formatRegistry = new HashMap<String Object>  ; static { formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory  ; } public static void main String[] args  { ExtendedMessageFormat mf = new ExtendedMessageFormat it s a {dummy} test formatRegistry ; String formattedPattern = mf format new String[] { great } ; System out println formattedPattern ; } } The following change starting at line  on the   release seems to fix the problem: ExtendedMessageFormat java CURRENT Broken : if escapingOn   c[start] == QUOTE  { return appendTo == null null : appendTo append QUOTE ; } WORKING: if escapingOn   c[start] == QUOTE  { next pos ; return appendTo == null null : appendTo append QUOTE ; },When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur Example that will cause error: ExtendedMessageFormatTest java private static Map<String Object> formatRegistry = new HashMap<String Object> ; static { formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory ; } public static void main String[] args { ExtendedMessageFormat mf = new ExtendedMessageFormat it s a {dummy} test formatRegistry ; String formattedPattern = mf format new String[] { great } ; System out println formattedPattern ; } } The following change starting at line on the release seems to fix the problem: ExtendedMessageFormat java CURRENT Broken : if escapingOn c[start] == QUOTE { return appendTo == null null : appendTo append QUOTE ; } WORKING: if escapingOn c[start] == QUOTE { next pos ; return appendTo == null null : appendTo append QUOTE ; },1
0,Lang,DateFormatUtils format does not correctly change Calendar TimeZone in certain situations,If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; more commonly constructed with: cal = new GregorianCalendar 2009 9 16 8 42 16  for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar        for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; cal getTime ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; },1
0,Lang,NumberUtils isNumber   Should Return True for Valid Number with a Trailing Decimal Place,NumberUtils isNumber   should return true for a valid number ending in a trailing decimal place; e g 2 should be considered a number because new BigDecimal 2   works fine This could be done by adding the code below after line 1444 which is the if chars[i] == e || chars[i] == E   block if chars[i] ==   { if hasDecPoint || hasExp  { two decimal points or dec in exponent return false; } return foundDigit; single trailing decimal point after non-exponent is ok },NumberUtils isNumber   should return true for a valid number ending in a trailing decimal place; e g  should be considered a number because new BigDecimal    works fine This could be done by adding the code below after line  which is the if chars[i] == e || chars[i] == E   block if chars[i] ==   { if hasDecPoint || hasExp  { two decimal points or dec in exponent return false; } return foundDigit; single trailing decimal point after nonexponent is ok },NumberUtils isNumber should return true for a valid number ending in a trailing decimal place; e g should be considered a number because new BigDecimal works fine This could be done by adding the code below after line which is the if chars[i] == e || chars[i] == E block if chars[i] == { if hasDecPoint || hasExp { two decimal points or dec in exponent return false; } return foundDigit; single trailing decimal point after nonexponent is ok },1
0,Lang,StringUtils methods do not handle Unicode 2 0 supplementary characters correctly ,StringUtils containsAny methods incorrectly matches Unicode 2 0 supplementary characters For example define a test fixture to be the Unicode character U 20000 where U 20000 is written in Java source as \uD840\uDC00 private static final String CharU20000 = \uD840\uDC00 ; private static final String CharU20001 = \uD840\uDC01 ; You can see Unicode supplementary characters correctly implemented in the JRE call: assertEquals -1 CharU20000 indexOf CharU20001 ; But this is broken: assertEquals false StringUtils containsAny CharU20000 CharU20001 ; assertEquals false StringUtils containsAny CharU20001 CharU20000 ; This is fine: assertEquals true StringUtils contains CharU20000 CharU20001 CharU20000 ; assertEquals true StringUtils contains CharU20000 CharU20001 CharU20001 ; assertEquals true StringUtils contains CharU20000 CharU20000 ; assertEquals false StringUtils contains CharU20000 CharU20001 ; because the method calls the JRE to perform the match More than you want to know: http: java sun com developer technicalArticles Intl Supplementary ,StringUtils containsAny methods incorrectly matches Unicode   supplementary characters For example define a test fixture to be the Unicode character U  where U  is written in Java source as \uD\uDC private static final String CharU = \uD\uDC ; private static final String CharU = \uD\uDC ; You can see Unicode supplementary characters correctly implemented in the JRE call: assertEquals  CharU indexOf CharU ; But this is broken: assertEquals false StringUtils containsAny CharU CharU ; assertEquals false StringUtils containsAny CharU CharU ; This is fine: assertEquals true StringUtils contains CharU CharU CharU ; assertEquals true StringUtils contains CharU CharU CharU ; assertEquals true StringUtils contains CharU CharU ; assertEquals false StringUtils contains CharU CharU ; because the method calls the JRE to perform the match More than you want to know: http: java sun com developer technicalArticles Intl Supplementary ,StringUtils containsAny methods incorrectly matches Unicode supplementary characters For example define a test fixture to be the Unicode character U where U is written in Java source as \uD\uDC private static final String CharU = \uD\uDC ; private static final String CharU = \uD\uDC ; You can see Unicode supplementary characters correctly implemented in the JRE call: assertEquals CharU indexOf CharU ; But this is broken: assertEquals false StringUtils containsAny CharU CharU ; assertEquals false StringUtils containsAny CharU CharU ; This is fine: assertEquals true StringUtils contains CharU CharU CharU ; assertEquals true StringUtils contains CharU CharU CharU ; assertEquals true StringUtils contains CharU CharU ; assertEquals false StringUtils contains CharU CharU ; because the method calls the JRE to perform the match More than you want to know: http: java sun com developer technicalArticles Intl Supplementary ,1
0,Lang,[lang] DateUtils truncate method is buggy when dealing with DST switching hours,Try to truncate 2004-10-31 01:00:00 MDT by hour and you ll actually get 2004-10- 31 01:00:00 MST which is one hour after the input hour truncate 2004-10-31 01:00:00 MDT Date oct31 01MDT = new Date 1099206000000L ; Date result = DateUtils truncate oct31 01MDT Calendar HOUR OF DAY ; assertEquals oct31 01MDT result ;,Try to truncate  :: MDT by hour and you ll actually get   :: MST which is one hour after the input hour truncate  :: MDT Date oct MDT = new Date L ; Date result = DateUtils truncate oct MDT Calendar HOUR OF DAY ; assertEquals oct MDT result ;,Try to truncate :: MDT by hour and you ll actually get :: MST which is one hour after the input hour truncate :: MDT Date oct MDT = new Date L ; Date result = DateUtils truncate oct MDT Calendar HOUR OF DAY ; assertEquals oct MDT result ;,1
0,Lang,unescapeXml  12345678;   should be  12345678; ,Following test in EntitiesTest java  fails: public void testNumberOverflow   throws Exception { doTestUnescapeEntity  12345678;  12345678;  ; doTestUnescapeEntity x 12345678;y x 12345678;y  ; doTestUnescapeEntity  x12345678;  x12345678;  ; doTestUnescapeEntity x x12345678;y x x12345678;y  ; } Maximim value for char is 0xFFFF so  12345678; is invalid entity reference and so should be left as is ,Following test in EntitiesTest java  fails: public void testNumberOverflow   throws Exception { doTestUnescapeEntity  ;  ;  ; doTestUnescapeEntity x ;y x ;y  ; doTestUnescapeEntity  x;  x;  ; doTestUnescapeEntity x x;y x x;y  ; } Maximim value for char is xFFFF so  ; is invalid entity reference and so should be left as is ,Following test in EntitiesTest java fails: public void testNumberOverflow throws Exception { doTestUnescapeEntity ; ; ; doTestUnescapeEntity x ;y x ;y ; doTestUnescapeEntity x; x; ; doTestUnescapeEntity x x;y x x;y ; } Maximim value for char is xFFFF so ; is invalid entity reference and so should be left as is ,1
0,Lang,LocaleUtils toLocale   rejects strings with only language variant,LocaleUtils toLocale   throws an exception on strings containing a language and a variant but no country code For example : fr POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale fr POSIX   toString   According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code Commons Configuration handles this case in its PropertyConverter toLocale   method I d like to replace our implementation by the one provided by LocaleUtils but our tests fail due to this case ,LocaleUtils toLocale   throws an exception on strings containing a language and a variant but no country code For example : fr POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale fr POSIX   toString   According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code Commons Configuration handles this case in its PropertyConverter toLocale   method I d like to replace our implementation by the one provided by LocaleUtils but our tests fail due to this case ,LocaleUtils toLocale throws an exception on strings containing a language and a variant but no country code For example : fr POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale fr POSIX toString According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code Commons Configuration handles this case in its PropertyConverter toLocale method I d like to replace our implementation by the one provided by LocaleUtils but our tests fail due to this case ,1
0,Lang,Dates round   behaves incorrectly for minutes and seconds,Get unexpected output for rounding by minutes or seconds public void testRound   { Calendar testCalendar = Calendar getInstance TimeZone getTimeZone GMT  ; testCalendar set 2007 6 2 8 9 50 ; Date date = testCalendar getTime  ; System out println Before round   date ; System out println After round   DateUtils round date Calendar MINUTE ; } --2 1 produces Before round   Mon Jul 02 03:09:50 CDT 2007 After round   Mon Jul 02 03:10:00 CDT 2007 – this is what I would expect --2 2 and 2 3 produces Before round   Mon Jul 02 03:09:50 CDT 2007 After round   Mon Jul 02 03:01:00 CDT 2007 – this appears to be wrong,Get unexpected output for rounding by minutes or seconds public void testRound   { Calendar testCalendar = Calendar getInstance TimeZone getTimeZone GMT  ; testCalendar set       ; Date date = testCalendar getTime  ; System out println Before round   date ; System out println After round   DateUtils round date Calendar MINUTE ; }   produces Before round   Mon Jul  :: CDT  After round   Mon Jul  :: CDT  – this is what I would expect   and   produces Before round   Mon Jul  :: CDT  After round   Mon Jul  :: CDT  – this appears to be wrong,Get unexpected output for rounding by minutes or seconds public void testRound { Calendar testCalendar = Calendar getInstance TimeZone getTimeZone GMT ; testCalendar set ; Date date = testCalendar getTime ; System out println Before round date ; System out println After round DateUtils round date Calendar MINUTE ; } produces Before round Mon Jul :: CDT After round Mon Jul :: CDT – this is what I would expect and produces Before round Mon Jul :: CDT After round Mon Jul :: CDT – this appears to be wrong,1
0,Lang,StringUtils methods do not handle Unicode 2 0 supplementary characters correctly ,StringUtils containsAny methods incorrectly matches Unicode 2 0 supplementary characters For example define a test fixture to be the Unicode character U 20000 where U 20000 is written in Java source as \uD840\uDC00 private static final String CharU20000 = \uD840\uDC00 ; private static final String CharU20001 = \uD840\uDC01 ; You can see Unicode supplementary characters correctly implemented in the JRE call: assertEquals -1 CharU20000 indexOf CharU20001 ; But this is broken: assertEquals false StringUtils containsAny CharU20000 CharU20001 ; assertEquals false StringUtils containsAny CharU20001 CharU20000 ; This is fine: assertEquals true StringUtils contains CharU20000 CharU20001 CharU20000 ; assertEquals true StringUtils contains CharU20000 CharU20001 CharU20001 ; assertEquals true StringUtils contains CharU20000 CharU20000 ; assertEquals false StringUtils contains CharU20000 CharU20001 ; because the method calls the JRE to perform the match More than you want to know: http: java sun com developer technicalArticles Intl Supplementary ,StringUtils containsAny methods incorrectly matches Unicode   supplementary characters For example define a test fixture to be the Unicode character U  where U  is written in Java source as \uD\uDC private static final String CharU = \uD\uDC ; private static final String CharU = \uD\uDC ; You can see Unicode supplementary characters correctly implemented in the JRE call: assertEquals  CharU indexOf CharU ; But this is broken: assertEquals false StringUtils containsAny CharU CharU ; assertEquals false StringUtils containsAny CharU CharU ; This is fine: assertEquals true StringUtils contains CharU CharU CharU ; assertEquals true StringUtils contains CharU CharU CharU ; assertEquals true StringUtils contains CharU CharU ; assertEquals false StringUtils contains CharU CharU ; because the method calls the JRE to perform the match More than you want to know: http: java sun com developer technicalArticles Intl Supplementary ,StringUtils containsAny methods incorrectly matches Unicode supplementary characters For example define a test fixture to be the Unicode character U where U is written in Java source as \uD\uDC private static final String CharU = \uD\uDC ; private static final String CharU = \uD\uDC ; You can see Unicode supplementary characters correctly implemented in the JRE call: assertEquals CharU indexOf CharU ; But this is broken: assertEquals false StringUtils containsAny CharU CharU ; assertEquals false StringUtils containsAny CharU CharU ; This is fine: assertEquals true StringUtils contains CharU CharU CharU ; assertEquals true StringUtils contains CharU CharU CharU ; assertEquals true StringUtils contains CharU CharU ; assertEquals false StringUtils contains CharU CharU ; because the method calls the JRE to perform the match More than you want to know: http: java sun com developer technicalArticles Intl Supplementary ,1
0,Lang,ArrayUtils addAll T[] array1 T array2  does not handle mixed types very well,ArrayUtils addAll T[] array1 T array2  does not handle mixed array types very well The stack trace for Number[] st = ArrayUtils addAll new Integer[] {1} new Long[] {2L}  ; starts: java lang ArrayStoreException at java lang System arraycopy Native Method  at org apache commons lang3 ArrayUtils addAll ArrayUtils java:2962  which is not all that obvious It would be a lot clearer if the method threw an IlegalArgumentException or similar ,ArrayUtils addAll T[] array T array  does not handle mixed array types very well The stack trace for Number[] st = ArrayUtils addAll new Integer[] {} new Long[] {L}  ; starts: java lang ArrayStoreException at java lang System arraycopy Native Method  at org apache commons lang ArrayUtils addAll ArrayUtils java:  which is not all that obvious It would be a lot clearer if the method threw an IlegalArgumentException or similar ,ArrayUtils addAll T[] array T array does not handle mixed array types very well The stack trace for Number[] st = ArrayUtils addAll new Integer[] {} new Long[] {L} ; starts: java lang ArrayStoreException at java lang System arraycopy Native Method at org apache commons lang ArrayUtils addAll ArrayUtils java: which is not all that obvious It would be a lot clearer if the method threw an IlegalArgumentException or similar ,1
0,Lang,StringUtils replaceEach - Bug or Missing Documentation,The following Test Case for replaceEach fails with a null pointer exception I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null I admit the use case is not perfect because it is unclear what happens on the replace I outlined three expectations in the test case of course only one should be met If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string import static org junit Assert assertEquals; import org apache commons lang StringUtils; import org junit Test; public class StringUtilsTest {  Test public void replaceEach  { String original = Hello World ; String[] searchList = { Hello World }; String[] replacementList = { Greetings null}; String result = StringUtils replaceEach original searchList replacementList ; assertEquals Greetings result ; perhaps this is ok as well assertEquals Greetings World result ; or even assertEquals Greetings null result ; } },The following Test Case for replaceEach fails with a null pointer exception I have expected that all StringUtils methods are nullfriendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null I admit the use case is not perfect because it is unclear what happens on the replace I outlined three expectations in the test case of course only one should be met If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string import static org junit Assert assertEquals; import org apache commons lang StringUtils; import org junit Test; public class StringUtilsTest {  Test public void replaceEach  { String original = Hello World ; String[] searchList = { Hello World }; String[] replacementList = { Greetings null}; String result = StringUtils replaceEach original searchList replacementList ; assertEquals Greetings result ; perhaps this is ok as well assertEquals Greetings World result ; or even assertEquals Greetings null result ; } },The following Test Case for replaceEach fails with a null pointer exception I have expected that all StringUtils methods are nullfriendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null I admit the use case is not perfect because it is unclear what happens on the replace I outlined three expectations in the test case of course only one should be met If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string import static org junit Assert assertEquals; import org apache commons lang StringUtils; import org junit Test; public class StringUtilsTest { Test public void replaceEach { String original = Hello World ; String[] searchList = { Hello World }; String[] replacementList = { Greetings null}; String result = StringUtils replaceEach original searchList replacementList ; assertEquals Greetings result ; perhaps this is ok as well assertEquals Greetings World result ; or even assertEquals Greetings null result ; } },1
0,Lang,StringEscapeUtils escapeJavaScript   method did not escape into \ it will make IE render page uncorrectly,If Javascripts including IE will parse the scripts uncorrectly actually should be escaped to \ For example document getElementById test   value = <script>alert \ aaa\  ;< script> ;this expression will make IE render page uncorrect it should be document getElementById test   value = <script>alert \ aaa\  ;<\ script> ; Btw Spring s JavascriptEscape behavor is correct Try to run below codes you will find the difference: String s = <script>alert aaa  ;< script> ; String str = org springframework web util JavaScriptUtils javaScriptEscape s ; System out println Spring JS Escape : str ; str = org apache commons lang StringEscapeUtils escapeJavaScript s ; System out println Apache Common Lang JS Escape : str ;,If Javascripts including IE will parse the scripts uncorrectly actually should be escaped to \ For example document getElementById test   value = <script>alert \ aaa\  ;< script> ;this expression will make IE render page uncorrect it should be document getElementById test   value = <script>alert \ aaa\  ;<\ script> ; Btw Spring s JavascriptEscape behavor is correct Try to run below codes you will find the difference: String s = <script>alert aaa  ;< script> ; String str = org springframework web util JavaScriptUtils javaScriptEscape s ; System out println Spring JS Escape : str ; str = org apache commons lang StringEscapeUtils escapeJavaScript s ; System out println Apache Common Lang JS Escape : str ;,If Javascripts including IE will parse the scripts uncorrectly actually should be escaped to \ For example document getElementById test value = <script>alert \ aaa\ ;< script> ;this expression will make IE render page uncorrect it should be document getElementById test value = <script>alert \ aaa\ ;<\ script> ; Btw Spring s JavascriptEscape behavor is correct Try to run below codes you will find the difference: String s = <script>alert aaa ;< script> ; String str = org springframework web util JavaScriptUtils javaScriptEscape s ; System out println Spring JS Escape : str ; str = org apache commons lang StringEscapeUtils escapeJavaScript s ; System out println Apache Common Lang JS Escape : str ;,1
0,Lang,StopWatch: suspend   acts as split   if followed by stop  ,In my opinion it is a bug that suspend   acts as split   if followed by stop  ; see below: StopWatch sw = new StopWatch  ; sw start  ; Thread sleep 1000 ; sw suspend  ; Time 1 ok  System out println sw getTime  ; Thread sleep 2000 ; Time 1 again ok  System out println sw getTime  ; sw resume  ; Thread sleep 3000 ; sw suspend  ; Time 2 ok  System out println sw getTime  ; Thread sleep 4000 ; Time 2 again ok  System out println sw getTime  ; Thread sleep 5000 ; sw stop  ; Time 2 should be but is Time 3 => NOT ok  System out println sw getTime  ; suspend resume is like a pause where time counter doesn t continue So a following stop  -call shouldn t increase the time counter should it ,In my opinion it is a bug that suspend   acts as split   if followed by stop  ; see below: StopWatch sw = new StopWatch  ; sw start  ; Thread sleep  ; sw suspend  ; Time  ok  System out println sw getTime  ; Thread sleep  ; Time  again ok  System out println sw getTime  ; sw resume  ; Thread sleep  ; sw suspend  ; Time  ok  System out println sw getTime  ; Thread sleep  ; Time  again ok  System out println sw getTime  ; Thread sleep  ; sw stop  ; Time  should be but is Time  => NOT ok  System out println sw getTime  ; suspend resume is like a pause where time counter doesn t continue So a following stop  call shouldn t increase the time counter should it ,In my opinion it is a bug that suspend acts as split if followed by stop ; see below: StopWatch sw = new StopWatch ; sw start ; Thread sleep ; sw suspend ; Time ok System out println sw getTime ; Thread sleep ; Time again ok System out println sw getTime ; sw resume ; Thread sleep ; sw suspend ; Time ok System out println sw getTime ; Thread sleep ; Time again ok System out println sw getTime ; Thread sleep ; sw stop ; Time should be but is Time => NOT ok System out println sw getTime ; suspend resume is like a pause where time counter doesn t continue So a following stop call shouldn t increase the time counter should it ,1
0,Lang,DurationFormatUtils returns wrong result,DurationFormatUtils returns wrong result oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off I ve tested against 2 1 and 2 2 Calendar cal = Calendar getInstance  ; cal set Calendar MONTH Calendar DECEMBER ; cal set Calendar DAY OF MONTH 31 ; cal set Calendar YEAR 2005 ; cal set Calendar HOUR OF DAY 0 ; cal set Calendar MINUTE 0 ; cal set Calendar SECOND 0 ; cal set Calendar MILLISECOND 0 ; String result = DurationFormatUtils formatPeriod cal getTimeInMillis   System currentTimeMillis   MM  ; System out println result ;,DurationFormatUtils returns wrong result oddly it is only when Date is set to Dec   The following code will result in a String of  which is way off I ve tested against   and   Calendar cal = Calendar getInstance  ; cal set Calendar MONTH Calendar DECEMBER ; cal set Calendar DAY OF MONTH  ; cal set Calendar YEAR  ; cal set Calendar HOUR OF DAY  ; cal set Calendar MINUTE  ; cal set Calendar SECOND  ; cal set Calendar MILLISECOND  ; String result = DurationFormatUtils formatPeriod cal getTimeInMillis   System currentTimeMillis   MM  ; System out println result ;,DurationFormatUtils returns wrong result oddly it is only when Date is set to Dec The following code will result in a String of which is way off I ve tested against and Calendar cal = Calendar getInstance ; cal set Calendar MONTH Calendar DECEMBER ; cal set Calendar DAY OF MONTH ; cal set Calendar YEAR ; cal set Calendar HOUR OF DAY ; cal set Calendar MINUTE ; cal set Calendar SECOND ; cal set Calendar MILLISECOND ; String result = DurationFormatUtils formatPeriod cal getTimeInMillis System currentTimeMillis MM ; System out println result ;,1
0,Lang,ValuedEnum compareTo Object other  not typesafe - it easily could be ,int org apache commons lang enums ValuedEnum compareTo Object other  is not typesafe - if the int-values are the same it will return 0 even for two totally different sub-classes of ValuedEnum,int org apache commons lang enums ValuedEnum compareTo Object other  is not typesafe  if the intvalues are the same it will return  even for two totally different subclasses of ValuedEnum,int org apache commons lang enums ValuedEnum compareTo Object other is not typesafe if the intvalues are the same it will return even for two totally different subclasses of ValuedEnum,1
0,Lang,StringEscapeUtils escapeJava String  escapes characters,Commons Lang 2 4 StringEscapeUtils escapeJava String  now escapes characters which is not a valid escapable character in Java strings I haven t tried the other Java escape unescape methods to see if they have a similar problem or that only Java escapable characters are escaped by escapeJava String  This bug may have appeared as an unintended side-effect of the fix for LANG-363 Also the javadoc for escapeJava is now a little off in that should now be included in the sentence describing the differences between Java and Javascript strings with respect to escaping rules The following is a JUnit3 test demonstrating the bug import junit framework TestCase; import org apache commons lang StringEscapeUtils; public class StringEscapeUtilsTest extends TestCase { public void testEscapeJavaWithSlash   { final String input = String with a slash   in it ; final String expected = input; final String actual = StringEscapeUtils escapeJava input  ; In 2 4 StringEscapeUtils escapeJava String  escapes characters which are not a valid character to escape in a Java string assertEquals expected actual  ; } },Commons Lang   StringEscapeUtils escapeJava String  now escapes characters which is not a valid escapable character in Java strings I haven t tried the other Java escape unescape methods to see if they have a similar problem or that only Java escapable characters are escaped by escapeJava String  This bug may have appeared as an unintended sideeffect of the fix for LANG Also the javadoc for escapeJava is now a little off in that should now be included in the sentence describing the differences between Java and Javascript strings with respect to escaping rules The following is a JUnit test demonstrating the bug import junit framework TestCase; import org apache commons lang StringEscapeUtils; public class StringEscapeUtilsTest extends TestCase { public void testEscapeJavaWithSlash   { final String input = String with a slash   in it ; final String expected = input; final String actual = StringEscapeUtils escapeJava input  ; In   StringEscapeUtils escapeJava String  escapes characters which are not a valid character to escape in a Java string assertEquals expected actual  ; } },Commons Lang StringEscapeUtils escapeJava String now escapes characters which is not a valid escapable character in Java strings I haven t tried the other Java escape unescape methods to see if they have a similar problem or that only Java escapable characters are escaped by escapeJava String This bug may have appeared as an unintended sideeffect of the fix for LANG Also the javadoc for escapeJava is now a little off in that should now be included in the sentence describing the differences between Java and Javascript strings with respect to escaping rules The following is a JUnit test demonstrating the bug import junit framework TestCase; import org apache commons lang StringEscapeUtils; public class StringEscapeUtilsTest extends TestCase { public void testEscapeJavaWithSlash { final String input = String with a slash in it ; final String expected = input; final String actual = StringEscapeUtils escapeJava input ; In StringEscapeUtils escapeJava String escapes characters which are not a valid character to escape in a Java string assertEquals expected actual ; } },1
0,Lang,ClassUtils getShortClassName   will not work with an array; it seems to add a semicolon to the end ,A semicolon is introduced into the class name at the end for all arrays String sArray[] = new String[2]; sArray[0] = mark ; sArray[1] = is cool ; String simpleString = chris ; assertEquals String ClassUtils getShortClassName simpleString null ; assertEquals String; ClassUtils getShortClassName sArray null ;,A semicolon is introduced into the class name at the end for all arrays String sArray[] = new String[]; sArray[] = mark ; sArray[] = is cool ; String simpleString = chris ; assertEquals String ClassUtils getShortClassName simpleString null ; assertEquals String; ClassUtils getShortClassName sArray null ;,A semicolon is introduced into the class name at the end for all arrays String sArray[] = new String[]; sArray[] = mark ; sArray[] = is cool ; String simpleString = chris ; assertEquals String ClassUtils getShortClassName simpleString null ; assertEquals String; ClassUtils getShortClassName sArray null ;,1
0,Lang,EqualsBuilder don t compare BigDecimals correctly,When comparing a BigDecimal the comparing is made using equals not compareTo which is more appropriate in the case of BigDecimal ,When comparing a BigDecimal the comparing is made using equals not compareTo which is more appropriate in the case of BigDecimal ,When comparing a BigDecimal the comparing is made using equals not compareTo which is more appropriate in the case of BigDecimal ,1
0,Lang,NumberUtils isNumber String  is not right when the String is 1 1L , 1 1L is not a Java Number but NumberUtils isNumber String  return true perhaps change: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp; } to: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp   hasDecPoint; },  L is not a Java Number but NumberUtils isNumber String  return true perhaps change: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp; } to: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp   hasDecPoint; }, L is not a Java Number but NumberUtils isNumber String return true perhaps change: if chars[i] == l || chars[i] == L { not allowing L with an exponent return foundDigit hasExp; } to: if chars[i] == l || chars[i] == L { not allowing L with an exponent return foundDigit hasExp hasDecPoint; },1
0,Lang,text ExtendedMessageFormat doesn t override java text MessageFormat equals Object ,Findbugs: Bug: org apache commons lang3 text ExtendedMessageFormat doesn t override java text MessageFormat equals Object  Pattern id: EQ DOESNT OVERRIDE EQUALS type: Eq category: STYLE This class extends a class that defines an equals method and adds fields but doesn t define an equals method itself Thus equality on instances of this class will ignore the identity of the subclass and the added fields Be sure this is what is intended and that you don t need to override the equals method Even if you don t need to override the equals method consider overriding it anyway to document the fact that the equals method for the subclass just return the result of invoking super equals o  ,Findbugs: Bug: org apache commons lang text ExtendedMessageFormat doesn t override java text MessageFormat equals Object  Pattern id: EQ DOESNT OVERRIDE EQUALS type: Eq category: STYLE This class extends a class that defines an equals method and adds fields but doesn t define an equals method itself Thus equality on instances of this class will ignore the identity of the subclass and the added fields Be sure this is what is intended and that you don t need to override the equals method Even if you don t need to override the equals method consider overriding it anyway to document the fact that the equals method for the subclass just return the result of invoking super equals o  ,Findbugs: Bug: org apache commons lang text ExtendedMessageFormat doesn t override java text MessageFormat equals Object Pattern id: EQ DOESNT OVERRIDE EQUALS type: Eq category: STYLE This class extends a class that defines an equals method and adds fields but doesn t define an equals method itself Thus equality on instances of this class will ignore the identity of the subclass and the added fields Be sure this is what is intended and that you don t need to override the equals method Even if you don t need to override the equals method consider overriding it anyway to document the fact that the equals method for the subclass just return the result of invoking super equals o ,1
0,Lang,LookupTranslator accepts CharSequence as input but fails to work with implementations other than String,The core of org apache commons lang3 text translate is a HashMap<CharSequence CharSequence> lookupMap From the Javadoc of CharSequence emphasis mine : This interface does not refine the general contracts of the equals and hashCode methods The result of comparing two objects that implement CharSequence is therefore in general undefined Each object may be implemented by a different class and there is no guarantee that each class will be capable of testing its instances for equality with those of the other It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map The current implementation causes code such as the following to not work as expected: CharSequence cs1 = 1 < 2 ; CharSequence cs2 = CharBuffer wrap 1 < 2 toCharArray  ; System out println StringEscapeUtils ESCAPE HTML4 translate cs1 ; System out println StringEscapeUtils ESCAPE HTML4 translate cs2 ; which gives the following results but should be identical : 1  lt; 2 1 < 2 The problem at a minimum is that CharBuffer equals is even documented in the Javadoc that: A char buffer is not equal to any other type of object so a lookup on a CharBuffer in the Map will always fail when compared against the String implementations that it contains An obvious work-around is to instead use something along the lines of either of the following: System out println StringEscapeUtils ESCAPE HTML4 translate cs2 toString  ; System out println StringEscapeUtils escapeHtml4 cs2 toString  ; which forces everything back to a String However this is not practical when working with large sets of data which would require significant heap allocations and garbage collection concerns As such I was actually trying to use the translate method that outputs to a Writer - but simplified the above examples to omit this   Another option that I m considering is to use a custom CharSequence wrapper around a char[] that implements hashCode   and equals   to work with those implemented on String However this will be interesting due to the symmetric assumption - which is further interesting that String equals is currently implemented using instanceof - even though String is final  ,The core of org apache commons lang text translate is a HashMap<CharSequence CharSequence> lookupMap From the Javadoc of CharSequence emphasis mine : This interface does not refine the general contracts of the equals and hashCode methods The result of comparing two objects that implement CharSequence is therefore in general undefined Each object may be implemented by a different class and there is no guarantee that each class will be capable of testing its instances for equality with those of the other It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map The current implementation causes code such as the following to not work as expected: CharSequence cs =  <  ; CharSequence cs = CharBuffer wrap  <  toCharArray  ; System out println StringEscapeUtils ESCAPE HTML translate cs ; System out println StringEscapeUtils ESCAPE HTML translate cs ; which gives the following results but should be identical :   lt;   <  The problem at a minimum is that CharBuffer equals is even documented in the Javadoc that: A char buffer is not equal to any other type of object so a lookup on a CharBuffer in the Map will always fail when compared against the String implementations that it contains An obvious workaround is to instead use something along the lines of either of the following: System out println StringEscapeUtils ESCAPE HTML translate cs toString  ; System out println StringEscapeUtils escapeHtml cs toString  ; which forces everything back to a String However this is not practical when working with large sets of data which would require significant heap allocations and garbage collection concerns As such I was actually trying to use the translate method that outputs to a Writer  but simplified the above examples to omit this   Another option that I m considering is to use a custom CharSequence wrapper around a char[] that implements hashCode   and equals   to work with those implemented on String However this will be interesting due to the symmetric assumption  which is further interesting that String equals is currently implemented using instanceof  even though String is final  ,The core of org apache commons lang text translate is a HashMap<CharSequence CharSequence> lookupMap From the Javadoc of CharSequence emphasis mine : This interface does not refine the general contracts of the equals and hashCode methods The result of comparing two objects that implement CharSequence is therefore in general undefined Each object may be implemented by a different class and there is no guarantee that each class will be capable of testing its instances for equality with those of the other It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map The current implementation causes code such as the following to not work as expected: CharSequence cs = < ; CharSequence cs = CharBuffer wrap < toCharArray ; System out println StringEscapeUtils ESCAPE HTML translate cs ; System out println StringEscapeUtils ESCAPE HTML translate cs ; which gives the following results but should be identical : lt; < The problem at a minimum is that CharBuffer equals is even documented in the Javadoc that: A char buffer is not equal to any other type of object so a lookup on a CharBuffer in the Map will always fail when compared against the String implementations that it contains An obvious workaround is to instead use something along the lines of either of the following: System out println StringEscapeUtils ESCAPE HTML translate cs toString ; System out println StringEscapeUtils escapeHtml cs toString ; which forces everything back to a String However this is not practical when working with large sets of data which would require significant heap allocations and garbage collection concerns As such I was actually trying to use the translate method that outputs to a Writer but simplified the above examples to omit this Another option that I m considering is to use a custom CharSequence wrapper around a char[] that implements hashCode and equals to work with those implemented on String However this will be interesting due to the symmetric assumption which is further interesting that String equals is currently implemented using instanceof even though String is final ,1
0,Lang,TypeUtils getTypeArguments   misses type arguments for partially-assigned classes,failing test code to add to TypeUtilsTest testGetTypeArguments  : typeVarAssigns = TypeUtils getTypeArguments Other class This class ; Assert assertEquals 2 typeVarAssigns size  ; Assert assertEquals String class typeVarAssigns get This class getTypeParameters  [0] ; Assert assertEquals Other class getTypeParameters  [0] typeVarAssigns get This class getTypeParameters  [1] ; These should pass based on: public interface This<K V> { } public class Other<T> implements This<String T> { } This case fails because the current code ignores the Other class due to its specifying its own type variables which is obviously incorrect This report is extrapolated from an offline report received by Hen ,failing test code to add to TypeUtilsTest testGetTypeArguments  : typeVarAssigns = TypeUtils getTypeArguments Other class This class ; Assert assertEquals  typeVarAssigns size  ; Assert assertEquals String class typeVarAssigns get This class getTypeParameters  [] ; Assert assertEquals Other class getTypeParameters  [] typeVarAssigns get This class getTypeParameters  [] ; These should pass based on: public interface This<K V> { } public class Other<T> implements This<String T> { } This case fails because the current code ignores the Other class due to its specifying its own type variables which is obviously incorrect This report is extrapolated from an offline report received by Hen ,failing test code to add to TypeUtilsTest testGetTypeArguments : typeVarAssigns = TypeUtils getTypeArguments Other class This class ; Assert assertEquals typeVarAssigns size ; Assert assertEquals String class typeVarAssigns get This class getTypeParameters [] ; Assert assertEquals Other class getTypeParameters [] typeVarAssigns get This class getTypeParameters [] ; These should pass based on: public interface This<K V> { } public class Other<T> implements This<String T> { } This case fails because the current code ignores the Other class due to its specifying its own type variables which is obviously incorrect This report is extrapolated from an offline report received by Hen ,1
0,Lang,Method createNumber from NumberUtils doesn t work for floating point numbers other than Float,Method createNumber from NumberUtils is trying to parse a string with a floating point number always first as a Float that will cause that if we send a string with a number that will need a Double or even a BigDecimal the number will be truncate to accommodate into the Float without an exception to be thrown so in fact we will no be returning ever neither a Double nor a BigDecimal ,Method createNumber from NumberUtils is trying to parse a string with a floating point number always first as a Float that will cause that if we send a string with a number that will need a Double or even a BigDecimal the number will be truncate to accommodate into the Float without an exception to be thrown so in fact we will no be returning ever neither a Double nor a BigDecimal ,Method createNumber from NumberUtils is trying to parse a string with a floating point number always first as a Float that will cause that if we send a string with a number that will need a Double or even a BigDecimal the number will be truncate to accommodate into the Float without an exception to be thrown so in fact we will no be returning ever neither a Double nor a BigDecimal ,1
0,Lang,RandomStringUtils random count 0 0 false false universe random  always throws java lang ArrayIndexOutOfBoundsException,In commons-lang 2 6 line 250 : ch = chars[random nextInt gap  start]; This line of code takes a random int to fetch a char in the chars array regardless of its size Besides start is useless here  Fixed version would be : ch = chars[random nextInt gap chars length]; When user pass 0 as end or when the array is not null but empty this line ends up with an exception,In commonslang   line  : ch = chars[random nextInt gap  start]; This line of code takes a random int to fetch a char in the chars array regardless of its size Besides start is useless here  Fixed version would be : ch = chars[random nextInt gap chars length]; When user pass  as end or when the array is not null but empty this line ends up with an exception,In commonslang line : ch = chars[random nextInt gap start]; This line of code takes a random int to fetch a char in the chars array regardless of its size Besides start is useless here Fixed version would be : ch = chars[random nextInt gap chars length]; When user pass as end or when the array is not null but empty this line ends up with an exception,1
0,Lang,infinite loop in Fraction reduce when numerator == 0,Summary pretty much says it all ,Summary pretty much says it all ,Summary pretty much says it all ,1
0,Lang,Fix case-insensitive string handling,String to Case   is locale-sensitive this is usually not intended for case-insensitive comparisions Please see Common Bug  3 for details ,String to Case   is localesensitive this is usually not intended for caseinsensitive comparisions Please see Common Bug   for details ,String to Case is localesensitive this is usually not intended for caseinsensitive comparisions Please see Common Bug for details ,1
0,Lang,StrBuilder appendFixedWidth does not handle nulls,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText has not been set ,1
0,Lang,SerializationUtils throws ClassNotFoundException when cloning primitive classes,If a serializable object contains a reference to a primitive class e g int class or int[] class the SerializationUtils throw a ClassNotFoundException when trying to clone that object import org apache commons lang3 SerializationUtils; import org junit Test; public class SerializationUtilsTest {  Test public void primitiveTypeClassSerialization  { Class< > primitiveType = int class; Class< > clone = SerializationUtils clone primitiveType ; assertEquals primitiveType clone ; } } The problem was already reported as a java bug http: bugs sun com view bug do bug id=4171142 and ObjectInputStream is fixed since java version 1 4 The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream s resoleClass method without delegating to the super method in case of a ClassNotFoundException I understand the intention of the ClassLoaderAwareObjectInputStream but this implementation should also implement a fallback to the original implementation For example: protected Class< > resolveClass ObjectStreamClass desc  throws IOException ClassNotFoundException { String name = desc getName  ; try { return Class forName name false classLoader ; } catch ClassNotFoundException ex  { try { return Class forName name false Thread currentThread   getContextClassLoader  ; } catch Exception e  { return super resolveClass desc ; } } } Here is the code in ObjectInputStream that fixed the java bug protected Class< > resolveClass ObjectStreamClass desc  throws IOException ClassNotFoundException { String name = desc getName  ; try { return Class forName name false latestUserDefinedLoader  ; } catch ClassNotFoundException ex  { Class cl = Class  primClasses get name ; if cl = null  { return cl; } else { throw ex; } } },If a serializable object contains a reference to a primitive class e g int class or int[] class the SerializationUtils throw a ClassNotFoundException when trying to clone that object import org apache commons lang SerializationUtils; import org junit Test; public class SerializationUtilsTest {  Test public void primitiveTypeClassSerialization  { Class< > primitiveType = int class; Class< > clone = SerializationUtils clone primitiveType ; assertEquals primitiveType clone ; } } The problem was already reported as a java bug http: bugs sun com view bug do bug id= and ObjectInputStream is fixed since java version   The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream s resoleClass method without delegating to the super method in case of a ClassNotFoundException I understand the intention of the ClassLoaderAwareObjectInputStream but this implementation should also implement a fallback to the original implementation For example: protected Class< > resolveClass ObjectStreamClass desc  throws IOException ClassNotFoundException { String name = desc getName  ; try { return Class forName name false classLoader ; } catch ClassNotFoundException ex  { try { return Class forName name false Thread currentThread   getContextClassLoader  ; } catch Exception e  { return super resolveClass desc ; } } } Here is the code in ObjectInputStream that fixed the java bug protected Class< > resolveClass ObjectStreamClass desc  throws IOException ClassNotFoundException { String name = desc getName  ; try { return Class forName name false latestUserDefinedLoader  ; } catch ClassNotFoundException ex  { Class cl = Class  primClasses get name ; if cl = null  { return cl; } else { throw ex; } } },If a serializable object contains a reference to a primitive class e g int class or int[] class the SerializationUtils throw a ClassNotFoundException when trying to clone that object import org apache commons lang SerializationUtils; import org junit Test; public class SerializationUtilsTest { Test public void primitiveTypeClassSerialization { Class< > primitiveType = int class; Class< > clone = SerializationUtils clone primitiveType ; assertEquals primitiveType clone ; } } The problem was already reported as a java bug http: bugs sun com view bug do bug id= and ObjectInputStream is fixed since java version The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream s resoleClass method without delegating to the super method in case of a ClassNotFoundException I understand the intention of the ClassLoaderAwareObjectInputStream but this implementation should also implement a fallback to the original implementation For example: protected Class< > resolveClass ObjectStreamClass desc throws IOException ClassNotFoundException { String name = desc getName ; try { return Class forName name false classLoader ; } catch ClassNotFoundException ex { try { return Class forName name false Thread currentThread getContextClassLoader ; } catch Exception e { return super resolveClass desc ; } } } Here is the code in ObjectInputStream that fixed the java bug protected Class< > resolveClass ObjectStreamClass desc throws IOException ClassNotFoundException { String name = desc getName ; try { return Class forName name false latestUserDefinedLoader ; } catch ClassNotFoundException ex { Class cl = Class primClasses get name ; if cl = null { return cl; } else { throw ex; } } },1
0,Lang,LocaleUtils toLocale does not parse strings starting with an underscore,Hi Javadocs of Locale toString   states that If the language is missing the string will begin with an underbar This is not handled in the LocaleUtils toLocale method if it is meant to be the inversion method of Locale toString   The fix for the ticket 328 does not handle well the case fr P which I found out during fixing the first bug I am attaching the patch for both problems ,Hi Javadocs of Locale toString   states that If the language is missing the string will begin with an underbar This is not handled in the LocaleUtils toLocale method if it is meant to be the inversion method of Locale toString   The fix for the ticket  does not handle well the case fr P which I found out during fixing the first bug I am attaching the patch for both problems ,Hi Javadocs of Locale toString states that If the language is missing the string will begin with an underbar This is not handled in the LocaleUtils toLocale method if it is meant to be the inversion method of Locale toString The fix for the ticket does not handle well the case fr P which I found out during fixing the first bug I am attaching the patch for both problems ,1
0,Lang,StringUtils equals   relies on undefined behavior,Since the java lang CharSequence class was first introduced in 1 4 the JavaDoc block has contained the following note: This interface does not refine the general contracts of the equals and hashCode methods The result of comparing two objects that implement CharSequence is therefore in general undefined Each object may be implemented by a different class and there is no guarantee that each class will be capable of testing its instances for equality with those of the other When the signature of the StringUtils equals   method was changed from equals String String  to equals CharSequence CharSequence  in R920543 the implementation still relied on calling CharSequence equals Object  even though in general the result is undefined One example where equals Object  returns false even though as CharSequences two objects represent equal sequences is when one object is an instance of javax lang model element Name and the other object is a String ,Since the java lang CharSequence class was first introduced in   the JavaDoc block has contained the following note: This interface does not refine the general contracts of the equals and hashCode methods The result of comparing two objects that implement CharSequence is therefore in general undefined Each object may be implemented by a different class and there is no guarantee that each class will be capable of testing its instances for equality with those of the other When the signature of the StringUtils equals   method was changed from equals String String  to equals CharSequence CharSequence  in R the implementation still relied on calling CharSequence equals Object  even though in general the result is undefined One example where equals Object  returns false even though as CharSequences two objects represent equal sequences is when one object is an instance of javax lang model element Name and the other object is a String ,Since the java lang CharSequence class was first introduced in the JavaDoc block has contained the following note: This interface does not refine the general contracts of the equals and hashCode methods The result of comparing two objects that implement CharSequence is therefore in general undefined Each object may be implemented by a different class and there is no guarantee that each class will be capable of testing its instances for equality with those of the other When the signature of the StringUtils equals method was changed from equals String String to equals CharSequence CharSequence in R the implementation still relied on calling CharSequence equals Object even though in general the result is undefined One example where equals Object returns false even though as CharSequences two objects represent equal sequences is when one object is an instance of javax lang model element Name and the other object is a String ,1
0,Lang,org apache commons lang3 math Fraction does not reduce Integer MIN VALUE 2 k ,The greatestCommonDivisor method in class Fraction does not find the gcd of Integer MIN VALUE and 2 k and this case can be triggered by taking Integer MIN VALUE as the numerator Note that the case of taking Integer MIN VALUE as the denominator is handled explicitly in the getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int   { f = Fraction getReducedFraction Integer MIN VALUE 2 ; assertEquals Integer MIN VALUE 2 f getNumerator  ; assertEquals 1 f getDenominator  ; public void testReduce   { f = Fraction getFraction Integer MIN VALUE 2 ; result = f reduce  ; assertEquals Integer MIN VALUE 2 result getNumerator  ; assertEquals 1 result getDenominator  ;,The greatestCommonDivisor method in class Fraction does not find the gcd of Integer MIN VALUE and  k and this case can be triggered by taking Integer MIN VALUE as the numerator Note that the case of taking Integer MIN VALUE as the denominator is handled explicitly in the getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int   { f = Fraction getReducedFraction Integer MIN VALUE  ; assertEquals Integer MIN VALUE  f getNumerator  ; assertEquals  f getDenominator  ; public void testReduce   { f = Fraction getFraction Integer MIN VALUE  ; result = f reduce  ; assertEquals Integer MIN VALUE  result getNumerator  ; assertEquals  result getDenominator  ;,The greatestCommonDivisor method in class Fraction does not find the gcd of Integer MIN VALUE and k and this case can be triggered by taking Integer MIN VALUE as the numerator Note that the case of taking Integer MIN VALUE as the denominator is handled explicitly in the getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int { f = Fraction getReducedFraction Integer MIN VALUE ; assertEquals Integer MIN VALUE f getNumerator ; assertEquals f getDenominator ; public void testReduce { f = Fraction getFraction Integer MIN VALUE ; result = f reduce ; assertEquals Integer MIN VALUE result getNumerator ; assertEquals result getDenominator ;,1
0,Mockito,Mockito can t create mock on public class that extends package-private class,Even if it can t be implemented I think that mockito should throw some normal exception at time of creation In my variant on first creation it returns wrong-working mock invokes real method instead of stubbed  On second creation throws exception that doesn t really connected with problem Everything works fine if you mock package-private parent ,Even if it can t be implemented I think that mockito should throw some normal exception at time of creation In my variant on first creation it returns wrongworking mock invokes real method instead of stubbed  On second creation throws exception that doesn t really connected with problem Everything works fine if you mock packageprivate parent ,Even if it can t be implemented I think that mockito should throw some normal exception at time of creation In my variant on first creation it returns wrongworking mock invokes real method instead of stubbed On second creation throws exception that doesn t really connected with problem Everything works fine if you mock packageprivate parent ,1
0,Mockito,possible NPE exception when class cannot be mocked via PowerMockito,In version 1 10 5 the catch block needs to guard against a null proxyInstance ,In version    the catch block needs to guard against a null proxyInstance ,In version the catch block needs to guard against a null proxyInstance ,1
0,Mockito,Source files should not be put in binary JAR,Source files java  should not be put into binary mockito-core jar It stupefies Idea to show decompiled file even when source jar is available ,Source files java  should not be put into binary mockitocore jar It stupefies Idea to show decompiled file even when source jar is available ,Source files java should not be put into binary mockitocore jar It stupefies Idea to show decompiled file even when source jar is available ,1
0,Mockito,ArgumentCaptor fromClass s return type should match a parameterized type,ArgumentCaptor fromClass s return type should match a parameterized type I e the expression ArgumentCaptor fromClass Class<S>  should be of type ArgumentCaptor<U> where S is a subtype of U It should type check ,ArgumentCaptor fromClass s return type should match a parameterized type I e the expression ArgumentCaptor fromClass Class<S>  should be of type ArgumentCaptor<U> where S is a subtype of U It should type check ,ArgumentCaptor fromClass s return type should match a parameterized type I e the expression ArgumentCaptor fromClass Class<S> should be of type ArgumentCaptor<U> where S is a subtype of U It should type check ,1
0,Mockito,Allow convenient spying on abstract classes ,Mockito is easy to use when the test needs to provide canned values for a certain method But it gets harder when a canned value isn t sufficient ,Mockito is easy to use when the test needs to provide canned values for a certain method But it gets harder when a canned value isn t sufficient ,Mockito is easy to use when the test needs to provide canned values for a certain method But it gets harder when a canned value isn t sufficient ,1
0,Mockito,Return empty value for Iterables ,I expect an Iterable to be mocked by default with an empty Iterable I understand from the initial issue this behavior would be introduced in Mockito 2 but beta-8 still returns null Could we return null for Iterables ,I expect an Iterable to be mocked by default with an empty Iterable I understand from the initial issue this behavior would be introduced in Mockito  but beta still returns null Could we return null for Iterables ,I expect an Iterable to be mocked by default with an empty Iterable I understand from the initial issue this behavior would be introduced in Mockito but beta still returns null Could we return null for Iterables ,1
0,Mockito,Exception when stubbing more than once with when thenThrow,If I create a mock and stub a method so it throws an exception and do that twice the first exception will be thrown upon invoking the second stub instruction ,If I create a mock and stub a method so it throws an exception and do that twice the first exception will be thrown upon invoking the second stub instruction ,If I create a mock and stub a method so it throws an exception and do that twice the first exception will be thrown upon invoking the second stub instruction ,1
0,Mockito,Problem spying on abstract classes,There s a problem with spying on abstract classes when the real implementation calls out to the abstract method ,There s a problem with spying on abstract classes when the real implementation calls out to the abstract method ,There s a problem with spying on abstract classes when the real implementation calls out to the abstract method ,1
0,Mockito,Fixed DelegatingMethod equals   so that it s easier to extend Mockito by custom verification modes,Currently if you create a DelegatingMethod and compare it to itself using equals   it will show as not equal because the equals   method expects a java lang reflect Method without explicitly stating such  This has a knock on effect on the evaluation of InvocationImpl equals   which at runtime may be using a DelegatingMethod in its equals   ,Currently if you create a DelegatingMethod and compare it to itself using equals   it will show as not equal because the equals   method expects a java lang reflect Method without explicitly stating such  This has a knock on effect on the evaluation of InvocationImpl equals   which at runtime may be using a DelegatingMethod in its equals   ,Currently if you create a DelegatingMethod and compare it to itself using equals it will show as not equal because the equals method expects a java lang reflect Method without explicitly stating such This has a knock on effect on the evaluation of InvocationImpl equals which at runtime may be using a DelegatingMethod in its equals ,1
0,Mockito,Deep stubbing with generic responses in the call chain is not working,Deep stubbing will throw an Exception if multiple generics occur in the call chain For instance consider having a mock myMock1 that provides a function that returns a generic T If T also has a function that returns a generic an Exception with the message Raw extraction not supported for : null will be thrown I think the issue is that further generics are not possible to be mocked by ReturnsDeepStubsSerializationFallback since the GenericMetadataSupport is closed at this point ,Deep stubbing will throw an Exception if multiple generics occur in the call chain For instance consider having a mock myMock that provides a function that returns a generic T If T also has a function that returns a generic an Exception with the message Raw extraction not supported for : null will be thrown I think the issue is that further generics are not possible to be mocked by ReturnsDeepStubsSerializationFallback since the GenericMetadataSupport is closed at this point ,Deep stubbing will throw an Exception if multiple generics occur in the call chain For instance consider having a mock myMock that provides a function that returns a generic T If T also has a function that returns a generic an Exception with the message Raw extraction not supported for : null will be thrown I think the issue is that further generics are not possible to be mocked by ReturnsDeepStubsSerializationFallback since the GenericMetadataSupport is closed at this point ,1
0,Mockito,fixed a verify   call example in  Captor javadoc ,None,None,None,1
0,Mockito,Make org mockito asm signature package optional in Import-Packages ,None,None,None,1
0,Mockito,Argument matcher anyXxx   i e anyString   anyList   should not match nulls,Note that the function is called with an integer not a string  and still the mocked function return the value which it should return only when a string is passed The same works when using anyBoolean   or any other methof from any family ,Note that the function is called with an integer not a string  and still the mocked function return the value which it should return only when a string is passed The same works when using anyBoolean   or any other methof from any family ,Note that the function is called with an integer not a string and still the mocked function return the value which it should return only when a string is passed The same works when using anyBoolean or any other methof from any family ,1
0,Mockito,nicer textual printing of typed parameters,When matchers fail but yield the same toString   Mockito prints extra type information However the type information is awkwardly printed for Strings I ve encountered this issue while working on removing hard dependency to hamcrest ,When matchers fail but yield the same toString   Mockito prints extra type information However the type information is awkwardly printed for Strings I ve encountered this issue while working on removing hard dependency to hamcrest ,When matchers fail but yield the same toString Mockito prints extra type information However the type information is awkwardly printed for Strings I ve encountered this issue while working on removing hard dependency to hamcrest ,1
0,Mockito,Mockito 1 10 x timeout verification needs JUnit classes VerifyError NoClassDefFoundError  ,If JUnit is not on the classpath and mockito is version 1 10 x as of now 1 10 1 up to 1 10 19  and the code is using the timeout verification which is not supposed to be related to JUnit then the JVM may fail with a VerifyError or a NoClassDefFoundError ,If JUnit is not on the classpath and mockito is version   x as of now    up to     and the code is using the timeout verification which is not supposed to be related to JUnit then the JVM may fail with a VerifyError or a NoClassDefFoundError ,If JUnit is not on the classpath and mockito is version x as of now up to and the code is using the timeout verification which is not supposed to be related to JUnit then the JVM may fail with a VerifyError or a NoClassDefFoundError ,1
0,Mockito,ArgumentCaptor no longer working for varargs,When upgrading 1 10 8 the verify passes but the getValue   fails with this error One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables That is remove var1 from target and test code then the test runs fine under 1 9 5 and 1 10 8 Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,When upgrading    the verify passes but the getValue   fails with this error One other piece of info came to light as a result of creating the MCVE  the test works fine if the Date is the only element passed for bindVariables That is remove var from target and test code then the test runs fine under    and    Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,When upgrading the verify passes but the getValue fails with this error One other piece of info came to light as a result of creating the MCVE the test works fine if the Date is the only element passed for bindVariables That is remove var from target and test code then the test runs fine under and Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,1
0,Mockito,RETURNS DEEP STUBS automatically tries to create serializable mocks,You are using the setting withSettings   serializable   however the type you are trying to mock NotSerializableReturnValue do not implement Serializable AND do not have a no-arg constructor ,You are using the setting withSettings   serializable   however the type you are trying to mock NotSerializableReturnValue do not implement Serializable AND do not have a noarg constructor ,You are using the setting withSettings serializable however the type you are trying to mock NotSerializableReturnValue do not implement Serializable AND do not have a noarg constructor ,1
0,Mockito,InjectMocks injects mock into wrong field ,When using  InjectMocks on some Android TextViews the mock is injected into the wrong field We have two fields txtGateView   txtNextStep in a class and our test mocks out txtNextStep then tried to inject This field is injected wrong From our quick testing the name txtNextView doesn t matter that can be changed But both txtGateView and txtGateLabel messed things up If we mock out both fields it works correctly ,When using  InjectMocks on some Android TextViews the mock is injected into the wrong field We have two fields txtGateView   txtNextStep in a class and our test mocks out txtNextStep then tried to inject This field is injected wrong From our quick testing the name txtNextView doesn t matter that can be changed But both txtGateView and txtGateLabel messed things up If we mock out both fields it works correctly ,When using InjectMocks on some Android TextViews the mock is injected into the wrong field We have two fields txtGateView txtNextStep in a class and our test mocks out txtNextStep then tried to inject This field is injected wrong From our quick testing the name txtNextView doesn t matter that can be changed But both txtGateView and txtGateLabel messed things up If we mock out both fields it works correctly ,1
0,Mockito,use  InjectMocks for final fields ,I m trying to upgrade the mockito version that we re using 1 8 5  to a newer version but there is a problem with  InjectMocks which since 1 9 0 doesn t inject into final field anymore ,I m trying to upgrade the mockito version that we re using     to a newer version but there is a problem with  InjectMocks which since    doesn t inject into final field anymore ,I m trying to upgrade the mockito version that we re using to a newer version but there is a problem with InjectMocks which since doesn t inject into final field anymore ,1
0,Mockito,1 10 regression StackOverflowError  with interface where generic type has itself as upper bound ,None,None,None,1
0,Mockito,Allow convenient spying on abstract classes ,Mockito is easy to use when the test needs to provide canned values for a certain method But it gets harder when a canned value isn t sufficient ,Mockito is easy to use when the test needs to provide canned values for a certain method But it gets harder when a canned value isn t sufficient ,Mockito is easy to use when the test needs to provide canned values for a certain method But it gets harder when a canned value isn t sufficient ,1
0,Mockito,Generate change list separated by types using labels,As discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels It is required to specify which labels should be considered separately Some other labels can be excluded like question or refactoring   There is also headerForOtherChanges method to override default Other header ,As discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels It is required to specify which labels should be considered separately Some other labels can be excluded like question or refactoring   There is also headerForOtherChanges method to override default Other header ,As discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels It is required to specify which labels should be considered separately Some other labels can be excluded like question or refactoring There is also headerForOtherChanges method to override default Other header ,1
0,Mockito,Make Mockito JUnit rule easier to use,Mockito JUnit rule easier to use by avoiding the need to pass test instance Make it compatible with JUnit 4 7 instead of 4 9 ,Mockito JUnit rule easier to use by avoiding the need to pass test instance Make it compatible with JUnit   instead of   ,Mockito JUnit rule easier to use by avoiding the need to pass test instance Make it compatible with JUnit instead of ,1
0,Mockito,Failing tests on Windows machine,None,None,None,1
0,Mockito,Failing tests on Windows machine,None,None,None,1
0,Mockito,Make Mockito JUnit rule easier to use,Mockito JUnit rule easier to use by avoiding the need to pass test instance Make it compatible with JUnit 4 7 instead of 4 9 ,Mockito JUnit rule easier to use by avoiding the need to pass test instance Make it compatible with JUnit   instead of   ,Mockito JUnit rule easier to use by avoiding the need to pass test instance Make it compatible with JUnit instead of ,1
0,Mockito,fix some rawtype warnings in tests ,None,None,None,1
0,Mockito,WrongTypeOfReturnValue when abstract class have two abstract method ,This is strange behavior because the method lol   should not be called but when I delete one abstract method everything is good ,This is strange behavior because the method lol   should not be called but when I delete one abstract method everything is good ,This is strange behavior because the method lol should not be called but when I delete one abstract method everything is good ,1
0,Mockito,java lang ClassCastException: java lang Class cannot be cast to java lang String,Exception throws on verifyZeroInteractions when using mock with default answer ,Exception throws on verifyZeroInteractions when using mock with default answer ,Exception throws on verifyZeroInteractions when using mock with default answer ,1
0,Mockito,ArgumentCaptor no longer working for varargs,When upgrading 1 10 8 the verify passes but the getValue   fails with this error One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables That is remove var1 from target and test code then the test runs fine under 1 9 5 and 1 10 8 Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,When upgrading    the verify passes but the getValue   fails with this error One other piece of info came to light as a result of creating the MCVE  the test works fine if the Date is the only element passed for bindVariables That is remove var from target and test code then the test runs fine under    and    Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,When upgrading the verify passes but the getValue fails with this error One other piece of info came to light as a result of creating the MCVE the test works fine if the Date is the only element passed for bindVariables That is remove var from target and test code then the test runs fine under and Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,1
0,Mockito,ArgumentCaptor no longer working for varargs,When upgrading 1 10 8 the verify passes but the getValue   fails with this error One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables That is remove var1 from target and test code then the test runs fine under 1 9 5 and 1 10 8 Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,When upgrading    the verify passes but the getValue   fails with this error One other piece of info came to light as a result of creating the MCVE  the test works fine if the Date is the only element passed for bindVariables That is remove var from target and test code then the test runs fine under    and    Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,When upgrading the verify passes but the getValue fails with this error One other piece of info came to light as a result of creating the MCVE the test works fine if the Date is the only element passed for bindVariables That is remove var from target and test code then the test runs fine under and Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,1
0,Mockito,ArgumentCaptor no longer working for varargs,When upgrading 1 10 8 the verify passes but the getValue   fails with this error One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables That is remove var1 from target and test code then the test runs fine under 1 9 5 and 1 10 8 Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,When upgrading    the verify passes but the getValue   fails with this error One other piece of info came to light as a result of creating the MCVE  the test works fine if the Date is the only element passed for bindVariables That is remove var from target and test code then the test runs fine under    and    Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,When upgrading the verify passes but the getValue fails with this error One other piece of info came to light as a result of creating the MCVE the test works fine if the Date is the only element passed for bindVariables That is remove var from target and test code then the test runs fine under and Also it doesn t matter that the captor is for a Date The same issue occurs if the parameter is of another type such as Integer ,1
0,Mockito,Mockito after   method accepts negative timeperiods and subsequent verifications always pass,None,None,None,1
0,Mockito,fix proposal for  114,None,None,None,1
0,Mockito,Mockito 1 10 x timeout verification needs JUnit classes VerifyError NoClassDefFoundError ,If JUnit is not on the classpath and mockito is version 1 10 x as of now 1 10 1 up to 1 10 19  and the code is using the timeout verification which is not supposed to be related to JUnit then the JVM may fail with a VerifyError or a NoClassDefFoundError ,If JUnit is not on the classpath and mockito is version   x as of now    up to     and the code is using the timeout verification which is not supposed to be related to JUnit then the JVM may fail with a VerifyError or a NoClassDefFoundError ,If JUnit is not on the classpath and mockito is version x as of now up to and the code is using the timeout verification which is not supposed to be related to JUnit then the JVM may fail with a VerifyError or a NoClassDefFoundError ,1
0,Mockito,fix proposal for  114,None,None,None,1
0,Mockito,Can not Return deep stubs from generic method that returns generic type ,if I try to mock a generic method which a generic returntype where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it When you don t use deep stubs and a raw Supplier mock to pass around it works:,if I try to mock a generic method which a generic returntype where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it When you don t use deep stubs and a raw Supplier mock to pass around it works:,if I try to mock a generic method which a generic returntype where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it When you don t use deep stubs and a raw Supplier mock to pass around it works:,1
0,Mockito,Null Pointer when invoking Whitebox invokeMethod   with null one of the params null ,None,None,None,1
0,Closure,Break in finally block isn t optimized properly,None,None,None,1
0,Chart,Error on TimeSeries createCopy   method,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart 1 0 7,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart   ,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart ,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze   gives bad results with commons-math3-3 0 in a simple test problem It works well in commons-math-2 2 ,Methode SimplexSolver optimeze   gives bad results with commonsmath  in a simple test problem It works well in commonsmath  ,Methode SimplexSolver optimeze gives bad results with commonsmath in a simple test problem It works well in commonsmath ,1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Time,possibly a bug in org joda time field FieldUtils safeMultiply,It seems to me that as currently written in joda-time-2 1 jar org joda time field FieldUtils safeMultiply long val1 int scalar  doesn t detect the overflow if the long val1 == Long MIN VALUE and the int scalar == -1 The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,It seems to me that as currently written in jodatime  jar org joda time field FieldUtils safeMultiply long val int scalar  doesn t detect the overflow if the long val == Long MIN VALUE and the int scalar ==  The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,It seems to me that as currently written in jodatime jar org joda time field FieldUtils safeMultiply long val int scalar doesn t detect the overflow if the long val == Long MIN VALUE and the int scalar == The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,1
0,Lang,NullPointerException in isAvailableLocale Locale ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source  and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source and if availableLocaleSet hasn t been called it will cause a NullPointerException ,1
0,Lang,ClassUtils toClass Object[]  throws NPE on null array element,see summary,see summary,see summary,1
0,Lang,FastDateFormat format   outputs incorrect week of year because locale isn t respected,FastDateFormat apparently doesn t respect the locale it was sent on creation when outputting week in year e g ww   in format   It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which depending on the year  may result in the incorrect week number being output Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right: import java util Calendar; import java util Date; import java util Locale; import java text SimpleDateFormat; import org apache commons lang time FastDateFormat; public class FastDateFormatWeekBugDemo { public static void main String[] args  { Locale setDefault new Locale en US  ; Locale locale = new Locale sv SE  ; Calendar cal = Calendar getInstance  ; setting locale here doesn t change outcome cal set 2010 0 1 12 0 0 ; Date d = cal getTime  ; System out println Target date: d ; FastDateFormat fdf = FastDateFormat getInstance EEEE week ww locale ; SimpleDateFormat sdf = new SimpleDateFormat EEEE week ww locale ; System out println FastDateFormat: fdf format d ; will output FastDateFormat: fredag week 01 System out println SimpleDateFormat: sdf format d ; will output SimpleDateFormat: fredag week 53 } } If sv SE is passed to Locale setDefault   instead of en US both FastDateFormat and SimpleDateFormat output the correct week number ,FastDateFormat apparently doesn t respect the locale it was sent on creation when outputting week in year e g ww   in format   It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which depending on the year  may result in the incorrect week number being output Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right: import java util Calendar; import java util Date; import java util Locale; import java text SimpleDateFormat; import org apache commons lang time FastDateFormat; public class FastDateFormatWeekBugDemo { public static void main String[] args  { Locale setDefault new Locale en US  ; Locale locale = new Locale sv SE  ; Calendar cal = Calendar getInstance  ; setting locale here doesn t change outcome cal set       ; Date d = cal getTime  ; System out println Target date: d ; FastDateFormat fdf = FastDateFormat getInstance EEEE week ww locale ; SimpleDateFormat sdf = new SimpleDateFormat EEEE week ww locale ; System out println FastDateFormat: fdf format d ; will output FastDateFormat: fredag week  System out println SimpleDateFormat: sdf format d ; will output SimpleDateFormat: fredag week  } } If sv SE is passed to Locale setDefault   instead of en US both FastDateFormat and SimpleDateFormat output the correct week number ,FastDateFormat apparently doesn t respect the locale it was sent on creation when outputting week in year e g ww in format It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which depending on the year may result in the incorrect week number being output Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right: import java util Calendar; import java util Date; import java util Locale; import java text SimpleDateFormat; import org apache commons lang time FastDateFormat; public class FastDateFormatWeekBugDemo { public static void main String[] args { Locale setDefault new Locale en US ; Locale locale = new Locale sv SE ; Calendar cal = Calendar getInstance ; setting locale here doesn t change outcome cal set ; Date d = cal getTime ; System out println Target date: d ; FastDateFormat fdf = FastDateFormat getInstance EEEE week ww locale ; SimpleDateFormat sdf = new SimpleDateFormat EEEE week ww locale ; System out println FastDateFormat: fdf format d ; will output FastDateFormat: fredag week System out println SimpleDateFormat: sdf format d ; will output SimpleDateFormat: fredag week } } If sv SE is passed to Locale setDefault instead of en US both FastDateFormat and SimpleDateFormat output the correct week number ,1
0,Lang,ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes,When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur Example that will cause error: ExtendedMessageFormatTest java private static Map<String Object> formatRegistry = new HashMap<String Object>  ; static { formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory  ; } public static void main String[] args  { ExtendedMessageFormat mf = new ExtendedMessageFormat it s a {dummy} test formatRegistry ; String formattedPattern = mf format new String[] { great } ; System out println formattedPattern ; } } The following change starting at line 421 on the 2 4 release seems to fix the problem: ExtendedMessageFormat java CURRENT Broken : if escapingOn   c[start] == QUOTE  { return appendTo == null null : appendTo append QUOTE ; } WORKING: if escapingOn   c[start] == QUOTE  { next pos ; return appendTo == null null : appendTo append QUOTE ; },When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur Example that will cause error: ExtendedMessageFormatTest java private static Map<String Object> formatRegistry = new HashMap<String Object>  ; static { formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory  ; } public static void main String[] args  { ExtendedMessageFormat mf = new ExtendedMessageFormat it s a {dummy} test formatRegistry ; String formattedPattern = mf format new String[] { great } ; System out println formattedPattern ; } } The following change starting at line  on the   release seems to fix the problem: ExtendedMessageFormat java CURRENT Broken : if escapingOn   c[start] == QUOTE  { return appendTo == null null : appendTo append QUOTE ; } WORKING: if escapingOn   c[start] == QUOTE  { next pos ; return appendTo == null null : appendTo append QUOTE ; },When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur Example that will cause error: ExtendedMessageFormatTest java private static Map<String Object> formatRegistry = new HashMap<String Object> ; static { formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory ; } public static void main String[] args { ExtendedMessageFormat mf = new ExtendedMessageFormat it s a {dummy} test formatRegistry ; String formattedPattern = mf format new String[] { great } ; System out println formattedPattern ; } } The following change starting at line on the release seems to fix the problem: ExtendedMessageFormat java CURRENT Broken : if escapingOn c[start] == QUOTE { return appendTo == null null : appendTo append QUOTE ; } WORKING: if escapingOn c[start] == QUOTE { next pos ; return appendTo == null null : appendTo append QUOTE ; },1
0,Lang,DateFormatUtils format does not correctly change Calendar TimeZone in certain situations,If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; more commonly constructed with: cal = new GregorianCalendar 2009 9 16 8 42 16  for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar        for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; cal getTime ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; },1
0,Lang,NumberUtils isNumber String  is not right when the String is 1 1L , 1 1L is not a Java Number but NumberUtils isNumber String  return true perhaps change: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp; } to: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp   hasDecPoint; },  L is not a Java Number but NumberUtils isNumber String  return true perhaps change: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp; } to: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp   hasDecPoint; }, L is not a Java Number but NumberUtils isNumber String return true perhaps change: if chars[i] == l || chars[i] == L { not allowing L with an exponent return foundDigit hasExp; } to: if chars[i] == l || chars[i] == L { not allowing L with an exponent return foundDigit hasExp hasDecPoint; },1
0,Closure,bug with implicit namespaces across modules,None,None,None,1
0,Closure,bug with implicit namespaces across modules,None,None,None,1
0,Closure,Dependency sorting with closurePass set to false no longer works ,None,None,None,1
0,Closure,Record type invalid property not reported on function with  this annotation,None,None,None,1
0,Closure,Codepoint U 007f appears raw in output,None,None,None,1
0,Closure,Wrong code generated if mixing types in ternary operator,None,None,None,1
0,Closure,side-effects analysis incorrectly removing function calls with side effects,None,None,None,1
0,Closure,Break in finally block isn t optimized properly,None,None,None,1
0,Closure,Add support for --manage closure dependencies and --only closure dependencies with compilation level WHITESPACE ONLY,None,None,None,1
0,Closure,Column-indicating caret is sometimes not in error output,None,None,None,1
0,Closure,ClassCastException during TypeCheck pass,None,None,None,1
0,Closure,unexpected typed coverage of less than 100 ,None,None,None,1
0,Closure,bogus missing return warning,None,None,None,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2 ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path1 GeneralPath path2  will thus return true for any pair of non-null GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path  will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,1
0,Chart,Potential NPE in AbstractCategoryItemRender getLegendItems  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null not if dataset = null ,1
0,Chart,Fix for MultiplePiePlot,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,1
0,Math,FastMath max 50 0f -50 0f  => -50 0f; should be 50 0f,FastMath max 50 0f -50 0f  => -50 0f; should be 50 0f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat   because that has a bug too - it tests doubles not floats ,FastMath max  f  f  =>  f; should be  f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat   because that has a bug too  it tests doubles not floats ,FastMath max f f => f; should be f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat because that has a bug too it tests doubles not floats ,1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Math,GaussianFitter Unexpectedly Throws NotStrictlyPositiveException,Running the following: double[] observations = { 1 1143831578403364E-29 4 95281403484594E-28 1 1171347211930288E-26 1 7044813962636277E-25 1 9784716574832164E-24 1 8630236407866774E-23 1 4820532905097742E-22 1 0241963854632831E-21 6 275077366673128E-21 3 461808994532493E-20 1 7407124684715706E-19 8 056687953553974E-19 3 460193945992071E-18 1 3883326374011525E-17 5 233894983671116E-17 1 8630791465263745E-16 6 288759227922111E-16 2 0204433920597856E-15 6 198768938576155E-15 1 821419346860626E-14 5 139176445538471E-14 1 3956427429045787E-13 3 655705706448139E-13 9 253753324779779E-13 2 267636001476696E-12 5 3880460095836855E-12 1 2431632654852931E-11 } ; GaussianFitter g = new GaussianFitter new LevenbergMarquardtOptimizer  ; for int index = 0; index < 27; index   { g addObservedPoint index observations[index] ; } g fit  ; Results in: org apache commons math exception NotStrictlyPositiveException: -1 277 is smaller than or equal to the minimum 0  at org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java:184  at org apache commons math analysis function Gaussian Parametric value Gaussian java:129  I m guessing the initial guess for sigma is off ,Running the following: double[] observations = {  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E } ; GaussianFitter g = new GaussianFitter new LevenbergMarquardtOptimizer  ; for int index = ; index < ; index   { g addObservedPoint index observations[index] ; } g fit  ; Results in: org apache commons math exception NotStrictlyPositiveException:   is smaller than or equal to the minimum   at org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java:  at org apache commons math analysis function Gaussian Parametric value Gaussian java:  I m guessing the initial guess for sigma is off ,Running the following: double[] observations = { E E E E E E E E E E E E E E E E E E E E E E E E E E E } ; GaussianFitter g = new GaussianFitter new LevenbergMarquardtOptimizer ; for int index = ; index < ; index { g addObservedPoint index observations[index] ; } g fit ; Results in: org apache commons math exception NotStrictlyPositiveException: is smaller than or equal to the minimum at org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java: at org apache commons math analysis function Gaussian Parametric value Gaussian java: I m guessing the initial guess for sigma is off ,1
0,Math,ListPopulation Iterator allows you to remove chromosomes from the population ,Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list Before returning the iterator we should wrap it in an unmodifiable list ,Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list Before returning the iterator we should wrap it in an unmodifiable list ,Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list Before returning the iterator we should wrap it in an unmodifiable list ,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze   gives bad results with commons-math3-3 0 in a simple test problem It works well in commons-math-2 2 ,Methode SimplexSolver optimeze   gives bad results with commonsmath  in a simple test problem It works well in commonsmath  ,Methode SimplexSolver optimeze gives bad results with commonsmath in a simple test problem It works well in commonsmath ,1
0,Math,In stat Frequency getPct Object  uses getCumPct Comparable  instead of getPct Comparable ,Drop in Replacement of 1 2 with 2 0 not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v  deprecated replaced by { link  getPct Comparable } as of 2 0  Deprecated public double getPct Object v  { return getCumPct Comparable< >  v ; },Drop in Replacement of   with   not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v  deprecated replaced by { link  getPct Comparable } as of    Deprecated public double getPct Object v  { return getCumPct Comparable< >  v ; },Drop in Replacement of with not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v deprecated replaced by { link getPct Comparable } as of Deprecated public double getPct Object v { return getCumPct Comparable< > v ; },1
0,Math,BisectionSolver solve final UnivariateRealFunction f double min double max double initial  throws NullPointerException,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial  invokes BisectionSolver solve double min double max  which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max  should be called Steps to reproduce: invoke: new BisectionSolver   solve someUnivariateFunctionImpl 0 0 1 0 0 5 ; NullPointerException will be thrown ,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial  invokes BisectionSolver solve double min double max  which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max  should be called Steps to reproduce: invoke: new BisectionSolver   solve someUnivariateFunctionImpl       ; NullPointerException will be thrown ,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max should be called Steps to reproduce: invoke: new BisectionSolver solve someUnivariateFunctionImpl ; NullPointerException will be thrown ,1
0,Math,bug in inverseCumulativeProbability   for Normal Distribution, version Revision: 617953 Date: 2008-02-02 22:54:00 -0700 Sat 02 Feb 2008  public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision: 506600 Date: 2007-02-12 12:35:59 -0700 Mon 12 Feb 2007  public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution 0 1 ; double result = normal inverseCumulativeProbability 0 9772498680518209 ; gives the exception below It should return approx  2 0000 normal inverseCumulativeProbability 0 977249868051820 ; works fine These also give errors: 0 9986501019683698 should return 3 0000   0 9999683287581673 should return 4 0000   org apache commons math MathException: Number of iterations=1 maximum iterations=2 147 483 647 initial=1 lower bound=0 upper bound=179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final a value=0 final b value=2 f a =-0 477 f b =0 at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:103  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java:145 , version Revision:  Date:  ::  Sat  Feb   public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision:  Date:  ::  Mon  Feb   public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution   ; double result = normal inverseCumulativeProbability   ; gives the exception below It should return approx    normal inverseCumulativeProbability   ; works fine These also give errors:   should return       should return     org apache commons math MathException: Number of iterations= maximum iterations=    initial= lower bound= upper bound=                                                                                                       final a value= final b value= f a =  f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: , version Revision: Date: :: Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision: Date: :: Mon Feb public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory ; NormalDistribution normal = factory createNormalDistribution ; double result = normal inverseCumulativeProbability ; gives the exception below It should return approx normal inverseCumulativeProbability ; works fine These also give errors: should return should return org apache commons math MathException: Number of iterations= maximum iterations= initial= lower bound= upper bound= final a value= final b value= f a = f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java: at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: ,1
0,Math,SimplexSolver not working as expected 2,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: 7 a 3 b; Constraints R1: 3 a -5 c <= 0; R2: 2 a -5 d <= 0; R3: 2 b -5 c <= 0; R4: 3 b -5 d <= 0; R5: 3 a 2 b <= 5; R6: 2 a 3 b <= 5; Variable bounds a <= 1; b <= 1; ===================== Results correct : a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {7 3 0 0} 0 ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {1 0 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {0 1 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {3 0 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {2 0 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 2 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 3 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {3 2 0 0} Relationship LEQ 5 ; podmienky add new LinearConstraint new double[] {2 3 0 0} Relationship LEQ 5 ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = 1 b = 0 5 value = 8 5 P S I used the latest software from the repository including MATH-286 fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max:  a  b; Constraints R:  a  c <= ; R:  a  d <= ; R:  b  c <= ; R:  b  d <= ; R:  a  b <= ; R:  a  b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a =  b =  value =  Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {   }  ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a =  b =   value =   P S I used the latest software from the repository including MATH fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: a b; Constraints R: a c <= ; R: a d <= ; R: b c <= ; R: b d <= ; R: a b <= ; R: a b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a = b = value = Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] { } ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint> ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; SimplexSolver solver = new SimplexSolver ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = b = value = P S I used the latest software from the repository including MATH fix ,1
0,Math,Complex ZERO reciprocal   returns NaN but should return INF ,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math3 complex Complex; Method: reciprocal    version Id: Complex java 1416643 2012-12-03 19:37:14Z tn,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal    version Id: Complex java   ::Z tn,Complex ZERO reciprocal returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal version Id: Complex java ::Z tn,1
0,Time,NPE in DateTimeZoneBuilder,When a DateTimeZone is build with duplicate-named recurring saving time in a first thread all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone create   When a second thread does the same an NPE is generated in ZoneInfoCompiler verbose   The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler will initialize cVerbose only for the first thread and not for the subsequent ones The NPE is caused by the autoboxing in: A better approach could be to remove the initialization and test for null:,When a DateTimeZone is build with duplicatenamed recurring saving time in a first thread all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone create   When a second thread does the same an NPE is generated in ZoneInfoCompiler verbose   The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler will initialize cVerbose only for the first thread and not for the subsequent ones The NPE is caused by the autoboxing in: A better approach could be to remove the initialization and test for null:,When a DateTimeZone is build with duplicatenamed recurring saving time in a first thread all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone create When a second thread does the same an NPE is generated in ZoneInfoCompiler verbose The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler will initialize cVerbose only for the first thread and not for the subsequent ones The NPE is caused by the autoboxing in: A better approach could be to remove the initialization and test for null:,1
0,Time,Inconsistent interpretation of ambiguous time during DST,The inconsistency appears for timezone Europe London These three DateTime objects should all represent the same moment in time even if they are ambiguous Now it always returns the earlier instant summer time  during an overlap ,The inconsistency appears for timezone Europe London These three DateTime objects should all represent the same moment in time even if they are ambiguous Now it always returns the earlier instant summer time  during an overlap ,The inconsistency appears for timezone Europe London These three DateTime objects should all represent the same moment in time even if they are ambiguous Now it always returns the earlier instant summer time during an overlap ,1
0,Time,Constructing invalid Partials,Partials can be constructed by invoking a constructor Partial DateTimeFieldType[] int[]  or by merging together a set of partials using with each constructed by calling Partial DateTimeFieldType int  However the above doesn t work in all cases: I suppose the Partials should not allow to be constructed in either case Is that right There s also a related issue probably stems from the fact that the Partial is invalid :,Partials can be constructed by invoking a constructor Partial DateTimeFieldType[] int[]  or by merging together a set of partials using with each constructed by calling Partial DateTimeFieldType int  However the above doesn t work in all cases: I suppose the Partials should not allow to be constructed in either case Is that right There s also a related issue probably stems from the fact that the Partial is invalid :,Partials can be constructed by invoking a constructor Partial DateTimeFieldType[] int[] or by merging together a set of partials using with each constructed by calling Partial DateTimeFieldType int However the above doesn t work in all cases: I suppose the Partials should not allow to be constructed in either case Is that right There s also a related issue probably stems from the fact that the Partial is invalid :,1
0,Lang,Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException,There s a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight Object obj int width char padChar  { if width > 0  { ensureCapacity size width ; String str = obj == null getNullText   : obj toString  ; int strLen = str length  ; if strLen >= width  { ==> str getChars 0 strLen buffer size ; <==== BUG: it should be str getChars 0 width buffer size ; } else { int padLen = width - strLen; str getChars 0 strLen buffer size ; for int i = 0; i < padLen; i   { buffer[size strLen i] = padChar; } } size = width; } return this; } This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width It s counterpart method appendFixedWidthPadLeft seems to be ok ,There s a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight Object obj int width char padChar  { if width >   { ensureCapacity size width ; String str = obj == null getNullText   : obj toString  ; int strLen = str length  ; if strLen >= width  { ==> str getChars  strLen buffer size ; <==== BUG: it should be str getChars  width buffer size ; } else { int padLen = width  strLen; str getChars  strLen buffer size ; for int i = ; i < padLen; i   { buffer[size strLen i] = padChar; } } size = width; } return this; } This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width It s counterpart method appendFixedWidthPadLeft seems to be ok ,There s a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight Object obj int width char padChar { if width > { ensureCapacity size width ; String str = obj == null getNullText : obj toString ; int strLen = str length ; if strLen >= width { ==> str getChars strLen buffer size ; <==== BUG: it should be str getChars width buffer size ; } else { int padLen = width strLen; str getChars strLen buffer size ; for int i = ; i < padLen; i { buffer[size strLen i] = padChar; } } size = width; } return this; } This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width It s counterpart method appendFixedWidthPadLeft seems to be ok ,1
0,Lang,NullPointerException in isAvailableLocale Locale ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source  and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source and if availableLocaleSet hasn t been called it will cause a NullPointerException ,1
0,Lang,StringIndexOutOfBoundsException in CharSequenceTranslator,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uD83D\uDE30 is a surrogate pair  Test public void testEscapeSurrogatePairs   throws Exception { assertEquals \uD83D\uDE30 StringEscapeUtils escapeCsv \uD83D\uDE30  ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range: 2 at java lang String charAt String java:658  at java lang Character codePointAt Character java:4668  at org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java:95  at org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java:59  at org apache commons lang3 StringEscapeUtils escapeCsv StringEscapeUtils java:556  Patch attached the method affected: public final void translate CharSequence input Writer out  throws IOException,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uDD\uDE is a surrogate pair  Test public void testEscapeSurrogatePairs   throws Exception { assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE  ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range:  at java lang String charAt String java:  at java lang Character codePointAt Character java:  at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java:  at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java:  at org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java:  Patch attached the method affected: public final void translate CharSequence input Writer out  throws IOException,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uDD\uDE is a surrogate pair Test public void testEscapeSurrogatePairs throws Exception { assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range: at java lang String charAt String java: at java lang Character codePointAt Character java: at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java: at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java: at org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java: Patch attached the method affected: public final void translate CharSequence input Writer out throws IOException,1
0,Lang,FastDateParser does not handle white-space properly,The SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,1
0,Lang,FastDateFormat format   outputs incorrect week of year because locale isn t respected,FastDateFormat apparently doesn t respect the locale it was sent on creation when outputting week in year e g ww   in format   It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which depending on the year  may result in the incorrect week number being output Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right: import java util Calendar; import java util Date; import java util Locale; import java text SimpleDateFormat; import org apache commons lang time FastDateFormat; public class FastDateFormatWeekBugDemo { public static void main String[] args  { Locale setDefault new Locale en US  ; Locale locale = new Locale sv SE  ; Calendar cal = Calendar getInstance  ; setting locale here doesn t change outcome cal set 2010 0 1 12 0 0 ; Date d = cal getTime  ; System out println Target date: d ; FastDateFormat fdf = FastDateFormat getInstance EEEE week ww locale ; SimpleDateFormat sdf = new SimpleDateFormat EEEE week ww locale ; System out println FastDateFormat: fdf format d ; will output FastDateFormat: fredag week 01 System out println SimpleDateFormat: sdf format d ; will output SimpleDateFormat: fredag week 53 } } If sv SE is passed to Locale setDefault   instead of en US both FastDateFormat and SimpleDateFormat output the correct week number ,FastDateFormat apparently doesn t respect the locale it was sent on creation when outputting week in year e g ww   in format   It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which depending on the year  may result in the incorrect week number being output Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right: import java util Calendar; import java util Date; import java util Locale; import java text SimpleDateFormat; import org apache commons lang time FastDateFormat; public class FastDateFormatWeekBugDemo { public static void main String[] args  { Locale setDefault new Locale en US  ; Locale locale = new Locale sv SE  ; Calendar cal = Calendar getInstance  ; setting locale here doesn t change outcome cal set       ; Date d = cal getTime  ; System out println Target date: d ; FastDateFormat fdf = FastDateFormat getInstance EEEE week ww locale ; SimpleDateFormat sdf = new SimpleDateFormat EEEE week ww locale ; System out println FastDateFormat: fdf format d ; will output FastDateFormat: fredag week  System out println SimpleDateFormat: sdf format d ; will output SimpleDateFormat: fredag week  } } If sv SE is passed to Locale setDefault   instead of en US both FastDateFormat and SimpleDateFormat output the correct week number ,FastDateFormat apparently doesn t respect the locale it was sent on creation when outputting week in year e g ww in format It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which depending on the year may result in the incorrect week number being output Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right: import java util Calendar; import java util Date; import java util Locale; import java text SimpleDateFormat; import org apache commons lang time FastDateFormat; public class FastDateFormatWeekBugDemo { public static void main String[] args { Locale setDefault new Locale en US ; Locale locale = new Locale sv SE ; Calendar cal = Calendar getInstance ; setting locale here doesn t change outcome cal set ; Date d = cal getTime ; System out println Target date: d ; FastDateFormat fdf = FastDateFormat getInstance EEEE week ww locale ; SimpleDateFormat sdf = new SimpleDateFormat EEEE week ww locale ; System out println FastDateFormat: fdf format d ; will output FastDateFormat: fredag week System out println SimpleDateFormat: sdf format d ; will output SimpleDateFormat: fredag week } } If sv SE is passed to Locale setDefault instead of en US both FastDateFormat and SimpleDateFormat output the correct week number ,1
0,Mockito,fixed a verify   call example in  Captor javadoc ,None,None,None,1
0,Mockito,Generate change list separated by types using labels,As discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels It is required to specify which labels should be considered separately Some other labels can be excluded like question or refactoring   There is also headerForOtherChanges method to override default Other header ,As discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels It is required to specify which labels should be considered separately Some other labels can be excluded like question or refactoring   There is also headerForOtherChanges method to override default Other header ,As discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels It is required to specify which labels should be considered separately Some other labels can be excluded like question or refactoring There is also headerForOtherChanges method to override default Other header ,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2 ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path1 GeneralPath path2  will thus return true for any pair of non-null GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path  will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,1
0,Math,weight versus sigma in AbstractLeastSquares,In AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation In the method getRMS   these weights are multiplicative as they should unlike in getChiSquare   where it appears at the denominator If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi2 Once corrected getRMS   can even reduce public double getRMS   {return Math sqrt getChiSquare   rows ;},In AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation In the method getRMS   these weights are multiplicative as they should unlike in getChiSquare   where it appears at the denominator If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi Once corrected getRMS   can even reduce public double getRMS   {return Math sqrt getChiSquare   rows ;},In AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation In the method getRMS these weights are multiplicative as they should unlike in getChiSquare where it appears at the denominator If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi Once corrected getRMS can even reduce public double getRMS {return Math sqrt getChiSquare rows ;},1
0,Math,Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the same,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to 1 1  ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to    ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to ,1
0,Math,Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the same,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to 1 1  ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to    ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to ,1
0,Math,NaN in equals methods,In MathUtils some equals methods will return true if both argument are NaN Unless I m mistaken this contradicts the IEEE standard If nobody objects I m going to make the changes ,In MathUtils some equals methods will return true if both argument are NaN Unless I m mistaken this contradicts the IEEE standard If nobody objects I m going to make the changes ,In MathUtils some equals methods will return true if both argument are NaN Unless I m mistaken this contradicts the IEEE standard If nobody objects I m going to make the changes ,1
0,Math,bug in inverseCumulativeProbability   for Normal Distribution, version Revision: 617953 Date: 2008-02-02 22:54:00 -0700 Sat 02 Feb 2008  public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision: 506600 Date: 2007-02-12 12:35:59 -0700 Mon 12 Feb 2007  public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution 0 1 ; double result = normal inverseCumulativeProbability 0 9772498680518209 ; gives the exception below It should return approx  2 0000 normal inverseCumulativeProbability 0 977249868051820 ; works fine These also give errors: 0 9986501019683698 should return 3 0000   0 9999683287581673 should return 4 0000   org apache commons math MathException: Number of iterations=1 maximum iterations=2 147 483 647 initial=1 lower bound=0 upper bound=179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final a value=0 final b value=2 f a =-0 477 f b =0 at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:103  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java:145 , version Revision:  Date:  ::  Sat  Feb   public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision:  Date:  ::  Mon  Feb   public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution   ; double result = normal inverseCumulativeProbability   ; gives the exception below It should return approx    normal inverseCumulativeProbability   ; works fine These also give errors:   should return       should return     org apache commons math MathException: Number of iterations= maximum iterations=    initial= lower bound= upper bound=                                                                                                       final a value= final b value= f a =  f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: , version Revision: Date: :: Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision: Date: :: Mon Feb public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory ; NormalDistribution normal = factory createNormalDistribution ; double result = normal inverseCumulativeProbability ; gives the exception below It should return approx normal inverseCumulativeProbability ; works fine These also give errors: should return should return org apache commons math MathException: Number of iterations= maximum iterations= initial= lower bound= upper bound= final a value= final b value= f a = f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java: at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: ,1
0,Lang,NullPointerException in isAvailableLocale Locale ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source  and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source and if availableLocaleSet hasn t been called it will cause a NullPointerException ,1
0,Lang,NullPointerException in isAvailableLocale Locale ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source  and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source and if availableLocaleSet hasn t been called it will cause a NullPointerException ,1
0,Lang,NullPointerException in isAvailableLocale Locale ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source  and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source and if availableLocaleSet hasn t been called it will cause a NullPointerException ,1
0,Closure,Break in finally block isn t optimized properly,None,None,None,1
0,Closure,Erroneous optimization in ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Closure,Column-indicating caret is sometimes not in error output,None,None,None,1
0,Chart,Error on TimeSeries createCopy   method,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart 1 0 7,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart   ,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart ,1
0,Math,MultivariateNormalDistribution density double[]  returns wrong value when the dimension is odd,To reproduce: Assert assertEquals 0 398942280401433 new MultivariateNormalDistribution new double[]{0} new double[][]{{1}}  density new double[]{0}  1e-15 ;,To reproduce: Assert assertEquals   new MultivariateNormalDistribution new double[]{} new double[][]{{}}  density new double[]{}  e ;,To reproduce: Assert assertEquals new MultivariateNormalDistribution new double[]{} new double[][]{{}} density new double[]{} e ;,1
0,Math,Bugs in Frequency API,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added - it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods - they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a non-Comparable object because the class cast exception is caught  however they just return 0 as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; 0 System out println f getPct OBJ ; 0 0 Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added  it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods  they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a nonComparable object because the class cast exception is caught  however they just return  as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ;  System out println f getPct OBJ ;   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return  or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object which should not allow a plain Object to be added it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object and getCumPct Object methods they will only work with objects that implement Comparable The getCount Object and getPct Object methods don t fail when given a nonComparable object because the class cast exception is caught however they just return as if the object was not present: final Object OBJ = new Object ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; System out println f getPct OBJ ; Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return or an Exception and applying the instanceof fix would also cause it to fail ,1
0,Math,weight versus sigma in AbstractLeastSquares,In AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation In the method getRMS   these weights are multiplicative as they should unlike in getChiSquare   where it appears at the denominator If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi2 Once corrected getRMS   can even reduce public double getRMS   {return Math sqrt getChiSquare   rows ;},In AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation In the method getRMS   these weights are multiplicative as they should unlike in getChiSquare   where it appears at the denominator If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi Once corrected getRMS   can even reduce public double getRMS   {return Math sqrt getChiSquare   rows ;},In AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation In the method getRMS these weights are multiplicative as they should unlike in getChiSquare where it appears at the denominator If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi Once corrected getRMS can even reduce public double getRMS {return Math sqrt getChiSquare rows ;},1
0,Lang,ClassUtils toClass Object[]  throws NPE on null array element,see summary,see summary,see summary,1
0,Lang,NumberUtils createNumber - bad behaviour for leading -- ,NumberUtils createNumber checks for a leading -- in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading  in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,1
0,Lang,FastDateParser does not handle white-space properly,The SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,1
0,Lang,StrBuilder appendFixedWidth does not handle nulls,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText has not been set ,1
0,Lang,NumberUtils createNumber - bad behaviour for leading -- ,NumberUtils createNumber checks for a leading -- in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading  in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,1
0,Lang,FastDateParser does not handle white-space properly,The SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,1
0,Lang,NumberUtils isNumber String  is not right when the String is 1 1L , 1 1L is not a Java Number but NumberUtils isNumber String  return true perhaps change: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp; } to: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp   hasDecPoint; },  L is not a Java Number but NumberUtils isNumber String  return true perhaps change: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp; } to: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp   hasDecPoint; }, L is not a Java Number but NumberUtils isNumber String return true perhaps change: if chars[i] == l || chars[i] == L { not allowing L with an exponent return foundDigit hasExp; } to: if chars[i] == l || chars[i] == L { not allowing L with an exponent return foundDigit hasExp hasDecPoint; },1
0,Lang,org apache commons lang3 math Fraction does not reduce Integer MIN VALUE 2 k ,The greatestCommonDivisor method in class Fraction does not find the gcd of Integer MIN VALUE and 2 k and this case can be triggered by taking Integer MIN VALUE as the numerator Note that the case of taking Integer MIN VALUE as the denominator is handled explicitly in the getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int   { f = Fraction getReducedFraction Integer MIN VALUE 2 ; assertEquals Integer MIN VALUE 2 f getNumerator  ; assertEquals 1 f getDenominator  ; public void testReduce   { f = Fraction getFraction Integer MIN VALUE 2 ; result = f reduce  ; assertEquals Integer MIN VALUE 2 result getNumerator  ; assertEquals 1 result getDenominator  ;,The greatestCommonDivisor method in class Fraction does not find the gcd of Integer MIN VALUE and  k and this case can be triggered by taking Integer MIN VALUE as the numerator Note that the case of taking Integer MIN VALUE as the denominator is handled explicitly in the getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int   { f = Fraction getReducedFraction Integer MIN VALUE  ; assertEquals Integer MIN VALUE  f getNumerator  ; assertEquals  f getDenominator  ; public void testReduce   { f = Fraction getFraction Integer MIN VALUE  ; result = f reduce  ; assertEquals Integer MIN VALUE  result getNumerator  ; assertEquals  result getDenominator  ;,The greatestCommonDivisor method in class Fraction does not find the gcd of Integer MIN VALUE and k and this case can be triggered by taking Integer MIN VALUE as the numerator Note that the case of taking Integer MIN VALUE as the denominator is handled explicitly in the getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int { f = Fraction getReducedFraction Integer MIN VALUE ; assertEquals Integer MIN VALUE f getNumerator ; assertEquals f getDenominator ; public void testReduce { f = Fraction getFraction Integer MIN VALUE ; result = f reduce ; assertEquals Integer MIN VALUE result getNumerator ; assertEquals result getDenominator ;,1
0,Math,HypergeometricDistribution sample suffers from integer overflow,Hi I have an application which broke when ported from commons math 2 2 to 3 2 It looks like the HypergeometricDistribution sample   method doesn t work as well as it used to with large integer values – the example code below should return a sample between 0 and 50 but usually returns -50 import org apache commons math3 distribution HypergeometricDistribution; public class Foo { public static void main String[] args  { HypergeometricDistribution a = new HypergeometricDistribution 43130568 42976365 50 ; System out printf d d n a getSupportLowerBound   a getSupportUpperBound  ; Prints 0 50 System out printf d n a sample  ; Prints -50 } } In the debugger I traced it as far as an integer overflow in HypergeometricDistribution getNumericalMean   – instead of doing return double  getSampleSize   getNumberOfSuccesses   double  getPopulationSize  ; it could do: return getSampleSize   double  getNumberOfSuccesses   double  getPopulationSize  ; This seemed to fix it based on a quick test ,Hi I have an application which broke when ported from commons math   to   It looks like the HypergeometricDistribution sample   method doesn t work as well as it used to with large integer values – the example code below should return a sample between  and  but usually returns  import org apache commons math distribution HypergeometricDistribution; public class Foo { public static void main String[] args  { HypergeometricDistribution a = new HypergeometricDistribution    ; System out printf d d n a getSupportLowerBound   a getSupportUpperBound  ; Prints   System out printf d n a sample  ; Prints  } } In the debugger I traced it as far as an integer overflow in HypergeometricDistribution getNumericalMean   – instead of doing return double  getSampleSize   getNumberOfSuccesses   double  getPopulationSize  ; it could do: return getSampleSize   double  getNumberOfSuccesses   double  getPopulationSize  ; This seemed to fix it based on a quick test ,Hi I have an application which broke when ported from commons math to It looks like the HypergeometricDistribution sample method doesn t work as well as it used to with large integer values – the example code below should return a sample between and but usually returns import org apache commons math distribution HypergeometricDistribution; public class Foo { public static void main String[] args { HypergeometricDistribution a = new HypergeometricDistribution ; System out printf d d n a getSupportLowerBound a getSupportUpperBound ; Prints System out printf d n a sample ; Prints } } In the debugger I traced it as far as an integer overflow in HypergeometricDistribution getNumericalMean – instead of doing return double getSampleSize getNumberOfSuccesses double getPopulationSize ; it could do: return getSampleSize double getNumberOfSuccesses double getPopulationSize ; This seemed to fix it based on a quick test ,1
0,Math,Dangerous code in PoissonDistributionImpl ,In the following excerpt from class PoissonDistributionImpl : PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z  { super  ; setNormal z ; setMean p ; } 1  Overridable methods are called within the constructor 2  The reference z is stored and modified within the class I ve encountered problem 1  in several classes while working on issue 348 In those cases in order to remove potential problems I copied pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether i e make the classes immutable  Problem 2  can also create unexpected behaviour Is it really necessary to pass the NormalDistribution object; can t it be always created within the class ,In the following excerpt from class PoissonDistributionImpl : PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z  { super  ; setNormal z ; setMean p ; }   Overridable methods are called within the constructor   The reference z is stored and modified within the class I ve encountered problem   in several classes while working on issue  In those cases in order to remove potential problems I copied pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether i e make the classes immutable  Problem   can also create unexpected behaviour Is it really necessary to pass the NormalDistribution object; can t it be always created within the class ,In the following excerpt from class PoissonDistributionImpl : PoissonDistributionImpl java public PoissonDistributionImpl double p NormalDistribution z { super ; setNormal z ; setMean p ; } Overridable methods are called within the constructor The reference z is stored and modified within the class I ve encountered problem in several classes while working on issue In those cases in order to remove potential problems I copied pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether i e make the classes immutable Problem can also create unexpected behaviour Is it really necessary to pass the NormalDistribution object; can t it be always created within the class ,1
0,Math,Need range checks for elitismRate in ElitisticListPopulation constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,1
0,Math,MathUtils factorial n  fails for n >= 17,The result of MathUtils factorial n   for n = 17 18 19 is wrong probably because of rounding errors in the double calculations Replace the first line of MathUtilsTest testFactorial   by for int i = 1; i <= 20; i   { to check all valid arguments for the long result and see the failure I suggest implementing a simple loop to multiply the long result - or even using a precomputed long[] - instead of adding logarithms ,The result of MathUtils factorial n   for n =    is wrong probably because of rounding errors in the double calculations Replace the first line of MathUtilsTest testFactorial   by for int i = ; i <= ; i   { to check all valid arguments for the long result and see the failure I suggest implementing a simple loop to multiply the long result  or even using a precomputed long[]  instead of adding logarithms ,The result of MathUtils factorial n for n = is wrong probably because of rounding errors in the double calculations Replace the first line of MathUtilsTest testFactorial by for int i = ; i <= ; i { to check all valid arguments for the long result and see the failure I suggest implementing a simple loop to multiply the long result or even using a precomputed long[] instead of adding logarithms ,1
0,Math,Bugs in Frequency API,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added - it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods - they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a non-Comparable object because the class cast exception is caught  however they just return 0 as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; 0 System out println f getPct OBJ ; 0 0 Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added  it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods  they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a nonComparable object because the class cast exception is caught  however they just return  as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ;  System out println f getPct OBJ ;   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return  or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object which should not allow a plain Object to be added it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object and getCumPct Object methods they will only work with objects that implement Comparable The getCount Object and getPct Object methods don t fail when given a nonComparable object because the class cast exception is caught however they just return as if the object was not present: final Object OBJ = new Object ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; System out println f getPct OBJ ; Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return or an Exception and applying the instanceof fix would also cause it to fail ,1
0,Math,MathUtils gcd Integer MIN VALUE 0  should throw an Exception instead of returning Integer MIN VALUE,The gcd method should throw an Exception for gcd Integer MIN VALUE 0  like for gcd Integer MIN VALUE Integer MIN VALUE  The method should only return nonnegative results ,The gcd method should throw an Exception for gcd Integer MIN VALUE   like for gcd Integer MIN VALUE Integer MIN VALUE  The method should only return nonnegative results ,The gcd method should throw an Exception for gcd Integer MIN VALUE like for gcd Integer MIN VALUE Integer MIN VALUE The method should only return nonnegative results ,1
0,Math,Bugs in Frequency API,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added - it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods - they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a non-Comparable object because the class cast exception is caught  however they just return 0 as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; 0 System out println f getPct OBJ ; 0 0 Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added  it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods  they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a nonComparable object because the class cast exception is caught  however they just return  as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ;  System out println f getPct OBJ ;   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return  or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object which should not allow a plain Object to be added it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object and getCumPct Object methods they will only work with objects that implement Comparable The getCount Object and getPct Object methods don t fail when given a nonComparable object because the class cast exception is caught however they just return as if the object was not present: final Object OBJ = new Object ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; System out println f getPct OBJ ; Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return or an Exception and applying the instanceof fix would also cause it to fail ,1
0,Math,NPE when calling SubLine intersection   with non-intersecting lines,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,1
0,Math,ArrayIndexOutOfBoundsException in MathArrays linearCombination,When MathArrays linearCombination is passed arguments with length 1 it throws an ArrayOutOfBoundsException This is caused by this line: double prodHighNext = prodHigh[1]; linearCombination should check the length of the arguments and fall back to simple multiplication if length == 1 ,When MathArrays linearCombination is passed arguments with length  it throws an ArrayOutOfBoundsException This is caused by this line: double prodHighNext = prodHigh[]; linearCombination should check the length of the arguments and fall back to simple multiplication if length ==  ,When MathArrays linearCombination is passed arguments with length it throws an ArrayOutOfBoundsException This is caused by this line: double prodHighNext = prodHigh[]; linearCombination should check the length of the arguments and fall back to simple multiplication if length == ,1
0,Math,bug in inverseCumulativeProbability   for Normal Distribution, version Revision: 617953 Date: 2008-02-02 22:54:00 -0700 Sat 02 Feb 2008  public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision: 506600 Date: 2007-02-12 12:35:59 -0700 Mon 12 Feb 2007  public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution 0 1 ; double result = normal inverseCumulativeProbability 0 9772498680518209 ; gives the exception below It should return approx  2 0000 normal inverseCumulativeProbability 0 977249868051820 ; works fine These also give errors: 0 9986501019683698 should return 3 0000   0 9999683287581673 should return 4 0000   org apache commons math MathException: Number of iterations=1 maximum iterations=2 147 483 647 initial=1 lower bound=0 upper bound=179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final a value=0 final b value=2 f a =-0 477 f b =0 at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:103  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java:145 , version Revision:  Date:  ::  Sat  Feb   public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision:  Date:  ::  Mon  Feb   public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution   ; double result = normal inverseCumulativeProbability   ; gives the exception below It should return approx    normal inverseCumulativeProbability   ; works fine These also give errors:   should return       should return     org apache commons math MathException: Number of iterations= maximum iterations=    initial= lower bound= upper bound=                                                                                                       final a value= final b value= f a =  f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: , version Revision: Date: :: Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision: Date: :: Mon Feb public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory ; NormalDistribution normal = factory createNormalDistribution ; double result = normal inverseCumulativeProbability ; gives the exception below It should return approx normal inverseCumulativeProbability ; works fine These also give errors: should return should return org apache commons math MathException: Number of iterations= maximum iterations= initial= lower bound= upper bound= final a value= final b value= f a = f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java: at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: ,1
0,Math,SimplexSolver not working as expected 2,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: 7 a 3 b; Constraints R1: 3 a -5 c <= 0; R2: 2 a -5 d <= 0; R3: 2 b -5 c <= 0; R4: 3 b -5 d <= 0; R5: 3 a 2 b <= 5; R6: 2 a 3 b <= 5; Variable bounds a <= 1; b <= 1; ===================== Results correct : a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {7 3 0 0} 0 ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {1 0 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {0 1 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {3 0 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {2 0 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 2 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 3 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {3 2 0 0} Relationship LEQ 5 ; podmienky add new LinearConstraint new double[] {2 3 0 0} Relationship LEQ 5 ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = 1 b = 0 5 value = 8 5 P S I used the latest software from the repository including MATH-286 fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max:  a  b; Constraints R:  a  c <= ; R:  a  d <= ; R:  b  c <= ; R:  b  d <= ; R:  a  b <= ; R:  a  b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a =  b =  value =  Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {   }  ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a =  b =   value =   P S I used the latest software from the repository including MATH fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: a b; Constraints R: a c <= ; R: a d <= ; R: b c <= ; R: b d <= ; R: a b <= ; R: a b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a = b = value = Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] { } ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint> ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; SimplexSolver solver = new SimplexSolver ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = b = value = P S I used the latest software from the repository including MATH fix ,1
0,Math,Complex ZERO reciprocal   returns NaN but should return INF ,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math3 complex Complex; Method: reciprocal    version Id: Complex java 1416643 2012-12-03 19:37:14Z tn,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal    version Id: Complex java   ::Z tn,Complex ZERO reciprocal returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal version Id: Complex java ::Z tn,1
0,Math, HarmonicFitter ParameterGuesser sometimes fails to return sensible values,The inner class ParameterGuesser in HarmonicFitter package o a c m optimization fitting   fails to compute a usable guess for the amplitude parameter ,The inner class ParameterGuesser in HarmonicFitter package o a c m optimization fitting   fails to compute a usable guess for the amplitude parameter ,The inner class ParameterGuesser in HarmonicFitter package o a c m optimization fitting fails to compute a usable guess for the amplitude parameter ,1
0,Time,possibly a bug in org joda time field FieldUtils safeMultiply,It seems to me that as currently written in joda-time-2 1 jar org joda time field FieldUtils safeMultiply long val1 int scalar  doesn t detect the overflow if the long val1 == Long MIN VALUE and the int scalar == -1 The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,It seems to me that as currently written in jodatime  jar org joda time field FieldUtils safeMultiply long val int scalar  doesn t detect the overflow if the long val == Long MIN VALUE and the int scalar ==  The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,It seems to me that as currently written in jodatime jar org joda time field FieldUtils safeMultiply long val int scalar doesn t detect the overflow if the long val == Long MIN VALUE and the int scalar == The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,1
0,Lang,NumberUtils createNumber - bad behaviour for leading -- ,NumberUtils createNumber checks for a leading -- in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading  in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,1
0,Lang,NumberUtils isNumber String  is not right when the String is 1 1L , 1 1L is not a Java Number but NumberUtils isNumber String  return true perhaps change: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp; } to: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp   hasDecPoint; },  L is not a Java Number but NumberUtils isNumber String  return true perhaps change: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp; } to: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp   hasDecPoint; }, L is not a Java Number but NumberUtils isNumber String return true perhaps change: if chars[i] == l || chars[i] == L { not allowing L with an exponent return foundDigit hasExp; } to: if chars[i] == l || chars[i] == L { not allowing L with an exponent return foundDigit hasExp hasDecPoint; },1
0,Closure,Break in finally block isn t optimized properly,None,None,None,1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Math,wrong result in eigen decomposition,Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version 2 0 public void testMathpbx02   { double[] mainTridiagonal = { 7484 860960227216 18405 28129035345 13855 225609560746 10016 708722343366 559 8117399576674 6750 190788301587 71 21428769782159 }; double[] secondaryTridiagonal = { -4175 088570476366 1975 7955858241994 5193 178422374075 1995 286659169179 75 34535882933804 -234 0808002076056 }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version 3 2 1 double[] refEigenValues = { 20654 744890306974412 16828 208208485466457 6893 155912634994820 6757 083016675340332 5887 799885688558788 64 309089923240379 57 992628792736340 }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] {-0 270356342026904 0 852811091326997 0 399639490702077 0 198794657813990 0 019739323307666 0 000106983022327 -0 000001216636321}  new ArrayRealVector new double[] {0 179995273578326 -0 402807848153042 0 701870993525734 0 555058211014888 0 068079148898236 0 000509139115227 -0 000007112235617}  new ArrayRealVector new double[] {-0 399582721284727 -0 056629954519333 -0 514406488522827 0 711168164518580 0 225548081276367 0 125943999652923 -0 004321507456014}  new ArrayRealVector new double[] {0 058515721572821 0 010200130057739 0 063516274916536 -0 090696087449378 -0 017148420432597 0 991318870265707 -0 034707338554096}  new ArrayRealVector new double[] {0 855205995537564 0 327134656629775 -0 265382397060548 0 282690729026706 0 105736068025572 -0 009138126622039 0 000367751821196}  new ArrayRealVector new double[] {-0 002913069901144 -0 005177515777101 0 041906334478672 -0 109315918416258 0 436192305456741 0 026307315639535 0 891797507436344}  new ArrayRealVector new double[] {-0 005738311176435 -0 010207611670378 0 082662420517928 -0 215733886094368 0 861606487840411 -0 025478530652759 -0 451080697503958}  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = 0; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i] 1 0e-3 ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  < 0  { assertEquals 0 refEigenVectors[i] add decomposition getEigenvector i  getNorm   1 0e-5 ; } else { assertEquals 0 refEigenVectors[i] subtract decomposition getEigenvector i  getNorm   1 0e-5 ; } } },Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version   public void testMathpbx   { double[] mainTridiagonal = {               }; double[] secondaryTridiagonal = {             }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version    double[] refEigenValues = {               }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = ; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i]  e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  <   { assertEquals  refEigenVectors[i] add decomposition getEigenvector i  getNorm    e ; } else { assertEquals  refEigenVectors[i] subtract decomposition getEigenvector i  getNorm    e ; } } },Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version public void testMathpbx { double[] mainTridiagonal = { }; double[] secondaryTridiagonal = { }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version double[] refEigenValues = { }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues ; for int i = ; i < refEigenValues length; i { assertEquals refEigenValues[i] eigenValues[i] e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i < { assertEquals refEigenVectors[i] add decomposition getEigenvector i getNorm e ; } else { assertEquals refEigenVectors[i] subtract decomposition getEigenvector i getNorm e ; } } },1
0,Lang,ClassUtils toClass Object[]  throws NPE on null array element,see summary,see summary,see summary,1
0,Closure,Classify non-rightmost expressions as problematic,None,None,None,1
0,Closure,Break in finally block isn t optimized properly,None,None,None,1
0,Closure,Erroneous optimization in ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,Classify non-rightmost expressions as problematic,None,None,None,1
0,Closure,Break in finally block isn t optimized properly,None,None,None,1
0,Closure,Erroneous optimization in ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,smartNameRemoval causing compiler crash,None,None,None,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze   gives bad results with commons-math3-3 0 in a simple test problem It works well in commons-math-2 2 ,Methode SimplexSolver optimeze   gives bad results with commonsmath  in a simple test problem It works well in commonsmath  ,Methode SimplexSolver optimeze gives bad results with commonsmath in a simple test problem It works well in commonsmath ,1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line 640 in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line  in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,1
0,Math,One of Variance evaluate   methods does not work correctly,The method org apache commons math stat descriptive moment Variance evaluate double[] values double[] weights double mean int begin int length  does not work properly Looks loke it ignores the length parameter and grabs the whole dataset Similar method in Mean class seems to work I did not check other methods taking the part of the array; they may have the same problem Workaround: I had to shrink my arrays and use the method without the length ,The method org apache commons math stat descriptive moment Variance evaluate double[] values double[] weights double mean int begin int length  does not work properly Looks loke it ignores the length parameter and grabs the whole dataset Similar method in Mean class seems to work I did not check other methods taking the part of the array; they may have the same problem Workaround: I had to shrink my arrays and use the method without the length ,The method org apache commons math stat descriptive moment Variance evaluate double[] values double[] weights double mean int begin int length does not work properly Looks loke it ignores the length parameter and grabs the whole dataset Similar method in Mean class seems to work I did not check other methods taking the part of the array; they may have the same problem Workaround: I had to shrink my arrays and use the method without the length ,1
0,Time,DateTimeFormat parseInto sometimes miscalculates year 2 2 ,The following code which can be added to org joda time format TestDateTimeFormatter  breaks because the input mutable date time s millis appear to be mishandled and the year for the parse is changed to 1999 ,The following code which can be added to org joda time format TestDateTimeFormatter  breaks because the input mutable date time s millis appear to be mishandled and the year for the parse is changed to  ,The following code which can be added to org joda time format TestDateTimeFormatter breaks because the input mutable date time s millis appear to be mishandled and the year for the parse is changed to ,1
0,Lang,NullPointerException in isAvailableLocale Locale ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source  and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source and if availableLocaleSet hasn t been called it will cause a NullPointerException ,1
0,Lang,NumberUtils createNumber - bad behaviour for leading -- ,NumberUtils createNumber checks for a leading -- in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading  in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,1
0,Lang,ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes,When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur Example that will cause error: ExtendedMessageFormatTest java private static Map<String Object> formatRegistry = new HashMap<String Object>  ; static { formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory  ; } public static void main String[] args  { ExtendedMessageFormat mf = new ExtendedMessageFormat it s a {dummy} test formatRegistry ; String formattedPattern = mf format new String[] { great } ; System out println formattedPattern ; } } The following change starting at line 421 on the 2 4 release seems to fix the problem: ExtendedMessageFormat java CURRENT Broken : if escapingOn   c[start] == QUOTE  { return appendTo == null null : appendTo append QUOTE ; } WORKING: if escapingOn   c[start] == QUOTE  { next pos ; return appendTo == null null : appendTo append QUOTE ; },When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur Example that will cause error: ExtendedMessageFormatTest java private static Map<String Object> formatRegistry = new HashMap<String Object>  ; static { formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory  ; } public static void main String[] args  { ExtendedMessageFormat mf = new ExtendedMessageFormat it s a {dummy} test formatRegistry ; String formattedPattern = mf format new String[] { great } ; System out println formattedPattern ; } } The following change starting at line  on the   release seems to fix the problem: ExtendedMessageFormat java CURRENT Broken : if escapingOn   c[start] == QUOTE  { return appendTo == null null : appendTo append QUOTE ; } WORKING: if escapingOn   c[start] == QUOTE  { next pos ; return appendTo == null null : appendTo append QUOTE ; },When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur Example that will cause error: ExtendedMessageFormatTest java private static Map<String Object> formatRegistry = new HashMap<String Object> ; static { formatRegistry put DummyFormatFactory DUMMY FORMAT new DummyFormatFactory ; } public static void main String[] args { ExtendedMessageFormat mf = new ExtendedMessageFormat it s a {dummy} test formatRegistry ; String formattedPattern = mf format new String[] { great } ; System out println formattedPattern ; } } The following change starting at line on the release seems to fix the problem: ExtendedMessageFormat java CURRENT Broken : if escapingOn c[start] == QUOTE { return appendTo == null null : appendTo append QUOTE ; } WORKING: if escapingOn c[start] == QUOTE { next pos ; return appendTo == null null : appendTo append QUOTE ; },1
0,Lang,org apache commons lang3 math Fraction does not reduce Integer MIN VALUE 2 k ,The greatestCommonDivisor method in class Fraction does not find the gcd of Integer MIN VALUE and 2 k and this case can be triggered by taking Integer MIN VALUE as the numerator Note that the case of taking Integer MIN VALUE as the denominator is handled explicitly in the getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int   { f = Fraction getReducedFraction Integer MIN VALUE 2 ; assertEquals Integer MIN VALUE 2 f getNumerator  ; assertEquals 1 f getDenominator  ; public void testReduce   { f = Fraction getFraction Integer MIN VALUE 2 ; result = f reduce  ; assertEquals Integer MIN VALUE 2 result getNumerator  ; assertEquals 1 result getDenominator  ;,The greatestCommonDivisor method in class Fraction does not find the gcd of Integer MIN VALUE and  k and this case can be triggered by taking Integer MIN VALUE as the numerator Note that the case of taking Integer MIN VALUE as the denominator is handled explicitly in the getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int   { f = Fraction getReducedFraction Integer MIN VALUE  ; assertEquals Integer MIN VALUE  f getNumerator  ; assertEquals  f getDenominator  ; public void testReduce   { f = Fraction getFraction Integer MIN VALUE  ; result = f reduce  ; assertEquals Integer MIN VALUE  result getNumerator  ; assertEquals  result getDenominator  ;,The greatestCommonDivisor method in class Fraction does not find the gcd of Integer MIN VALUE and k and this case can be triggered by taking Integer MIN VALUE as the numerator Note that the case of taking Integer MIN VALUE as the denominator is handled explicitly in the getReducedFraction factory method FractionTest java additional test cases public void testReducedFactory int int { f = Fraction getReducedFraction Integer MIN VALUE ; assertEquals Integer MIN VALUE f getNumerator ; assertEquals f getDenominator ; public void testReduce { f = Fraction getFraction Integer MIN VALUE ; result = f reduce ; assertEquals Integer MIN VALUE result getNumerator ; assertEquals result getDenominator ;,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2 ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path1 GeneralPath path2  will thus return true for any pair of non-null GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path  will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,1
0,Math,BisectionSolver solve final UnivariateRealFunction f double min double max double initial  throws NullPointerException,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial  invokes BisectionSolver solve double min double max  which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max  should be called Steps to reproduce: invoke: new BisectionSolver   solve someUnivariateFunctionImpl 0 0 1 0 0 5 ; NullPointerException will be thrown ,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial  invokes BisectionSolver solve double min double max  which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max  should be called Steps to reproduce: invoke: new BisectionSolver   solve someUnivariateFunctionImpl       ; NullPointerException will be thrown ,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max should be called Steps to reproduce: invoke: new BisectionSolver solve someUnivariateFunctionImpl ; NullPointerException will be thrown ,1
0,Lang,NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in ,Seems to be similar to LANG-300 except that if you don t place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead ,Seems to be similar to LANG except that if you don t place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead ,Seems to be similar to LANG except that if you don t place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead ,1
0,Closure,side-effects analysis incorrectly removing function calls with side effects,None,None,None,1
0,Closure,Column-indicating caret is sometimes not in error output,None,None,None,1
0,Closure,Constructor types that return all or unknown fail to parse,None,None,None,1
0,Closure,Converting from an interface type to a constructor which  implements itself causes stack overflow ,None,None,None,1
0,Closure,division by zero wrongly throws JSC DIVIDE BY 0 ERROR,None,None,None,1
0,Chart,Potential NPE in AbstractCategoryItemRender getLegendItems  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null not if dataset = null ,1
0,Chart,Fix for MultiplePiePlot,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,1
0,Math,FastMath max 50 0f -50 0f  => -50 0f; should be 50 0f,FastMath max 50 0f -50 0f  => -50 0f; should be 50 0f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat   because that has a bug too - it tests doubles not floats ,FastMath max  f  f  =>  f; should be  f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat   because that has a bug too  it tests doubles not floats ,FastMath max f f => f; should be f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat because that has a bug too it tests doubles not floats ,1
0,Math,Need range checks for elitismRate in ElitisticListPopulation constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze   gives bad results with commons-math3-3 0 in a simple test problem It works well in commons-math-2 2 ,Methode SimplexSolver optimeze   gives bad results with commonsmath  in a simple test problem It works well in commonsmath  ,Methode SimplexSolver optimeze gives bad results with commonsmath in a simple test problem It works well in commonsmath ,1
0,Math,In stat Frequency getPct Object  uses getCumPct Comparable  instead of getPct Comparable ,Drop in Replacement of 1 2 with 2 0 not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v  deprecated replaced by { link  getPct Comparable } as of 2 0  Deprecated public double getPct Object v  { return getCumPct Comparable< >  v ; },Drop in Replacement of   with   not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v  deprecated replaced by { link  getPct Comparable } as of    Deprecated public double getPct Object v  { return getCumPct Comparable< >  v ; },Drop in Replacement of with not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v deprecated replaced by { link getPct Comparable } as of Deprecated public double getPct Object v { return getCumPct Comparable< > v ; },1
0,Math,Statistics setVarianceImpl makes getStandardDeviation produce NaN,Invoking SummaryStatistics setVarianceImpl new Variance true false  makes getStandardDeviation produce NaN The code to reproduce it: int[] scores = {1 2 3 4}; SummaryStatistics stats = new SummaryStatistics  ; stats setVarianceImpl new Variance false ; use population variance for int i : scores  { stats addValue i ; } double sd = stats getStandardDeviation  ; System out println sd ; A workaround suggested by Mikkel is: double sd = FastMath sqrt stats getSecondMoment   stats getN  ;,Invoking SummaryStatistics setVarianceImpl new Variance true false  makes getStandardDeviation produce NaN The code to reproduce it: int[] scores = {   }; SummaryStatistics stats = new SummaryStatistics  ; stats setVarianceImpl new Variance false ; use population variance for int i : scores  { stats addValue i ; } double sd = stats getStandardDeviation  ; System out println sd ; A workaround suggested by Mikkel is: double sd = FastMath sqrt stats getSecondMoment   stats getN  ;,Invoking SummaryStatistics setVarianceImpl new Variance true false makes getStandardDeviation produce NaN The code to reproduce it: int[] scores = { }; SummaryStatistics stats = new SummaryStatistics ; stats setVarianceImpl new Variance false ; use population variance for int i : scores { stats addValue i ; } double sd = stats getStandardDeviation ; System out println sd ; A workaround suggested by Mikkel is: double sd = FastMath sqrt stats getSecondMoment stats getN ;,1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line 640 in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line  in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,1
0,Math,Division by zero,In class Complex division by zero always returns NaN I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF See here ,In class Complex division by zero always returns NaN I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF See here ,In class Complex division by zero always returns NaN I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF See here ,1
0,Math, BrentOptimizer not always reporting the best point,BrentOptimizer package o a c m optimization univariate   does not check that the point it is going to return is indeed the best one it has encountered Indeed the last evaluated point might be slightly worse than the one before last ,BrentOptimizer package o a c m optimization univariate   does not check that the point it is going to return is indeed the best one it has encountered Indeed the last evaluated point might be slightly worse than the one before last ,BrentOptimizer package o a c m optimization univariate does not check that the point it is going to return is indeed the best one it has encountered Indeed the last evaluated point might be slightly worse than the one before last ,1
0,Math,NPE when calling SubLine intersection   with non-intersecting lines,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,1
0,Math,MathRuntimeException with simple ebeMultiply on OpenMapRealVector,The following piece of code import org apache commons math linear OpenMapRealVector; import org apache commons math linear RealVector; public class DemoBugOpenMapRealVector { public static void main String[] args  { final RealVector u = new OpenMapRealVector 3 1E-6 ; u setEntry 0 1  ; u setEntry 1 0  ; u setEntry 2 2  ; final RealVector v = new OpenMapRealVector 3 1E-6 ; v setEntry 0 0  ; v setEntry 1 3  ; v setEntry 2 0  ; System out println u ; System out println v ; System out println u ebeMultiply v ; } } raises an exception org apache commons math linear OpenMapRealVector 7170a9b6 Exception in thread main org apache commons math MathRuntimeException 6: map has been modified while iterating at org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java:373  at org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java:564  at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java:372  at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java:1  at DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java:17 ,The following piece of code import org apache commons math linear OpenMapRealVector; import org apache commons math linear RealVector; public class DemoBugOpenMapRealVector { public static void main String[] args  { final RealVector u = new OpenMapRealVector  E ; u setEntry    ; u setEntry    ; u setEntry    ; final RealVector v = new OpenMapRealVector  E ; v setEntry    ; v setEntry    ; v setEntry    ; System out println u ; System out println v ; System out println u ebeMultiply v ; } } raises an exception org apache commons math linear OpenMapRealVector ab Exception in thread main org apache commons math MathRuntimeException : map has been modified while iterating at org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java:  at org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java:  at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java:  at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java:  at DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java: ,The following piece of code import org apache commons math linear OpenMapRealVector; import org apache commons math linear RealVector; public class DemoBugOpenMapRealVector { public static void main String[] args { final RealVector u = new OpenMapRealVector E ; u setEntry ; u setEntry ; u setEntry ; final RealVector v = new OpenMapRealVector E ; v setEntry ; v setEntry ; v setEntry ; System out println u ; System out println v ; System out println u ebeMultiply v ; } } raises an exception org apache commons math linear OpenMapRealVector ab Exception in thread main org apache commons math MathRuntimeException : map has been modified while iterating at org apache commons math MathRuntimeException createConcurrentModificationException MathRuntimeException java: at org apache commons math util OpenIntToDoubleHashMap Iterator advance OpenIntToDoubleHashMap java: at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java: at org apache commons math linear OpenMapRealVector ebeMultiply OpenMapRealVector java: at DemoBugOpenMapRealVector main DemoBugOpenMapRealVector java: ,1
0,Math, HarmonicFitter ParameterGuesser sometimes fails to return sensible values,The inner class ParameterGuesser in HarmonicFitter package o a c m optimization fitting   fails to compute a usable guess for the amplitude parameter ,The inner class ParameterGuesser in HarmonicFitter package o a c m optimization fitting   fails to compute a usable guess for the amplitude parameter ,The inner class ParameterGuesser in HarmonicFitter package o a c m optimization fitting fails to compute a usable guess for the amplitude parameter ,1
0,Time, withHourOfDay   sets hour inconsistantly on DST transition ,When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones Shoul the hour be set to the daylight hour or the standard hour for all time zones I can t find anything that documents this behavior My test code below returns different results for different time zones The very last assertion fails on the Australia time zone cutover ,When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones Shoul the hour be set to the daylight hour or the standard hour for all time zones I can t find anything that documents this behavior My test code below returns different results for different time zones The very last assertion fails on the Australia time zone cutover ,When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones Shoul the hour be set to the daylight hour or the standard hour for all time zones I can t find anything that documents this behavior My test code below returns different results for different time zones The very last assertion fails on the Australia time zone cutover ,1
0,Time,Constructing invalid Partials,Partials can be constructed by invoking a constructor Partial DateTimeFieldType[] int[]  or by merging together a set of partials using with each constructed by calling Partial DateTimeFieldType int  However the above doesn t work in all cases: I suppose the Partials should not allow to be constructed in either case Is that right There s also a related issue probably stems from the fact that the Partial is invalid :,Partials can be constructed by invoking a constructor Partial DateTimeFieldType[] int[]  or by merging together a set of partials using with each constructed by calling Partial DateTimeFieldType int  However the above doesn t work in all cases: I suppose the Partials should not allow to be constructed in either case Is that right There s also a related issue probably stems from the fact that the Partial is invalid :,Partials can be constructed by invoking a constructor Partial DateTimeFieldType[] int[] or by merging together a set of partials using with each constructed by calling Partial DateTimeFieldType int However the above doesn t work in all cases: I suppose the Partials should not allow to be constructed in either case Is that right There s also a related issue probably stems from the fact that the Partial is invalid :,1
0,Lang,StrBuilder contains usages of thisBuf length when they should use size,While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf length and unless I m mistaken they shouldn t ,While fixing LANG I noticed that there are two other places in StrBuilder that reference thisBuf length and unless I m mistaken they shouldn t ,While fixing LANG I noticed that there are two other places in StrBuilder that reference thisBuf length and unless I m mistaken they shouldn t ,1
0,Lang,ClassUtils toClass Object[]  throws NPE on null array element,see summary,see summary,see summary,1
0,Lang,DateFormatUtils format does not correctly change Calendar TimeZone in certain situations,If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; more commonly constructed with: cal = new GregorianCalendar 2009 9 16 8 42 16  for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar        for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; cal getTime ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; },1
0,Lang,StrBuilder appendFixedWidth does not handle nulls,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText has not been set ,1
0,Math,NPE in KMeansPlusPlusClusterer unittest,When running this unittest I am facing this NPE: java lang NullPointerException at org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java:91  This is the unittest: package org fao fisheries chronicles calcuation cluster; import static org junit Assert assertEquals; import static org junit Assert assertTrue; import java util Arrays; import java util List; import java util Random; import org apache commons math stat clustering Cluster; import org apache commons math stat clustering EuclideanIntegerPoint; import org apache commons math stat clustering KMeansPlusPlusClusterer; import org fao fisheries chronicles input CsvImportProcess; import org fao fisheries chronicles input Top200Csv; import org junit Test; public class ClusterAnalysisTest {  Test public void testPerformClusterAnalysis2   { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint> new Random 1746432956321l ; EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { new EuclideanIntegerPoint new int[] { 1959 325100 }   new EuclideanIntegerPoint new int[] { 1960 373200 }   }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer cluster Arrays asList points  1 1 ; assertEquals 1 clusters size  ; } },When running this unittest I am facing this NPE: java lang NullPointerException at org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java:  This is the unittest: package org fao fisheries chronicles calcuation cluster; import static org junit Assert assertEquals; import static org junit Assert assertTrue; import java util Arrays; import java util List; import java util Random; import org apache commons math stat clustering Cluster; import org apache commons math stat clustering EuclideanIntegerPoint; import org apache commons math stat clustering KMeansPlusPlusClusterer; import org fao fisheries chronicles input CsvImportProcess; import org fao fisheries chronicles input TopCsv; import org junit Test; public class ClusterAnalysisTest {  Test public void testPerformClusterAnalysis   { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint> new Random l ; EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { new EuclideanIntegerPoint new int[] {   }   new EuclideanIntegerPoint new int[] {   }   }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer cluster Arrays asList points    ; assertEquals  clusters size  ; } },When running this unittest I am facing this NPE: java lang NullPointerException at org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java: This is the unittest: package org fao fisheries chronicles calcuation cluster; import static org junit Assert assertEquals; import static org junit Assert assertTrue; import java util Arrays; import java util List; import java util Random; import org apache commons math stat clustering Cluster; import org apache commons math stat clustering EuclideanIntegerPoint; import org apache commons math stat clustering KMeansPlusPlusClusterer; import org fao fisheries chronicles input CsvImportProcess; import org fao fisheries chronicles input TopCsv; import org junit Test; public class ClusterAnalysisTest { Test public void testPerformClusterAnalysis { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint> new Random l ; EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { new EuclideanIntegerPoint new int[] { } new EuclideanIntegerPoint new int[] { } }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer cluster Arrays asList points ; assertEquals clusters size ; } },1
0,Lang,BooleanUtils toBoolean   - invalid drop-thru in case statement causes StringIndexOutOfBoundsException,The method BooleanUtils toBoolean   has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case 3 should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean   has a case statement; case  drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case  should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean has a case statement; case drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru ; The end of case should return false Patch to follow for source and unit test ,1
0,Lang,LocaleUtils toLocale   rejects strings with only language variant,LocaleUtils toLocale   throws an exception on strings containing a language and a variant but no country code For example : fr POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale fr POSIX   toString   According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code Commons Configuration handles this case in its PropertyConverter toLocale   method I d like to replace our implementation by the one provided by LocaleUtils but our tests fail due to this case ,LocaleUtils toLocale   throws an exception on strings containing a language and a variant but no country code For example : fr POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale fr POSIX   toString   According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code Commons Configuration handles this case in its PropertyConverter toLocale   method I d like to replace our implementation by the one provided by LocaleUtils but our tests fail due to this case ,LocaleUtils toLocale throws an exception on strings containing a language and a variant but no country code For example : fr POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale fr POSIX toString According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code Commons Configuration handles this case in its PropertyConverter toLocale method I d like to replace our implementation by the one provided by LocaleUtils but our tests fail due to this case ,1
0,Closure,Identifier minus a negative number needs a space between the - s,None,None,None,1
0,Closure,Add support for --manage closure dependencies and --only closure dependencies with compilation level WHITESPACE ONLY,None,None,None,1
0,Closure,ClassCastException during TypeCheck pass,None,None,None,1
0,Chart,Error on TimeSeries createCopy   method,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart 1 0 7,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart   ,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart ,1
0,Chart,Fix for MultiplePiePlot,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,1
0,Math,Truncation issue in KMeansPlusPlusClusterer,The for loop inside KMeansPlusPlusClusterer chooseInitialClusters defines a variable int sum = 0; This variable should have type double rather than int Using an int causes the method to truncate the distances between points to square roots of  integers It s especially bad when the distances between points are typically less than 1 As an aside in version 2 2 this bug manifested itself by making the clusterer return empty clusters I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed ,The for loop inside KMeansPlusPlusClusterer chooseInitialClusters defines a variable int sum = ; This variable should have type double rather than int Using an int causes the method to truncate the distances between points to square roots of  integers It s especially bad when the distances between points are typically less than  As an aside in version   this bug manifested itself by making the clusterer return empty clusters I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed ,The for loop inside KMeansPlusPlusClusterer chooseInitialClusters defines a variable int sum = ; This variable should have type double rather than int Using an int causes the method to truncate the distances between points to square roots of integers It s especially bad when the distances between points are typically less than As an aside in version this bug manifested itself by making the clusterer return empty clusters I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed ,1
0,Math,MathUtils gcd u v  fails when u and v both contain a high power of 2,The test at the beginning of MathUtils gcd u v  for arguments equal to zero fails when u and v contain high enough powers of 2 so that their product overflows to zero assertEquals 3 1<<15  MathUtils gcd 3 1<<20  9 1<<15 ; Fix: Replace the test at the start of MathUtils gcd   if u v == 0  { by if u == 0 || v == 0  {,The test at the beginning of MathUtils gcd u v  for arguments equal to zero fails when u and v contain high enough powers of  so that their product overflows to zero assertEquals  <<  MathUtils gcd  <<   << ; Fix: Replace the test at the start of MathUtils gcd   if u v ==   { by if u ==  || v ==   {,The test at the beginning of MathUtils gcd u v for arguments equal to zero fails when u and v contain high enough powers of so that their product overflows to zero assertEquals << MathUtils gcd << << ; Fix: Replace the test at the start of MathUtils gcd if u v == { by if u == || v == {,1
0,Math,ListPopulation Iterator allows you to remove chromosomes from the population ,Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list Before returning the iterator we should wrap it in an unmodifiable list ,Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list Before returning the iterator we should wrap it in an unmodifiable list ,Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list Before returning the iterator we should wrap it in an unmodifiable list ,1
0,Math,Fraction percentageValue rare overflow,The percentageValue   method of the Fraction class works by first multiplying the Fraction by 100 then converting the Fraction to a double This causes overflows when the numerator is greater than Integer MAX VALUE 100 even when the value of the fraction is far below this value The patch changes the method to first convert to a double value and then multiply this value by 100 - the result should be the same but with less overflows An addition to the test for the method that covers this bug is also included ,The percentageValue   method of the Fraction class works by first multiplying the Fraction by  then converting the Fraction to a double This causes overflows when the numerator is greater than Integer MAX VALUE  even when the value of the fraction is far below this value The patch changes the method to first convert to a double value and then multiply this value by   the result should be the same but with less overflows An addition to the test for the method that covers this bug is also included ,The percentageValue method of the Fraction class works by first multiplying the Fraction by then converting the Fraction to a double This causes overflows when the numerator is greater than Integer MAX VALUE even when the value of the fraction is far below this value The patch changes the method to first convert to a double value and then multiply this value by the result should be the same but with less overflows An addition to the test for the method that covers this bug is also included ,1
0,Math,wrong result in eigen decomposition,Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version 2 0 public void testMathpbx02   { double[] mainTridiagonal = { 7484 860960227216 18405 28129035345 13855 225609560746 10016 708722343366 559 8117399576674 6750 190788301587 71 21428769782159 }; double[] secondaryTridiagonal = { -4175 088570476366 1975 7955858241994 5193 178422374075 1995 286659169179 75 34535882933804 -234 0808002076056 }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version 3 2 1 double[] refEigenValues = { 20654 744890306974412 16828 208208485466457 6893 155912634994820 6757 083016675340332 5887 799885688558788 64 309089923240379 57 992628792736340 }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] {-0 270356342026904 0 852811091326997 0 399639490702077 0 198794657813990 0 019739323307666 0 000106983022327 -0 000001216636321}  new ArrayRealVector new double[] {0 179995273578326 -0 402807848153042 0 701870993525734 0 555058211014888 0 068079148898236 0 000509139115227 -0 000007112235617}  new ArrayRealVector new double[] {-0 399582721284727 -0 056629954519333 -0 514406488522827 0 711168164518580 0 225548081276367 0 125943999652923 -0 004321507456014}  new ArrayRealVector new double[] {0 058515721572821 0 010200130057739 0 063516274916536 -0 090696087449378 -0 017148420432597 0 991318870265707 -0 034707338554096}  new ArrayRealVector new double[] {0 855205995537564 0 327134656629775 -0 265382397060548 0 282690729026706 0 105736068025572 -0 009138126622039 0 000367751821196}  new ArrayRealVector new double[] {-0 002913069901144 -0 005177515777101 0 041906334478672 -0 109315918416258 0 436192305456741 0 026307315639535 0 891797507436344}  new ArrayRealVector new double[] {-0 005738311176435 -0 010207611670378 0 082662420517928 -0 215733886094368 0 861606487840411 -0 025478530652759 -0 451080697503958}  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = 0; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i] 1 0e-3 ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  < 0  { assertEquals 0 refEigenVectors[i] add decomposition getEigenvector i  getNorm   1 0e-5 ; } else { assertEquals 0 refEigenVectors[i] subtract decomposition getEigenvector i  getNorm   1 0e-5 ; } } },Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version   public void testMathpbx   { double[] mainTridiagonal = {               }; double[] secondaryTridiagonal = {             }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version    double[] refEigenValues = {               }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = ; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i]  e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  <   { assertEquals  refEigenVectors[i] add decomposition getEigenvector i  getNorm    e ; } else { assertEquals  refEigenVectors[i] subtract decomposition getEigenvector i  getNorm    e ; } } },Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version public void testMathpbx { double[] mainTridiagonal = { }; double[] secondaryTridiagonal = { }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version double[] refEigenValues = { }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues ; for int i = ; i < refEigenValues length; i { assertEquals refEigenValues[i] eigenValues[i] e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i < { assertEquals refEigenVectors[i] add decomposition getEigenvector i getNorm e ; } else { assertEquals refEigenVectors[i] subtract decomposition getEigenvector i getNorm e ; } } },1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line 640 in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line  in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,1
0,Math,Mann-Whitney U Test Suffers From Integer Overflow With Large Data Sets,When performing a Mann-Whitney U Test on large data sets the attached test uses two 1500 element sets  intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,When performing a MannWhitney U Test on large data sets the attached test uses two  element sets  intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as pvalues of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,When performing a MannWhitney U Test on large data sets the attached test uses two element sets intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as pvalues of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,1
0,Math,Bugs in Frequency API,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added - it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods - they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a non-Comparable object because the class cast exception is caught  however they just return 0 as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; 0 System out println f getPct OBJ ; 0 0 Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v  method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object  which should not allow a plain Object to be added  it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object  and getCumPct Object  methods  they will only work with objects that implement Comparable The getCount Object  and getPct Object  methods don t fail when given a nonComparable object because the class cast exception is caught  however they just return  as if the object was not present: final Object OBJ = new Object  ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ;  System out println f getPct OBJ ;   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return  or an Exception and applying the instanceof fix would also cause it to fail ,I think the existing Frequency API has some bugs in it The addValue Object v method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException In fact the problem is with the first call to addValue Object which should not allow a plain Object to be added it should only allow Comparable objects This could be fixed by checking that the object is Comparable Similar considerations apply to the getCumFreq Object and getCumPct Object methods they will only work with objects that implement Comparable The getCount Object and getPct Object methods don t fail when given a nonComparable object because the class cast exception is caught however they just return as if the object was not present: final Object OBJ = new Object ; f addValue OBJ ; This ought to fail but doesn t causing the unexpected behaviour below System out println f getCount OBJ ; System out println f getPct OBJ ; Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object Also it should make it easier to implement generics However this would cause compilation failures for some programs that pass Object rather than Comparable to the class These would need recoding but I think they would continue to run OK against the new API It would also affect the runtime behaviour slightly as the first attempt to add a nonComparable object would fail rather than the second add of a possibly valid object But is that a viable program It can only add one object and any attempt to get statistics will either return or an Exception and applying the instanceof fix would also cause it to fail ,1
0,Math,getLInfNorm   uses wrong formula in both ArrayRealVector and OpenMapRealVector in different ways ,the L infinity norm of a finite dimensional vector is just the max of the absolute value of its entries The current implementation in ArrayRealVector has a typo: public double getLInfNorm   { double max = 0; for double a : data  { max = Math max max Math abs a ; } return max; } the = should just be an = There is sadly a unit test assuring us that this is the correct behavior effectively a regression-only test not a test for correctness  Worse the implementation in OpenMapRealVector is not even positive semi-definite: public double getLInfNorm   { double max = 0; Iterator iter = entries iterator  ; while iter hasNext   { iter advance  ; max = iter value  ; } return max; } I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator  : public double getLInfNorm   { double norm = 0; Iterator<Entry> it = sparseIterator  ; Entry e; while it hasNext     e = it next   = null  { norm = Math max norm Math abs e getValue  ; } return norm; } Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future ,the L infinity norm of a finite dimensional vector is just the max of the absolute value of its entries The current implementation in ArrayRealVector has a typo: public double getLInfNorm   { double max = ; for double a : data  { max = Math max max Math abs a ; } return max; } the = should just be an = There is sadly a unit test assuring us that this is the correct behavior effectively a regressiononly test not a test for correctness  Worse the implementation in OpenMapRealVector is not even positive semidefinite: public double getLInfNorm   { double max = ; Iterator iter = entries iterator  ; while iter hasNext   { iter advance  ; max = iter value  ; } return max; } I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator  : public double getLInfNorm   { double norm = ; Iterator<Entry> it = sparseIterator  ; Entry e; while it hasNext     e = it next   = null  { norm = Math max norm Math abs e getValue  ; } return norm; } Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future ,the L infinity norm of a finite dimensional vector is just the max of the absolute value of its entries The current implementation in ArrayRealVector has a typo: public double getLInfNorm { double max = ; for double a : data { max = Math max max Math abs a ; } return max; } the = should just be an = There is sadly a unit test assuring us that this is the correct behavior effectively a regressiononly test not a test for correctness Worse the implementation in OpenMapRealVector is not even positive semidefinite: public double getLInfNorm { double max = ; Iterator iter = entries iterator ; while iter hasNext { iter advance ; max = iter value ; } return max; } I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator : public double getLInfNorm { double norm = ; Iterator<Entry> it = sparseIterator ; Entry e; while it hasNext e = it next = null { norm = Math max norm Math abs e getValue ; } return norm; } Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future ,1
0,Math,SimplexSolver not working as expected 2,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: 7 a 3 b; Constraints R1: 3 a -5 c <= 0; R2: 2 a -5 d <= 0; R3: 2 b -5 c <= 0; R4: 3 b -5 d <= 0; R5: 3 a 2 b <= 5; R6: 2 a 3 b <= 5; Variable bounds a <= 1; b <= 1; ===================== Results correct : a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {7 3 0 0} 0 ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {1 0 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {0 1 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {3 0 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {2 0 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 2 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 3 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {3 2 0 0} Relationship LEQ 5 ; podmienky add new LinearConstraint new double[] {2 3 0 0} Relationship LEQ 5 ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = 1 b = 0 5 value = 8 5 P S I used the latest software from the repository including MATH-286 fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max:  a  b; Constraints R:  a  c <= ; R:  a  d <= ; R:  b  c <= ; R:  b  d <= ; R:  a  b <= ; R:  a  b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a =  b =  value =  Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {   }  ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a =  b =   value =   P S I used the latest software from the repository including MATH fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: a b; Constraints R: a c <= ; R: a d <= ; R: b c <= ; R: b d <= ; R: a b <= ; R: a b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a = b = value = Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] { } ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint> ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; SimplexSolver solver = new SimplexSolver ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = b = value = P S I used the latest software from the repository including MATH fix ,1
0,Math,HypergeometricDistribution sample suffers from integer overflow,Hi I have an application which broke when ported from commons math 2 2 to 3 2 It looks like the HypergeometricDistribution sample   method doesn t work as well as it used to with large integer values – the example code below should return a sample between 0 and 50 but usually returns -50 import org apache commons math3 distribution HypergeometricDistribution; public class Foo { public static void main String[] args  { HypergeometricDistribution a = new HypergeometricDistribution 43130568 42976365 50 ; System out printf d d n a getSupportLowerBound   a getSupportUpperBound  ; Prints 0 50 System out printf d n a sample  ; Prints -50 } } In the debugger I traced it as far as an integer overflow in HypergeometricDistribution getNumericalMean   – instead of doing return double  getSampleSize   getNumberOfSuccesses   double  getPopulationSize  ; it could do: return getSampleSize   double  getNumberOfSuccesses   double  getPopulationSize  ; This seemed to fix it based on a quick test ,Hi I have an application which broke when ported from commons math   to   It looks like the HypergeometricDistribution sample   method doesn t work as well as it used to with large integer values – the example code below should return a sample between  and  but usually returns  import org apache commons math distribution HypergeometricDistribution; public class Foo { public static void main String[] args  { HypergeometricDistribution a = new HypergeometricDistribution    ; System out printf d d n a getSupportLowerBound   a getSupportUpperBound  ; Prints   System out printf d n a sample  ; Prints  } } In the debugger I traced it as far as an integer overflow in HypergeometricDistribution getNumericalMean   – instead of doing return double  getSampleSize   getNumberOfSuccesses   double  getPopulationSize  ; it could do: return getSampleSize   double  getNumberOfSuccesses   double  getPopulationSize  ; This seemed to fix it based on a quick test ,Hi I have an application which broke when ported from commons math to It looks like the HypergeometricDistribution sample method doesn t work as well as it used to with large integer values – the example code below should return a sample between and but usually returns import org apache commons math distribution HypergeometricDistribution; public class Foo { public static void main String[] args { HypergeometricDistribution a = new HypergeometricDistribution ; System out printf d d n a getSupportLowerBound a getSupportUpperBound ; Prints System out printf d n a sample ; Prints } } In the debugger I traced it as far as an integer overflow in HypergeometricDistribution getNumericalMean – instead of doing return double getSampleSize getNumberOfSuccesses double getPopulationSize ; it could do: return getSampleSize double getNumberOfSuccesses double getPopulationSize ; This seemed to fix it based on a quick test ,1
0,Lang,BooleanUtils toBoolean   - invalid drop-thru in case statement causes StringIndexOutOfBoundsException,The method BooleanUtils toBoolean   has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case 3 should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean   has a case statement; case  drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case  should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean has a case statement; case drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru ; The end of case should return false Patch to follow for source and unit test ,1
0,Lang,ClassUtils toClass Object[]  throws NPE on null array element,see summary,see summary,see summary,1
0,Lang,FastDateParser does not handle white-space properly,The SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,1
0,Mockito,fixed a verify   call example in  Captor javadoc ,None,None,None,1
0,Mockito,1 10 regression StackOverflowError  with interface where generic type has itself as upper bound ,None,None,None,1
0,Mockito,Generate change list separated by types using labels,As discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels It is required to specify which labels should be considered separately Some other labels can be excluded like question or refactoring   There is also headerForOtherChanges method to override default Other header ,As discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels It is required to specify which labels should be considered separately Some other labels can be excluded like question or refactoring   There is also headerForOtherChanges method to override default Other header ,As discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels It is required to specify which labels should be considered separately Some other labels can be excluded like question or refactoring There is also headerForOtherChanges method to override default Other header ,1
0,Closure,weird object literal invalid property error on unrelated object prototype,None,None,None,1
0,Closure,Dependency sorting with closurePass set to false no longer works ,None,None,None,1
0,Closure,Codepoint U 007f appears raw in output,None,None,None,1
0,Closure,Add support for --manage closure dependencies and --only closure dependencies with compilation level WHITESPACE ONLY,None,None,None,1
0,Closure,Column-indicating caret is sometimes not in error output,None,None,None,1
0,Closure,Column-indicating caret is sometimes not in error output,None,None,None,1
0,Closure,unexpected typed coverage of less than 100 ,None,None,None,1
0,Chart,Error on TimeSeries createCopy   method,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart 1 0 7,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart   ,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart ,1
0,Chart,Error on TimeSeries createCopy   method,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart 1 0 7,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart   ,The test case at the end fails with : java lang IllegalArgumentException: Requires start <= end The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly Here I would expect an empty serie to be returned not an exception This is with jfreechart ,1
0,Chart,Potential NPE in AbstractCategoryItemRender getLegendItems  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null not if dataset = null ,1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Math,BSPTree class and recovery of a Euclidean 3D BRep,New to the work here Thanks for your efforts on this code I create a BSPTree from a BoundaryRep Brep  my test Brep is a cube as represented by a float array containing 8 3D points in x y z  order and an array of indices 12 triplets for the 12 faces of the cube  I construct a BSPMesh   as shown in the code below I can construct the PolyhedronsSet   but have problems extracting the faces from the BSPTree to reconstruct the BRep The attached code BSPMesh2 java  shows that a small change to 1 of the vertex positions causes corrects the problem Any ideas ,New to the work here Thanks for your efforts on this code I create a BSPTree from a BoundaryRep Brep  my test Brep is a cube as represented by a float array containing  D points in x y z  order and an array of indices  triplets for the  faces of the cube  I construct a BSPMesh   as shown in the code below I can construct the PolyhedronsSet   but have problems extracting the faces from the BSPTree to reconstruct the BRep The attached code BSPMesh java  shows that a small change to  of the vertex positions causes corrects the problem Any ideas ,New to the work here Thanks for your efforts on this code I create a BSPTree from a BoundaryRep Brep my test Brep is a cube as represented by a float array containing D points in x y z order and an array of indices triplets for the faces of the cube I construct a BSPMesh as shown in the code below I can construct the PolyhedronsSet but have problems extracting the faces from the BSPTree to reconstruct the BRep The attached code BSPMesh java shows that a small change to of the vertex positions causes corrects the problem Any ideas ,1
0,Math,wrong result in eigen decomposition,Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version 2 0 public void testMathpbx02   { double[] mainTridiagonal = { 7484 860960227216 18405 28129035345 13855 225609560746 10016 708722343366 559 8117399576674 6750 190788301587 71 21428769782159 }; double[] secondaryTridiagonal = { -4175 088570476366 1975 7955858241994 5193 178422374075 1995 286659169179 75 34535882933804 -234 0808002076056 }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version 3 2 1 double[] refEigenValues = { 20654 744890306974412 16828 208208485466457 6893 155912634994820 6757 083016675340332 5887 799885688558788 64 309089923240379 57 992628792736340 }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] {-0 270356342026904 0 852811091326997 0 399639490702077 0 198794657813990 0 019739323307666 0 000106983022327 -0 000001216636321}  new ArrayRealVector new double[] {0 179995273578326 -0 402807848153042 0 701870993525734 0 555058211014888 0 068079148898236 0 000509139115227 -0 000007112235617}  new ArrayRealVector new double[] {-0 399582721284727 -0 056629954519333 -0 514406488522827 0 711168164518580 0 225548081276367 0 125943999652923 -0 004321507456014}  new ArrayRealVector new double[] {0 058515721572821 0 010200130057739 0 063516274916536 -0 090696087449378 -0 017148420432597 0 991318870265707 -0 034707338554096}  new ArrayRealVector new double[] {0 855205995537564 0 327134656629775 -0 265382397060548 0 282690729026706 0 105736068025572 -0 009138126622039 0 000367751821196}  new ArrayRealVector new double[] {-0 002913069901144 -0 005177515777101 0 041906334478672 -0 109315918416258 0 436192305456741 0 026307315639535 0 891797507436344}  new ArrayRealVector new double[] {-0 005738311176435 -0 010207611670378 0 082662420517928 -0 215733886094368 0 861606487840411 -0 025478530652759 -0 451080697503958}  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = 0; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i] 1 0e-3 ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  < 0  { assertEquals 0 refEigenVectors[i] add decomposition getEigenvector i  getNorm   1 0e-5 ; } else { assertEquals 0 refEigenVectors[i] subtract decomposition getEigenvector i  getNorm   1 0e-5 ; } } },Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version   public void testMathpbx   { double[] mainTridiagonal = {               }; double[] secondaryTridiagonal = {             }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version    double[] refEigenValues = {               }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = ; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i]  e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  <   { assertEquals  refEigenVectors[i] add decomposition getEigenvector i  getNorm    e ; } else { assertEquals  refEigenVectors[i] subtract decomposition getEigenvector i  getNorm    e ; } } },Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version public void testMathpbx { double[] mainTridiagonal = { }; double[] secondaryTridiagonal = { }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version double[] refEigenValues = { }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues ; for int i = ; i < refEigenValues length; i { assertEquals refEigenValues[i] eigenValues[i] e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i < { assertEquals refEigenVectors[i] add decomposition getEigenvector i getNorm e ; } else { assertEquals refEigenVectors[i] subtract decomposition getEigenvector i getNorm e ; } } },1
0,Math,wrong result in eigen decomposition,Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version 2 0 public void testMathpbx02   { double[] mainTridiagonal = { 7484 860960227216 18405 28129035345 13855 225609560746 10016 708722343366 559 8117399576674 6750 190788301587 71 21428769782159 }; double[] secondaryTridiagonal = { -4175 088570476366 1975 7955858241994 5193 178422374075 1995 286659169179 75 34535882933804 -234 0808002076056 }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version 3 2 1 double[] refEigenValues = { 20654 744890306974412 16828 208208485466457 6893 155912634994820 6757 083016675340332 5887 799885688558788 64 309089923240379 57 992628792736340 }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] {-0 270356342026904 0 852811091326997 0 399639490702077 0 198794657813990 0 019739323307666 0 000106983022327 -0 000001216636321}  new ArrayRealVector new double[] {0 179995273578326 -0 402807848153042 0 701870993525734 0 555058211014888 0 068079148898236 0 000509139115227 -0 000007112235617}  new ArrayRealVector new double[] {-0 399582721284727 -0 056629954519333 -0 514406488522827 0 711168164518580 0 225548081276367 0 125943999652923 -0 004321507456014}  new ArrayRealVector new double[] {0 058515721572821 0 010200130057739 0 063516274916536 -0 090696087449378 -0 017148420432597 0 991318870265707 -0 034707338554096}  new ArrayRealVector new double[] {0 855205995537564 0 327134656629775 -0 265382397060548 0 282690729026706 0 105736068025572 -0 009138126622039 0 000367751821196}  new ArrayRealVector new double[] {-0 002913069901144 -0 005177515777101 0 041906334478672 -0 109315918416258 0 436192305456741 0 026307315639535 0 891797507436344}  new ArrayRealVector new double[] {-0 005738311176435 -0 010207611670378 0 082662420517928 -0 215733886094368 0 861606487840411 -0 025478530652759 -0 451080697503958}  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = 0; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i] 1 0e-3 ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  < 0  { assertEquals 0 refEigenVectors[i] add decomposition getEigenvector i  getNorm   1 0e-5 ; } else { assertEquals 0 refEigenVectors[i] subtract decomposition getEigenvector i  getNorm   1 0e-5 ; } } },Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version   public void testMathpbx   { double[] mainTridiagonal = {               }; double[] secondaryTridiagonal = {             }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version    double[] refEigenValues = {               }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  new ArrayRealVector new double[] {             }  }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues  ; for int i = ; i < refEigenValues length; i  { assertEquals refEigenValues[i] eigenValues[i]  e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i  <   { assertEquals  refEigenVectors[i] add decomposition getEigenvector i  getNorm    e ; } else { assertEquals  refEigenVectors[i] subtract decomposition getEigenvector i  getNorm    e ; } } },Some results computed by EigenDecompositionImpl are wrong The following case computed by Fortran Lapack fails with version public void testMathpbx { double[] mainTridiagonal = { }; double[] secondaryTridiagonal = { }; the reference values have been computed using routine DSTEMR from the fortran library LAPACK version double[] refEigenValues = { }; RealVector[] refEigenVectors = { new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } new ArrayRealVector new double[] { } }; the following line triggers the exception EigenDecomposition decomposition = new EigenDecompositionImpl mainTridiagonal secondaryTridiagonal MathUtils SAFE MIN ; double[] eigenValues = decomposition getRealEigenvalues ; for int i = ; i < refEigenValues length; i { assertEquals refEigenValues[i] eigenValues[i] e ; if refEigenVectors[i] dotProduct decomposition getEigenvector i < { assertEquals refEigenVectors[i] add decomposition getEigenvector i getNorm e ; } else { assertEquals refEigenVectors[i] subtract decomposition getEigenvector i getNorm e ; } } },1
0,Math,Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the same,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to 1 1  ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to    ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to ,1
0,Math,Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the same,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to 1 1  ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to    ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to ,1
0,Math,bug in inverseCumulativeProbability   for Normal Distribution, version Revision: 617953 Date: 2008-02-02 22:54:00 -0700 Sat 02 Feb 2008  public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision: 506600 Date: 2007-02-12 12:35:59 -0700 Mon 12 Feb 2007  public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution 0 1 ; double result = normal inverseCumulativeProbability 0 9772498680518209 ; gives the exception below It should return approx  2 0000 normal inverseCumulativeProbability 0 977249868051820 ; works fine These also give errors: 0 9986501019683698 should return 3 0000   0 9999683287581673 should return 4 0000   org apache commons math MathException: Number of iterations=1 maximum iterations=2 147 483 647 initial=1 lower bound=0 upper bound=179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final a value=0 final b value=2 f a =-0 477 f b =0 at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:103  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java:145 , version Revision:  Date:  ::  Sat  Feb   public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision:  Date:  ::  Mon  Feb   public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution   ; double result = normal inverseCumulativeProbability   ; gives the exception below It should return approx    normal inverseCumulativeProbability   ; works fine These also give errors:   should return       should return     org apache commons math MathException: Number of iterations= maximum iterations=    initial= lower bound= upper bound=                                                                                                       final a value= final b value= f a =  f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: , version Revision: Date: :: Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision: Date: :: Mon Feb public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory ; NormalDistribution normal = factory createNormalDistribution ; double result = normal inverseCumulativeProbability ; gives the exception below It should return approx normal inverseCumulativeProbability ; works fine These also give errors: should return should return org apache commons math MathException: Number of iterations= maximum iterations= initial= lower bound= upper bound= final a value= final b value= f a = f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java: at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: ,1
0,Math,SimplexSolver not working as expected 2,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: 7 a 3 b; Constraints R1: 3 a -5 c <= 0; R2: 2 a -5 d <= 0; R3: 2 b -5 c <= 0; R4: 3 b -5 d <= 0; R5: 3 a 2 b <= 5; R6: 2 a 3 b <= 5; Variable bounds a <= 1; b <= 1; ===================== Results correct : a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {7 3 0 0} 0 ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {1 0 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {0 1 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {3 0 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {2 0 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 2 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 3 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {3 2 0 0} Relationship LEQ 5 ; podmienky add new LinearConstraint new double[] {2 3 0 0} Relationship LEQ 5 ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = 1 b = 0 5 value = 8 5 P S I used the latest software from the repository including MATH-286 fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max:  a  b; Constraints R:  a  c <= ; R:  a  d <= ; R:  b  c <= ; R:  b  d <= ; R:  a  b <= ; R:  a  b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a =  b =  value =  Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {   }  ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a =  b =   value =   P S I used the latest software from the repository including MATH fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: a b; Constraints R: a c <= ; R: a d <= ; R: b c <= ; R: b d <= ; R: a b <= ; R: a b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a = b = value = Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] { } ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint> ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; SimplexSolver solver = new SimplexSolver ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = b = value = P S I used the latest software from the repository including MATH fix ,1
0,Math,Complex ZERO reciprocal   returns NaN but should return INF ,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math3 complex Complex; Method: reciprocal    version Id: Complex java 1416643 2012-12-03 19:37:14Z tn,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal    version Id: Complex java   ::Z tn,Complex ZERO reciprocal returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal version Id: Complex java ::Z tn,1
0,Math,Complex ZERO reciprocal   returns NaN but should return INF ,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math3 complex Complex; Method: reciprocal    version Id: Complex java 1416643 2012-12-03 19:37:14Z tn,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal    version Id: Complex java   ::Z tn,Complex ZERO reciprocal returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal version Id: Complex java ::Z tn,1
0,Math,Complex ZERO reciprocal   returns NaN but should return INF ,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math3 complex Complex; Method: reciprocal    version Id: Complex java 1416643 2012-12-03 19:37:14Z tn,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal    version Id: Complex java   ::Z tn,Complex ZERO reciprocal returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal version Id: Complex java ::Z tn,1
0,Lang,BooleanUtils toBoolean   - invalid drop-thru in case statement causes StringIndexOutOfBoundsException,The method BooleanUtils toBoolean   has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case 3 should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean   has a case statement; case  drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case  should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean has a case statement; case drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru ; The end of case should return false Patch to follow for source and unit test ,1
0,Lang,BooleanUtils toBoolean   - invalid drop-thru in case statement causes StringIndexOutOfBoundsException,The method BooleanUtils toBoolean   has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case 3 should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean   has a case statement; case  drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case  should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean has a case statement; case drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru ; The end of case should return false Patch to follow for source and unit test ,1
0,Lang,BooleanUtils toBoolean   - invalid drop-thru in case statement causes StringIndexOutOfBoundsException,The method BooleanUtils toBoolean   has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case 3 should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean   has a case statement; case  drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case  should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean has a case statement; case drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru ; The end of case should return false Patch to follow for source and unit test ,1
0,Lang,BooleanUtils toBoolean   - invalid drop-thru in case statement causes StringIndexOutOfBoundsException,The method BooleanUtils toBoolean   has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case 3 should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean   has a case statement; case  drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case  should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean has a case statement; case drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru ; The end of case should return false Patch to follow for source and unit test ,1
0,Lang,BooleanUtils toBoolean   - invalid drop-thru in case statement causes StringIndexOutOfBoundsException,The method BooleanUtils toBoolean   has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case 3 should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean   has a case statement; case  drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case  should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean has a case statement; case drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru ; The end of case should return false Patch to follow for source and unit test ,1
0,Lang,ClassUtils toClass Object[]  throws NPE on null array element,see summary,see summary,see summary,1
0,Lang,ClassUtils toClass Object[]  throws NPE on null array element,see summary,see summary,see summary,1
0,Lang,WordUtils abbreviate bug when lower is greater than str length,In WordUtils abbreviate upper is adjusted to the length of the string then to lower But lower is never adjusted to the length of the string so if lower is greater than str lengt   upper will be too Then str substring 0 upper  throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string,In WordUtils abbreviate upper is adjusted to the length of the string then to lower But lower is never adjusted to the length of the string so if lower is greater than str lengt   upper will be too Then str substring  upper  throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string,In WordUtils abbreviate upper is adjusted to the length of the string then to lower But lower is never adjusted to the length of the string so if lower is greater than str lengt upper will be too Then str substring upper throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string,1
0,Lang,DateFormatUtils format does not correctly change Calendar TimeZone in certain situations,If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; more commonly constructed with: cal = new GregorianCalendar 2009 9 16 8 42 16  for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar        for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; cal getTime ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; },1
0,Lang,DateFormatUtils format does not correctly change Calendar TimeZone in certain situations,If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; more commonly constructed with: cal = new GregorianCalendar 2009 9 16 8 42 16  for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar        for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; cal getTime ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; },1
0,Lang,DateFormatUtils format does not correctly change Calendar TimeZone in certain situations,If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; more commonly constructed with: cal = new GregorianCalendar 2009 9 16 8 42 16  for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = 2009-10-16T16:42:16 000Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT-8  ; cal clear  ; cal set 2009 9 16 8 42 16 ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyy-MM-dd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime   seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar        for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu   { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT  ; cal clear  ; cal set       ; cal getTime  ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT  ; assertEquals dateTime dateTime format format cal ; },If a Calendar object is constructed in certain ways a call to Calendar setTimeZone does not correctly change the Calendars fields Calling Calenar getTime seems to fix this problem While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect resolve this problem For example the following unit test fails: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; more commonly constructed with: cal = new GregorianCalendar for the unit test to work in any time zone constructing with GMT rather than default locale time zone GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; } However this unit test passes: public void testFormat CalendarIsoMsZulu { final String dateTime = T:: Z ; GregorianCalendar cal = new GregorianCalendar TimeZone getTimeZone GMT ; cal clear ; cal set ; cal getTime ; FastDateFormat format = FastDateFormat getInstance yyyyMMdd T HH:mm:ss SSS Z TimeZone getTimeZone GMT ; assertEquals dateTime dateTime format format cal ; },1
0,Lang,StopWatch: suspend   acts as split   if followed by stop  ,In my opinion it is a bug that suspend   acts as split   if followed by stop  ; see below: StopWatch sw = new StopWatch  ; sw start  ; Thread sleep 1000 ; sw suspend  ; Time 1 ok  System out println sw getTime  ; Thread sleep 2000 ; Time 1 again ok  System out println sw getTime  ; sw resume  ; Thread sleep 3000 ; sw suspend  ; Time 2 ok  System out println sw getTime  ; Thread sleep 4000 ; Time 2 again ok  System out println sw getTime  ; Thread sleep 5000 ; sw stop  ; Time 2 should be but is Time 3 => NOT ok  System out println sw getTime  ; suspend resume is like a pause where time counter doesn t continue So a following stop  -call shouldn t increase the time counter should it ,In my opinion it is a bug that suspend   acts as split   if followed by stop  ; see below: StopWatch sw = new StopWatch  ; sw start  ; Thread sleep  ; sw suspend  ; Time  ok  System out println sw getTime  ; Thread sleep  ; Time  again ok  System out println sw getTime  ; sw resume  ; Thread sleep  ; sw suspend  ; Time  ok  System out println sw getTime  ; Thread sleep  ; Time  again ok  System out println sw getTime  ; Thread sleep  ; sw stop  ; Time  should be but is Time  => NOT ok  System out println sw getTime  ; suspend resume is like a pause where time counter doesn t continue So a following stop  call shouldn t increase the time counter should it ,In my opinion it is a bug that suspend acts as split if followed by stop ; see below: StopWatch sw = new StopWatch ; sw start ; Thread sleep ; sw suspend ; Time ok System out println sw getTime ; Thread sleep ; Time again ok System out println sw getTime ; sw resume ; Thread sleep ; sw suspend ; Time ok System out println sw getTime ; Thread sleep ; Time again ok System out println sw getTime ; Thread sleep ; sw stop ; Time should be but is Time => NOT ok System out println sw getTime ; suspend resume is like a pause where time counter doesn t continue So a following stop call shouldn t increase the time counter should it ,1
0,Closure,Identifier minus a negative number needs a space between the - s,None,None,None,1
0,Closure,ClassCastException during TypeCheck pass,None,None,None,1
0,Closure,Erroneous optimization in ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,combining  interface and multiple  extends can crash compiler,None,None,None,1
0,Math,FastMath max 50 0f -50 0f  => -50 0f; should be 50 0f,FastMath max 50 0f -50 0f  => -50 0f; should be 50 0f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat   because that has a bug too - it tests doubles not floats ,FastMath max  f  f  =>  f; should be  f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat   because that has a bug too  it tests doubles not floats ,FastMath max f f => f; should be f This is because the wrong variable is returned The bug was not detected by the test case testMinMaxFloat because that has a bug too it tests doubles not floats ,1
0,Math,NPE when calling SubLine intersection   with non-intersecting lines,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,1
0,Closure,Column-indicating caret is sometimes not in error output,None,None,None,1
0,Closure,Erroneous optimization in ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Closure,combining  interface and multiple  extends can crash compiler,None,None,None,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2 ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path1 GeneralPath path2  will thus return true for any pair of non-null GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path  will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,1
0,Math,NPE when calling SubLine intersection   with non-intersecting lines,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,1
0,Math,Fix and then deprecate isSupportXxxInclusive in RealDistribution interface,The conclusion from [1] was never implemented We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4 0 we should agree on a precise definition and fix the code to match it in the mean time The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite i e not infinite  not NaN value is returned [1] http: markmail org message dxuxh7eybl7xejde,The conclusion from [] was never implemented We should deprecate these properties from the RealDistribution interface but since removal will have to wait until   we should agree on a precise definition and fix the code to match it in the mean time The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite i e not infinite  not NaN value is returned [] http: markmail org message dxuxheyblxejde,The conclusion from [] was never implemented We should deprecate these properties from the RealDistribution interface but since removal will have to wait until we should agree on a precise definition and fix the code to match it in the mean time The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite i e not infinite not NaN value is returned [] http: markmail org message dxuxheyblxejde,1
0,Lang,StrBuilder contains usages of thisBuf length when they should use size,While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf length and unless I m mistaken they shouldn t ,While fixing LANG I noticed that there are two other places in StrBuilder that reference thisBuf length and unless I m mistaken they shouldn t ,While fixing LANG I noticed that there are two other places in StrBuilder that reference thisBuf length and unless I m mistaken they shouldn t ,1
0,Lang,DateUtils isSameLocalTime does not work correct,Hi I think I found a bug in the DateUtils class in the method isSameLocalTime Example: Calendar a = Calendar getInstance  ; a setTimeInMillis 1297364400000L ; Calendar b = Calendar getInstance  ; b setTimeInMillis 1297321200000L ; Assert assertFalse DateUtils isSameLocalTime a b ; This is because the method compares cal1 get Calendar HOUR  == cal2 get Calendar HOUR  but I think it has to be cal1 get Calendar HOUR OF DAY  == cal2 get Calendar HOUR OF DAY ,Hi I think I found a bug in the DateUtils class in the method isSameLocalTime Example: Calendar a = Calendar getInstance  ; a setTimeInMillis L ; Calendar b = Calendar getInstance  ; b setTimeInMillis L ; Assert assertFalse DateUtils isSameLocalTime a b ; This is because the method compares cal get Calendar HOUR  == cal get Calendar HOUR  but I think it has to be cal get Calendar HOUR OF DAY  == cal get Calendar HOUR OF DAY ,Hi I think I found a bug in the DateUtils class in the method isSameLocalTime Example: Calendar a = Calendar getInstance ; a setTimeInMillis L ; Calendar b = Calendar getInstance ; b setTimeInMillis L ; Assert assertFalse DateUtils isSameLocalTime a b ; This is because the method compares cal get Calendar HOUR == cal get Calendar HOUR but I think it has to be cal get Calendar HOUR OF DAY == cal get Calendar HOUR OF DAY ,1
0,Lang,StrBuilder appendFixedWidth does not handle nulls,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText has not been set ,1
0,Mockito,Can not Return deep stubs from generic method that returns generic type ,if I try to mock a generic method which a generic returntype where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it When you don t use deep stubs and a raw Supplier mock to pass around it works:,if I try to mock a generic method which a generic returntype where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it When you don t use deep stubs and a raw Supplier mock to pass around it works:,if I try to mock a generic method which a generic returntype where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it When you don t use deep stubs and a raw Supplier mock to pass around it works:,1
0,Closure,Codepoint U 007f appears raw in output,None,None,None,1
0,Closure,Codepoint U 007f appears raw in output,None,None,None,1
0,Chart,Potential NPE in AbstractCategoryItemRender getLegendItems  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null not if dataset = null ,1
0,Math,In stat Frequency getPct Object  uses getCumPct Comparable  instead of getPct Comparable ,Drop in Replacement of 1 2 with 2 0 not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v  deprecated replaced by { link  getPct Comparable } as of 2 0  Deprecated public double getPct Object v  { return getCumPct Comparable< >  v ; },Drop in Replacement of   with   not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v  deprecated replaced by { link  getPct Comparable } as of    Deprecated public double getPct Object v  { return getCumPct Comparable< >  v ; },Drop in Replacement of with not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v deprecated replaced by { link getPct Comparable } as of Deprecated public double getPct Object v { return getCumPct Comparable< > v ; },1
0,Math,Mann-Whitney U Test Suffers From Integer Overflow With Large Data Sets,When performing a Mann-Whitney U Test on large data sets the attached test uses two 1500 element sets  intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,When performing a MannWhitney U Test on large data sets the attached test uses two  element sets  intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as pvalues of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,When performing a MannWhitney U Test on large data sets the attached test uses two element sets intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as pvalues of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,1
0,Math,SimplexSolver not working as expected 2,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: 7 a 3 b; Constraints R1: 3 a -5 c <= 0; R2: 2 a -5 d <= 0; R3: 2 b -5 c <= 0; R4: 3 b -5 d <= 0; R5: 3 a 2 b <= 5; R6: 2 a 3 b <= 5; Variable bounds a <= 1; b <= 1; ===================== Results correct : a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {7 3 0 0} 0 ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {1 0 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {0 1 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {3 0 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {2 0 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 2 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 3 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {3 2 0 0} Relationship LEQ 5 ; podmienky add new LinearConstraint new double[] {2 3 0 0} Relationship LEQ 5 ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = 1 b = 0 5 value = 8 5 P S I used the latest software from the repository including MATH-286 fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max:  a  b; Constraints R:  a  c <= ; R:  a  d <= ; R:  b  c <= ; R:  b  d <= ; R:  a  b <= ; R:  a  b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a =  b =  value =  Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {   }  ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a =  b =   value =   P S I used the latest software from the repository including MATH fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: a b; Constraints R: a c <= ; R: a d <= ; R: b c <= ; R: b d <= ; R: a b <= ; R: a b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a = b = value = Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] { } ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint> ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; SimplexSolver solver = new SimplexSolver ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = b = value = P S I used the latest software from the repository including MATH fix ,1
0,Math,SimplexSolver not working as expected 2,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: 7 a 3 b; Constraints R1: 3 a -5 c <= 0; R2: 2 a -5 d <= 0; R3: 2 b -5 c <= 0; R4: 3 b -5 d <= 0; R5: 3 a 2 b <= 5; R6: 2 a 3 b <= 5; Variable bounds a <= 1; b <= 1; ===================== Results correct : a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {7 3 0 0} 0 ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {1 0 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {0 1 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {3 0 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {2 0 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 2 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 3 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {3 2 0 0} Relationship LEQ 5 ; podmienky add new LinearConstraint new double[] {2 3 0 0} Relationship LEQ 5 ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = 1 b = 0 5 value = 8 5 P S I used the latest software from the repository including MATH-286 fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max:  a  b; Constraints R:  a  c <= ; R:  a  d <= ; R:  b  c <= ; R:  b  d <= ; R:  a  b <= ; R:  a  b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a =  b =  value =  Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {   }  ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a =  b =   value =   P S I used the latest software from the repository including MATH fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: a b; Constraints R: a c <= ; R: a d <= ; R: b c <= ; R: b d <= ; R: a b <= ; R: a b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a = b = value = Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] { } ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint> ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; SimplexSolver solver = new SimplexSolver ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = b = value = P S I used the latest software from the repository including MATH fix ,1
0,Math,Complex ZERO reciprocal   returns NaN but should return INF ,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math3 complex Complex; Method: reciprocal    version Id: Complex java 1416643 2012-12-03 19:37:14Z tn,Complex ZERO reciprocal   returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal    version Id: Complex java   ::Z tn,Complex ZERO reciprocal returns NaN but should return INF Class: org apache commons math complex Complex; Method: reciprocal version Id: Complex java ::Z tn,1
0,Lang,StringIndexOutOfBoundsException in CharSequenceTranslator,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uD83D\uDE30 is a surrogate pair  Test public void testEscapeSurrogatePairs   throws Exception { assertEquals \uD83D\uDE30 StringEscapeUtils escapeCsv \uD83D\uDE30  ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range: 2 at java lang String charAt String java:658  at java lang Character codePointAt Character java:4668  at org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java:95  at org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java:59  at org apache commons lang3 StringEscapeUtils escapeCsv StringEscapeUtils java:556  Patch attached the method affected: public final void translate CharSequence input Writer out  throws IOException,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uDD\uDE is a surrogate pair  Test public void testEscapeSurrogatePairs   throws Exception { assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE  ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range:  at java lang String charAt String java:  at java lang Character codePointAt Character java:  at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java:  at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java:  at org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java:  Patch attached the method affected: public final void translate CharSequence input Writer out  throws IOException,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uDD\uDE is a surrogate pair Test public void testEscapeSurrogatePairs throws Exception { assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range: at java lang String charAt String java: at java lang Character codePointAt Character java: at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java: at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java: at org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java: Patch attached the method affected: public final void translate CharSequence input Writer out throws IOException,1
0,Chart,Fix for MultiplePiePlot,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,When dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called ,1
0,Chart,XYSeries addOrUpdate   should add if duplicates are allowed,I ve found a bug in jfreechart-1 0 9 code for org jfree data xy XYSeries There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data The method addOrUpdate Number x Number y  was never modified to support this and therefore duplicate data were overwriting existing data ,I ve found a bug in jfreechart   code for org jfree data xy XYSeries There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data The method addOrUpdate Number x Number y  was never modified to support this and therefore duplicate data were overwriting existing data ,I ve found a bug in jfreechart code for org jfree data xy XYSeries There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data The method addOrUpdate Number x Number y was never modified to support this and therefore duplicate data were overwriting existing data ,1
0,Math,GaussianFitter Unexpectedly Throws NotStrictlyPositiveException,Running the following: double[] observations = { 1 1143831578403364E-29 4 95281403484594E-28 1 1171347211930288E-26 1 7044813962636277E-25 1 9784716574832164E-24 1 8630236407866774E-23 1 4820532905097742E-22 1 0241963854632831E-21 6 275077366673128E-21 3 461808994532493E-20 1 7407124684715706E-19 8 056687953553974E-19 3 460193945992071E-18 1 3883326374011525E-17 5 233894983671116E-17 1 8630791465263745E-16 6 288759227922111E-16 2 0204433920597856E-15 6 198768938576155E-15 1 821419346860626E-14 5 139176445538471E-14 1 3956427429045787E-13 3 655705706448139E-13 9 253753324779779E-13 2 267636001476696E-12 5 3880460095836855E-12 1 2431632654852931E-11 } ; GaussianFitter g = new GaussianFitter new LevenbergMarquardtOptimizer  ; for int index = 0; index < 27; index   { g addObservedPoint index observations[index] ; } g fit  ; Results in: org apache commons math exception NotStrictlyPositiveException: -1 277 is smaller than or equal to the minimum 0  at org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java:184  at org apache commons math analysis function Gaussian Parametric value Gaussian java:129  I m guessing the initial guess for sigma is off ,Running the following: double[] observations = {  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E  E } ; GaussianFitter g = new GaussianFitter new LevenbergMarquardtOptimizer  ; for int index = ; index < ; index   { g addObservedPoint index observations[index] ; } g fit  ; Results in: org apache commons math exception NotStrictlyPositiveException:   is smaller than or equal to the minimum   at org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java:  at org apache commons math analysis function Gaussian Parametric value Gaussian java:  I m guessing the initial guess for sigma is off ,Running the following: double[] observations = { E E E E E E E E E E E E E E E E E E E E E E E E E E E } ; GaussianFitter g = new GaussianFitter new LevenbergMarquardtOptimizer ; for int index = ; index < ; index { g addObservedPoint index observations[index] ; } g fit ; Results in: org apache commons math exception NotStrictlyPositiveException: is smaller than or equal to the minimum at org apache commons math analysis function Gaussian Parametric validateParameters Gaussian java: at org apache commons math analysis function Gaussian Parametric value Gaussian java: I m guessing the initial guess for sigma is off ,1
0,Math,Brent solver doesn t throw IllegalArgumentException when initial guess has the wrong sign,Javadoc for public double solve final UnivariateRealFunction f final double min final double max final double initial  claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown This case isn t even checked ,Javadoc for public double solve final UnivariateRealFunction f final double min final double max final double initial  claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown This case isn t even checked ,Javadoc for public double solve final UnivariateRealFunction f final double min final double max final double initial claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown This case isn t even checked ,1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line 640 in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line  in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,1
0,Math,Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the same,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to 1 1  ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to    ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to ,1
0,Math,too large first step with embedded Runge-Kutta integrators Dormand-Prince 8 5 3   ,Adaptive step size integrators compute the first step size by themselves if it is not provided For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range and in fact it tries afterward to go back and fails to stop  Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed ,Adaptive step size integrators compute the first step size by themselves if it is not provided For embedded RungeKutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range and in fact it tries afterward to go back and fails to stop  GraggBulirschStoer integrators do not have this problem the step size is checked and truncated if needed ,Adaptive step size integrators compute the first step size by themselves if it is not provided For embedded RungeKutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range and in fact it tries afterward to go back and fails to stop GraggBulirschStoer integrators do not have this problem the step size is checked and truncated if needed ,1
0,Time,possibly a bug in org joda time field FieldUtils safeMultiply,It seems to me that as currently written in joda-time-2 1 jar org joda time field FieldUtils safeMultiply long val1 int scalar  doesn t detect the overflow if the long val1 == Long MIN VALUE and the int scalar == -1 The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,It seems to me that as currently written in jodatime  jar org joda time field FieldUtils safeMultiply long val int scalar  doesn t detect the overflow if the long val == Long MIN VALUE and the int scalar ==  The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,It seems to me that as currently written in jodatime jar org joda time field FieldUtils safeMultiply long val int scalar doesn t detect the overflow if the long val == Long MIN VALUE and the int scalar == The attached file demonstrates what I think is the bug and suggests a patch I looked at the Joda Time bugs list in SourceForge but couldn t see anything that looked relevant ,1
0,Lang,ArrayUtils add T[] array T element  can create unexpected ClassCastException,ArrayUtils add T[] array T element  can create an unexpected ClassCastException For example the following code compiles without a warning: String[] sa = ArrayUtils add stringArray aString ; and works fine provided at least one of the parameters is non-null However if both parameters are null the add   method returns an Object[] array hence the Exception If both parameters are null it s not possible to determine the correct array type to return so it seems to me this should be disallowed I think the method ought to be changed to throw IllegalParameterException when both parameters are null ,ArrayUtils add T[] array T element  can create an unexpected ClassCastException For example the following code compiles without a warning: String[] sa = ArrayUtils add stringArray aString ; and works fine provided at least one of the parameters is nonnull However if both parameters are null the add   method returns an Object[] array hence the Exception If both parameters are null it s not possible to determine the correct array type to return so it seems to me this should be disallowed I think the method ought to be changed to throw IllegalParameterException when both parameters are null ,ArrayUtils add T[] array T element can create an unexpected ClassCastException For example the following code compiles without a warning: String[] sa = ArrayUtils add stringArray aString ; and works fine provided at least one of the parameters is nonnull However if both parameters are null the add method returns an Object[] array hence the Exception If both parameters are null it s not possible to determine the correct array type to return so it seems to me this should be disallowed I think the method ought to be changed to throw IllegalParameterException when both parameters are null ,1
0,Lang,StringUtils join throws NPE when toString returns null for one of objects in collection,Try StringUtils join new Object[]{ new Object   {  Override public String toString   { return null; } } }  ; ToString should probably never return null but it does in javax mail internet InternetAddress,Try StringUtils join new Object[]{ new Object   {  Override public String toString   { return null; } } }  ; ToString should probably never return null but it does in javax mail internet InternetAddress,Try StringUtils join new Object[]{ new Object { Override public String toString { return null; } } } ; ToString should probably never return null but it does in javax mail internet InternetAddress,1
0,Lang,WordUtils abbreviate bug when lower is greater than str length,In WordUtils abbreviate upper is adjusted to the length of the string then to lower But lower is never adjusted to the length of the string so if lower is greater than str lengt   upper will be too Then str substring 0 upper  throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string,In WordUtils abbreviate upper is adjusted to the length of the string then to lower But lower is never adjusted to the length of the string so if lower is greater than str lengt   upper will be too Then str substring  upper  throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string,In WordUtils abbreviate upper is adjusted to the length of the string then to lower But lower is never adjusted to the length of the string so if lower is greater than str lengt upper will be too Then str substring upper throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string,1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Math,Need range checks for elitismRate in ElitisticListPopulation constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,1
0,Math,Brent solver doesn t throw IllegalArgumentException when initial guess has the wrong sign,Javadoc for public double solve final UnivariateRealFunction f final double min final double max final double initial  claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown This case isn t even checked ,Javadoc for public double solve final UnivariateRealFunction f final double min final double max final double initial  claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown This case isn t even checked ,Javadoc for public double solve final UnivariateRealFunction f final double min final double max final double initial claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown This case isn t even checked ,1
0,Lang,NumberUtils createNumber throws NumberFormatException for one digit long,NumberUtils createNumber throws a NumberFormatException when parsing 1l 2l etc It works fine if you try to parse 01l or 02l The condition isDigits numeric substring 1  line 455 return false as numeric substring 1  is an empty string for 1l ,NumberUtils createNumber throws a NumberFormatException when parsing l l etc It works fine if you try to parse l or l The condition isDigits numeric substring   line  return false as numeric substring   is an empty string for l ,NumberUtils createNumber throws a NumberFormatException when parsing l l etc It works fine if you try to parse l or l The condition isDigits numeric substring line return false as numeric substring is an empty string for l ,1
0,Lang,NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in ,Seems to be similar to LANG-300 except that if you don t place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead ,Seems to be similar to LANG except that if you don t place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead ,Seems to be similar to LANG except that if you don t place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead ,1
0,Lang,StopWatch: suspend   acts as split   if followed by stop  ,In my opinion it is a bug that suspend   acts as split   if followed by stop  ; see below: StopWatch sw = new StopWatch  ; sw start  ; Thread sleep 1000 ; sw suspend  ; Time 1 ok  System out println sw getTime  ; Thread sleep 2000 ; Time 1 again ok  System out println sw getTime  ; sw resume  ; Thread sleep 3000 ; sw suspend  ; Time 2 ok  System out println sw getTime  ; Thread sleep 4000 ; Time 2 again ok  System out println sw getTime  ; Thread sleep 5000 ; sw stop  ; Time 2 should be but is Time 3 => NOT ok  System out println sw getTime  ; suspend resume is like a pause where time counter doesn t continue So a following stop  -call shouldn t increase the time counter should it ,In my opinion it is a bug that suspend   acts as split   if followed by stop  ; see below: StopWatch sw = new StopWatch  ; sw start  ; Thread sleep  ; sw suspend  ; Time  ok  System out println sw getTime  ; Thread sleep  ; Time  again ok  System out println sw getTime  ; sw resume  ; Thread sleep  ; sw suspend  ; Time  ok  System out println sw getTime  ; Thread sleep  ; Time  again ok  System out println sw getTime  ; Thread sleep  ; sw stop  ; Time  should be but is Time  => NOT ok  System out println sw getTime  ; suspend resume is like a pause where time counter doesn t continue So a following stop  call shouldn t increase the time counter should it ,In my opinion it is a bug that suspend acts as split if followed by stop ; see below: StopWatch sw = new StopWatch ; sw start ; Thread sleep ; sw suspend ; Time ok System out println sw getTime ; Thread sleep ; Time again ok System out println sw getTime ; sw resume ; Thread sleep ; sw suspend ; Time ok System out println sw getTime ; Thread sleep ; Time again ok System out println sw getTime ; Thread sleep ; sw stop ; Time should be but is Time => NOT ok System out println sw getTime ; suspend resume is like a pause where time counter doesn t continue So a following stop call shouldn t increase the time counter should it ,1
0,Lang,NumberUtils isNumber String  is not right when the String is 1 1L , 1 1L is not a Java Number but NumberUtils isNumber String  return true perhaps change: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp; } to: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp   hasDecPoint; },  L is not a Java Number but NumberUtils isNumber String  return true perhaps change: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp; } to: if chars[i] == l || chars[i] == L   { not allowing L with an exponent return foundDigit   hasExp   hasDecPoint; }, L is not a Java Number but NumberUtils isNumber String return true perhaps change: if chars[i] == l || chars[i] == L { not allowing L with an exponent return foundDigit hasExp; } to: if chars[i] == l || chars[i] == L { not allowing L with an exponent return foundDigit hasExp hasDecPoint; },1
0,Closure,Codepoint U 007f appears raw in output,None,None,None,1
0,Closure,Identifier minus a negative number needs a space between the - s,None,None,None,1
0,Chart,JCommon 1 0 12 ShapeUtilities equal path1 path2 ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path1 GeneralPath path2  will thus return true for any pair of non-null GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path  will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,The comparison of two GeneralPath objects uses the same PathIterator for both objects equal GeneralPath path GeneralPath path will thus return true for any pair of nonnull GeneralPath instances having the same windingRule ,1
0,Math,SimplexSolver gives bad results,Methode SimplexSolver optimeze   gives bad results with commons-math3-3 0 in a simple test problem It works well in commons-math-2 2 ,Methode SimplexSolver optimeze   gives bad results with commonsmath  in a simple test problem It works well in commonsmath  ,Methode SimplexSolver optimeze gives bad results with commonsmath in a simple test problem It works well in commonsmath ,1
0,Math,In stat Frequency getPct Object  uses getCumPct Comparable  instead of getPct Comparable ,Drop in Replacement of 1 2 with 2 0 not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v  deprecated replaced by { link  getPct Comparable } as of 2 0  Deprecated public double getPct Object v  { return getCumPct Comparable< >  v ; },Drop in Replacement of   with   not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v  deprecated replaced by { link  getPct Comparable } as of    Deprecated public double getPct Object v  { return getCumPct Comparable< >  v ; },Drop in Replacement of with not possible because all getPct calls will be cummulative without code change Frequency java Returns the percentage of values that are equal to v deprecated replaced by { link getPct Comparable } as of Deprecated public double getPct Object v { return getCumPct Comparable< > v ; },1
0,Math,Mann-Whitney U Test Suffers From Integer Overflow With Large Data Sets,When performing a Mann-Whitney U Test on large data sets the attached test uses two 1500 element sets  intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,When performing a MannWhitney U Test on large data sets the attached test uses two  element sets  intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as pvalues of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,When performing a MannWhitney U Test on large data sets the attached test uses two element sets intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as pvalues of NaN or incorrect calculations Attached is a patch including a test and a fix which modifies the affected code to use doubles,1
0,Math,BisectionSolver solve final UnivariateRealFunction f double min double max double initial  throws NullPointerException,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial  invokes BisectionSolver solve double min double max  which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max  should be called Steps to reproduce: invoke: new BisectionSolver   solve someUnivariateFunctionImpl 0 0 1 0 0 5 ; NullPointerException will be thrown ,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial  invokes BisectionSolver solve double min double max  which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max  should be called Steps to reproduce: invoke: new BisectionSolver   solve someUnivariateFunctionImpl       ; NullPointerException will be thrown ,Method BisectionSolver solve final UnivariateRealFunction f double min double max double initial invokes BisectionSolver solve double min double max which throws NullPointerException as member variable UnivariateRealSolverImpl f is null Instead the method: BisectionSolver solve final UnivariateRealFunction f double min double max should be called Steps to reproduce: invoke: new BisectionSolver solve someUnivariateFunctionImpl ; NullPointerException will be thrown ,1
0,Time,Inconsistent interpretation of ambiguous time during DST,The inconsistency appears for timezone Europe London These three DateTime objects should all represent the same moment in time even if they are ambiguous Now it always returns the earlier instant summer time  during an overlap ,The inconsistency appears for timezone Europe London These three DateTime objects should all represent the same moment in time even if they are ambiguous Now it always returns the earlier instant summer time  during an overlap ,The inconsistency appears for timezone Europe London These three DateTime objects should all represent the same moment in time even if they are ambiguous Now it always returns the earlier instant summer time during an overlap ,1
0,Lang,BooleanUtils toBoolean   - invalid drop-thru in case statement causes StringIndexOutOfBoundsException,The method BooleanUtils toBoolean   has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case 3 should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean   has a case statement; case  drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru  ; The end of case  should return false Patch to follow for source and unit test ,The method BooleanUtils toBoolean has a case statement; case drops through to case ; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals false BooleanUtils toBoolean tru ; The end of case should return false Patch to follow for source and unit test ,1
0,Lang,StringIndexOutOfBoundsException in CharSequenceTranslator,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uD83D\uDE30 is a surrogate pair  Test public void testEscapeSurrogatePairs   throws Exception { assertEquals \uD83D\uDE30 StringEscapeUtils escapeCsv \uD83D\uDE30  ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range: 2 at java lang String charAt String java:658  at java lang Character codePointAt Character java:4668  at org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java:95  at org apache commons lang3 text translate CharSequenceTranslator translate CharSequenceTranslator java:59  at org apache commons lang3 StringEscapeUtils escapeCsv StringEscapeUtils java:556  Patch attached the method affected: public final void translate CharSequence input Writer out  throws IOException,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uDD\uDE is a surrogate pair  Test public void testEscapeSurrogatePairs   throws Exception { assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE  ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range:  at java lang String charAt String java:  at java lang Character codePointAt Character java:  at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java:  at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java:  at org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java:  Patch attached the method affected: public final void translate CharSequence input Writer out  throws IOException,I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem \uDD\uDE is a surrogate pair Test public void testEscapeSurrogatePairs throws Exception { assertEquals \uDD\uDE StringEscapeUtils escapeCsv \uDD\uDE ; } You ll get the exception as shown below java lang StringIndexOutOfBoundsException: String index out of range: at java lang String charAt String java: at java lang Character codePointAt Character java: at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java: at org apache commons lang text translate CharSequenceTranslator translate CharSequenceTranslator java: at org apache commons lang StringEscapeUtils escapeCsv StringEscapeUtils java: Patch attached the method affected: public final void translate CharSequence input Writer out throws IOException,1
0,Closure,Classify non-rightmost expressions as problematic,None,None,None,1
0,Closure,Break in finally block isn t optimized properly,None,None,None,1
0,Closure,Classify non-rightmost expressions as problematic,None,None,None,1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Lang,NumberUtils createNumber - bad behaviour for leading -- ,NumberUtils createNumber checks for a leading -- in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading  in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,NumberUtils createNumber checks for a leading in the string and returns null if found This is documented as a work round for a bug in BigDecimal Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException It s not clear whether the BigDecimal problem still exists with recent versions of Java However if it does exist then the check needs to be done for all invocations of BigDecimal i e needs to be moved to createBigDecimal ,1
0,Lang,FastDateParser does not handle white-space properly,The SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,The SimpleDateFormat Javadoc does not treat whitespace specially however FastDateParser treats a single whitespace as being any number of whitespace characters This means that FDP will parse dates that fail when parsed by SDP ,1
0,Closure,compiler crashes when goog provide used with non string,None,None,None,1
0,Closure,Erroneous optimization in ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,Math, RegulaFalsiSolver failure,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } fails with illegal state: maximal count 100  exceeded: evaluations Using PegasusSolver the answer is found after 17 evaluations ,The following unit test:  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } fails with illegal state: maximal count   exceeded: evaluations Using PegasusSolver the answer is found after  evaluations ,The following unit test: Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } fails with illegal state: maximal count exceeded: evaluations Using PegasusSolver the answer is found after evaluations ,1
0,Math,Need range checks for elitismRate in ElitisticListPopulation constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,There is a range check for setting the elitismRate via ElitisticListPopulation s setElitismRate method but not via the constructors ,1
0,Math,RealMatrixImpl operate gets result vector dimensions wrong,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line 640 in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line  in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,org apache commons math linear RealMatrixImpl operate tries to create a result vector that always has the same length as the input vector This can result in runtime exceptions if the matrix is nonsquare and it always yields incorrect results if the matrix is nonsquare The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix Thus line in RealMatrixImpl java should read double[] out = new double[nRows]; instead of double[] out = new double[v length];,1
0,Math,Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the same,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to 1 1  ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link  NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to    ,For both Complex add and subtract the javadoc states that If either this or <code>rhs< code> has a NaN value in either part { link NaN} is returned; otherwise Inifinite and NaN values are returned in the parts of the result according to the rules for { link java lang Double} arithmetic Subtract includes an isNaN test and returns Complex NaN if either complex argument isNaN; but add omits this test The test should be added to the add implementation actually restored since this looks like a code merge problem going back to ,1
0,Math,NaN in equals methods,In MathUtils some equals methods will return true if both argument are NaN Unless I m mistaken this contradicts the IEEE standard If nobody objects I m going to make the changes ,In MathUtils some equals methods will return true if both argument are NaN Unless I m mistaken this contradicts the IEEE standard If nobody objects I m going to make the changes ,In MathUtils some equals methods will return true if both argument are NaN Unless I m mistaken this contradicts the IEEE standard If nobody objects I m going to make the changes ,1
0,Math,NPE in KMeansPlusPlusClusterer unittest,When running this unittest I am facing this NPE: java lang NullPointerException at org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java:91  This is the unittest: package org fao fisheries chronicles calcuation cluster; import static org junit Assert assertEquals; import static org junit Assert assertTrue; import java util Arrays; import java util List; import java util Random; import org apache commons math stat clustering Cluster; import org apache commons math stat clustering EuclideanIntegerPoint; import org apache commons math stat clustering KMeansPlusPlusClusterer; import org fao fisheries chronicles input CsvImportProcess; import org fao fisheries chronicles input Top200Csv; import org junit Test; public class ClusterAnalysisTest {  Test public void testPerformClusterAnalysis2   { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint> new Random 1746432956321l ; EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { new EuclideanIntegerPoint new int[] { 1959 325100 }   new EuclideanIntegerPoint new int[] { 1960 373200 }   }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer cluster Arrays asList points  1 1 ; assertEquals 1 clusters size  ; } },When running this unittest I am facing this NPE: java lang NullPointerException at org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java:  This is the unittest: package org fao fisheries chronicles calcuation cluster; import static org junit Assert assertEquals; import static org junit Assert assertTrue; import java util Arrays; import java util List; import java util Random; import org apache commons math stat clustering Cluster; import org apache commons math stat clustering EuclideanIntegerPoint; import org apache commons math stat clustering KMeansPlusPlusClusterer; import org fao fisheries chronicles input CsvImportProcess; import org fao fisheries chronicles input TopCsv; import org junit Test; public class ClusterAnalysisTest {  Test public void testPerformClusterAnalysis   { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint> new Random l ; EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { new EuclideanIntegerPoint new int[] {   }   new EuclideanIntegerPoint new int[] {   }   }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer cluster Arrays asList points    ; assertEquals  clusters size  ; } },When running this unittest I am facing this NPE: java lang NullPointerException at org apache commons math stat clustering KMeansPlusPlusClusterer assignPointsToClusters KMeansPlusPlusClusterer java: This is the unittest: package org fao fisheries chronicles calcuation cluster; import static org junit Assert assertEquals; import static org junit Assert assertTrue; import java util Arrays; import java util List; import java util Random; import org apache commons math stat clustering Cluster; import org apache commons math stat clustering EuclideanIntegerPoint; import org apache commons math stat clustering KMeansPlusPlusClusterer; import org fao fisheries chronicles input CsvImportProcess; import org fao fisheries chronicles input TopCsv; import org junit Test; public class ClusterAnalysisTest { Test public void testPerformClusterAnalysis { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint> new Random l ; EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { new EuclideanIntegerPoint new int[] { } new EuclideanIntegerPoint new int[] { } }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer cluster Arrays asList points ; assertEquals clusters size ; } },1
0,Math,One of Variance evaluate   methods does not work correctly,The method org apache commons math stat descriptive moment Variance evaluate double[] values double[] weights double mean int begin int length  does not work properly Looks loke it ignores the length parameter and grabs the whole dataset Similar method in Mean class seems to work I did not check other methods taking the part of the array; they may have the same problem Workaround: I had to shrink my arrays and use the method without the length ,The method org apache commons math stat descriptive moment Variance evaluate double[] values double[] weights double mean int begin int length  does not work properly Looks loke it ignores the length parameter and grabs the whole dataset Similar method in Mean class seems to work I did not check other methods taking the part of the array; they may have the same problem Workaround: I had to shrink my arrays and use the method without the length ,The method org apache commons math stat descriptive moment Variance evaluate double[] values double[] weights double mean int begin int length does not work properly Looks loke it ignores the length parameter and grabs the whole dataset Similar method in Mean class seems to work I did not check other methods taking the part of the array; they may have the same problem Workaround: I had to shrink my arrays and use the method without the length ,1
0,Math,ODE integrator goes past specified end of integration range,End of integration range in ODE solving is handled as an event In some cases numerical accuracy in events detection leads to error in events location The following test case shows the end event is not handled properly and an integration that should cover a 60s range in fact covers a 160s range more than twice the specified range public void testMissedEvent   throws IntegratorException DerivativeException { final double t0 = 1878250320 0000029; final double t = 1878250379 9999986; FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations   { public int getDimension   { return 1; } public void computeDerivatives double t double[] y double[] yDot  throws DerivativeException { yDot[0] = y[0] 1 0e-6; } }; DormandPrince853Integrator integrator = new DormandPrince853Integrator 0 0 100 0 1 0e-10 1 0e-10 ; double[] y = { 1 0 }; integrator setInitialStepSize 60 0 ; double finalT = integrator integrate ode t0 y t y ; Assert assertEquals t finalT 1 0e-6 ; },End of integration range in ODE solving is handled as an event In some cases numerical accuracy in events detection leads to error in events location The following test case shows the end event is not handled properly and an integration that should cover a s range in fact covers a s range more than twice the specified range public void testMissedEvent   throws IntegratorException DerivativeException { final double t =  ; final double t =  ; FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations   { public int getDimension   { return ; } public void computeDerivatives double t double[] y double[] yDot  throws DerivativeException { yDot[] = y[]  e; } }; DormandPrinceIntegrator integrator = new DormandPrinceIntegrator      e  e ; double[] y = {   }; integrator setInitialStepSize   ; double finalT = integrator integrate ode t y t y ; Assert assertEquals t finalT  e ; },End of integration range in ODE solving is handled as an event In some cases numerical accuracy in events detection leads to error in events location The following test case shows the end event is not handled properly and an integration that should cover a s range in fact covers a s range more than twice the specified range public void testMissedEvent throws IntegratorException DerivativeException { final double t = ; final double t = ; FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations { public int getDimension { return ; } public void computeDerivatives double t double[] y double[] yDot throws DerivativeException { yDot[] = y[] e; } }; DormandPrinceIntegrator integrator = new DormandPrinceIntegrator e e ; double[] y = { }; integrator setInitialStepSize ; double finalT = integrator integrate ode t y t y ; Assert assertEquals t finalT e ; },1
0,Lang,FastDateFormat getDateInstance   and getDateTimeInstance   assume Locale getDefault   won t change,The FastDateFormat getDateInstance   and getDateTimeInstance   methods create the HashMap key from various items including the locale If the locale is null then it is not made part of the key but the stored object is created using the current default locale If the Locale is changed subsequently then the wrong locale is applied Patch for test case to follow ,The FastDateFormat getDateInstance   and getDateTimeInstance   methods create the HashMap key from various items including the locale If the locale is null then it is not made part of the key but the stored object is created using the current default locale If the Locale is changed subsequently then the wrong locale is applied Patch for test case to follow ,The FastDateFormat getDateInstance and getDateTimeInstance methods create the HashMap key from various items including the locale If the locale is null then it is not made part of the key but the stored object is created using the current default locale If the Locale is changed subsequently then the wrong locale is applied Patch for test case to follow ,1
0,Lang,NumberUtils createNumber throws NumberFormatException for one digit long,NumberUtils createNumber throws a NumberFormatException when parsing 1l 2l etc It works fine if you try to parse 01l or 02l The condition isDigits numeric substring 1  line 455 return false as numeric substring 1  is an empty string for 1l ,NumberUtils createNumber throws a NumberFormatException when parsing l l etc It works fine if you try to parse l or l The condition isDigits numeric substring   line  return false as numeric substring   is an empty string for l ,NumberUtils createNumber throws a NumberFormatException when parsing l l etc It works fine if you try to parse l or l The condition isDigits numeric substring line return false as numeric substring is an empty string for l ,1
0,Lang,ClassUtils toClass Object[]  throws NPE on null array element,see summary,see summary,see summary,1
0,Lang,NumberUtils does not handle upper-case hex: 0X and -0X,NumberUtils createNumber   should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer decode   handles both upper and lower case hex ,NumberUtils createNumber   should work equally for x and X; currently X generates a NumberFormatException Integer decode   handles both upper and lower case hex ,NumberUtils createNumber should work equally for x and X; currently X generates a NumberFormatException Integer decode handles both upper and lower case hex ,1
0,Lang,StringUtils replaceEach - Bug or Missing Documentation,The following Test Case for replaceEach fails with a null pointer exception I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null I admit the use case is not perfect because it is unclear what happens on the replace I outlined three expectations in the test case of course only one should be met If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string import static org junit Assert assertEquals; import org apache commons lang StringUtils; import org junit Test; public class StringUtilsTest {  Test public void replaceEach  { String original = Hello World ; String[] searchList = { Hello World }; String[] replacementList = { Greetings null}; String result = StringUtils replaceEach original searchList replacementList ; assertEquals Greetings result ; perhaps this is ok as well assertEquals Greetings World result ; or even assertEquals Greetings null result ; } },The following Test Case for replaceEach fails with a null pointer exception I have expected that all StringUtils methods are nullfriendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null I admit the use case is not perfect because it is unclear what happens on the replace I outlined three expectations in the test case of course only one should be met If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string import static org junit Assert assertEquals; import org apache commons lang StringUtils; import org junit Test; public class StringUtilsTest {  Test public void replaceEach  { String original = Hello World ; String[] searchList = { Hello World }; String[] replacementList = { Greetings null}; String result = StringUtils replaceEach original searchList replacementList ; assertEquals Greetings result ; perhaps this is ok as well assertEquals Greetings World result ; or even assertEquals Greetings null result ; } },The following Test Case for replaceEach fails with a null pointer exception I have expected that all StringUtils methods are nullfriendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null I admit the use case is not perfect because it is unclear what happens on the replace I outlined three expectations in the test case of course only one should be met If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string import static org junit Assert assertEquals; import org apache commons lang StringUtils; import org junit Test; public class StringUtilsTest { Test public void replaceEach { String original = Hello World ; String[] searchList = { Hello World }; String[] replacementList = { Greetings null}; String result = StringUtils replaceEach original searchList replacementList ; assertEquals Greetings result ; perhaps this is ok as well assertEquals Greetings World result ; or even assertEquals Greetings null result ; } },1
0,Chart,Bug propgated from v1 0 5 on to present,The method getRowCount   in class org jfree data category DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset possibly zero  The implementation from v1 0 5 on no longer checks for a null condition which would then return a zero  on the seriesKeys as it did in v1 0 4 and previous This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount   method is called ,The method getRowCount   in class org jfree data category DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset possibly zero  The implementation from v   on no longer checks for a null condition which would then return a zero  on the seriesKeys as it did in v   and previous This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount   method is called ,The method getRowCount in class org jfree data category DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset possibly zero The implementation from v on no longer checks for a null condition which would then return a zero on the seriesKeys as it did in v and previous This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount method is called ,1
0,Chart,Bug propgated from v1 0 5 on to present,The method getRowCount   in class org jfree data category DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset possibly zero  The implementation from v1 0 5 on no longer checks for a null condition which would then return a zero  on the seriesKeys as it did in v1 0 4 and previous This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount   method is called ,The method getRowCount   in class org jfree data category DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset possibly zero  The implementation from v   on no longer checks for a null condition which would then return a zero  on the seriesKeys as it did in v   and previous This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount   method is called ,The method getRowCount in class org jfree data category DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset possibly zero The implementation from v on no longer checks for a null condition which would then return a zero on the seriesKeys as it did in v and previous This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount method is called ,1
0,Math,NPE when calling SubLine intersection   with non-intersecting lines,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,1
0,Math,NPE when calling SubLine intersection   with non-intersecting lines,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection   with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace   This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,When calling SubLine intersection with two lines that not intersect then a NullPointerException is thrown in Line toSubSpace This bug is in the twod and threed implementations The attached patch fixes both implementations and adds the required test cases ,1
0,Lang,NullPointerException in isAvailableLocale Locale ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source  and if availableLocaleSet   hasn t been called it will cause a NullPointerException ,FindBugs pointed out: UwF: Field not initialized in constructor: org apache commons lang LocaleUtils cAvailableLocaleSet cAvailableSet is used directly once in the source and if availableLocaleSet hasn t been called it will cause a NullPointerException ,1
0,Lang,ClassUtils toClass Object[]  throws NPE on null array element,see summary,see summary,see summary,1
0,Lang,StringUtils join throws NPE when toString returns null for one of objects in collection,Try StringUtils join new Object[]{ new Object   {  Override public String toString   { return null; } } }  ; ToString should probably never return null but it does in javax mail internet InternetAddress,Try StringUtils join new Object[]{ new Object   {  Override public String toString   { return null; } } }  ; ToString should probably never return null but it does in javax mail internet InternetAddress,Try StringUtils join new Object[]{ new Object { Override public String toString { return null; } } } ; ToString should probably never return null but it does in javax mail internet InternetAddress,1
0,Lang,StringUtils join throws NPE when toString returns null for one of objects in collection,Try StringUtils join new Object[]{ new Object   {  Override public String toString   { return null; } } }  ; ToString should probably never return null but it does in javax mail internet InternetAddress,Try StringUtils join new Object[]{ new Object   {  Override public String toString   { return null; } } }  ; ToString should probably never return null but it does in javax mail internet InternetAddress,Try StringUtils join new Object[]{ new Object { Override public String toString { return null; } } } ; ToString should probably never return null but it does in javax mail internet InternetAddress,1
0,Lang,StringUtils replaceEach - Bug or Missing Documentation,The following Test Case for replaceEach fails with a null pointer exception I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null I admit the use case is not perfect because it is unclear what happens on the replace I outlined three expectations in the test case of course only one should be met If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string import static org junit Assert assertEquals; import org apache commons lang StringUtils; import org junit Test; public class StringUtilsTest {  Test public void replaceEach  { String original = Hello World ; String[] searchList = { Hello World }; String[] replacementList = { Greetings null}; String result = StringUtils replaceEach original searchList replacementList ; assertEquals Greetings result ; perhaps this is ok as well assertEquals Greetings World result ; or even assertEquals Greetings null result ; } },The following Test Case for replaceEach fails with a null pointer exception I have expected that all StringUtils methods are nullfriendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null I admit the use case is not perfect because it is unclear what happens on the replace I outlined three expectations in the test case of course only one should be met If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string import static org junit Assert assertEquals; import org apache commons lang StringUtils; import org junit Test; public class StringUtilsTest {  Test public void replaceEach  { String original = Hello World ; String[] searchList = { Hello World }; String[] replacementList = { Greetings null}; String result = StringUtils replaceEach original searchList replacementList ; assertEquals Greetings result ; perhaps this is ok as well assertEquals Greetings World result ; or even assertEquals Greetings null result ; } },The following Test Case for replaceEach fails with a null pointer exception I have expected that all StringUtils methods are nullfriendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null I admit the use case is not perfect because it is unclear what happens on the replace I outlined three expectations in the test case of course only one should be met If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string import static org junit Assert assertEquals; import org apache commons lang StringUtils; import org junit Test; public class StringUtilsTest { Test public void replaceEach { String original = Hello World ; String[] searchList = { Hello World }; String[] replacementList = { Greetings null}; String result = StringUtils replaceEach original searchList replacementList ; assertEquals Greetings result ; perhaps this is ok as well assertEquals Greetings World result ; or even assertEquals Greetings null result ; } },1
0,Lang,StrBuilder appendFixedWidth does not handle nulls,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText has not been set ,1
0,Lang,StrBuilder appendFixedWidth does not handle nulls,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText   has not been set ,Appending a null value with fixed width causes a null pointer exception if getNullText has not been set ,1
0,Closure,Column-indicating caret is sometimes not in error output,None,None,None,1
0,Chart,Potential NPE in AbstractCategoryItemRender getLegendItems  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null  not if dataset = null  ,Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender java The warning is in the last code line where seriesCount is assigned The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if dataset == null not if dataset = null ,1
0,Math,bug in inverseCumulativeProbability   for Normal Distribution, version Revision: 617953 Date: 2008-02-02 22:54:00 -0700 Sat 02 Feb 2008  public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision: 506600 Date: 2007-02-12 12:35:59 -0700 Mon 12 Feb 2007  public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution 0 1 ; double result = normal inverseCumulativeProbability 0 9772498680518209 ; gives the exception below It should return approx  2 0000 normal inverseCumulativeProbability 0 977249868051820 ; works fine These also give errors: 0 9986501019683698 should return 3 0000   0 9999683287581673 should return 4 0000   org apache commons math MathException: Number of iterations=1 maximum iterations=2 147 483 647 initial=1 lower bound=0 upper bound=179 769 313 486 231 570 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 final a value=0 final b value=2 f a =-0 477 f b =0 at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:103  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java:145 , version Revision:  Date:  ::  Sat  Feb   public class NormalDistributionImpl extends AbstractContinuousDistribution  version Revision:  Date:  ::  Mon  Feb   public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory  ; NormalDistribution normal = factory createNormalDistribution   ; double result = normal inverseCumulativeProbability   ; gives the exception below It should return approx    normal inverseCumulativeProbability   ; works fine These also give errors:   should return       should return     org apache commons math MathException: Number of iterations= maximum iterations=    initial= lower bound= upper bound=                                                                                                       final a value= final b value= f a =  f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java:  at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: , version Revision: Date: :: Sat Feb public class NormalDistributionImpl extends AbstractContinuousDistribution version Revision: Date: :: Mon Feb public abstract class AbstractContinuousDistribution This code: DistributionFactory factory = app getDistributionFactory ; NormalDistribution normal = factory createNormalDistribution ; double result = normal inverseCumulativeProbability ; gives the exception below It should return approx normal inverseCumulativeProbability ; works fine These also give errors: should return should return org apache commons math MathException: Number of iterations= maximum iterations= initial= lower bound= upper bound= final a value= final b value= f a = f b = at org apache commons math distribution AbstractContinuousDistribution inverseCumulativeProbability AbstractContinuousDistribution java: at org apache commons math distribution NormalDistributionImpl inverseCumulativeProbability NormalDistributionImpl java: ,1
0,Math,SimplexSolver not working as expected 2,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: 7 a 3 b; Constraints R1: 3 a -5 c <= 0; R2: 2 a -5 d <= 0; R3: 2 b -5 c <= 0; R4: 3 b -5 d <= 0; R5: 3 a 2 b <= 5; R6: 2 a 3 b <= 5; Variable bounds a <= 1; b <= 1; ===================== Results correct : a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {7 3 0 0} 0 ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {1 0 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {0 1 0 0} Relationship LEQ 1 ; podmienky add new LinearConstraint new double[] {3 0 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {2 0 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 2 -5 0} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {0 3 0 -5} Relationship LEQ 0 ; podmienky add new LinearConstraint new double[] {3 2 0 0} Relationship LEQ 5 ; podmienky add new LinearConstraint new double[] {2 3 0 0} Relationship LEQ 5 ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = 1 b = 0 5 value = 8 5 P S I used the latest software from the repository including MATH-286 fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max:  a  b; Constraints R:  a  c <= ; R:  a  d <= ; R:  b  c <= ; R:  b  d <= ; R:  a  b <= ; R:  a  b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a =  b =  value =  Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] {   }  ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; podmienky add new LinearConstraint new double[] {   } Relationship LEQ  ; SimplexSolver solver = new SimplexSolver  ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a =  b =   value =   P S I used the latest software from the repository including MATH fix  ,SimplexSolver didn t find the optimal solution Program for Lpsolve: ===================== Objective function max: a b; Constraints R: a c <= ; R: a d <= ; R: b c <= ; R: b d <= ; R: a b <= ; R: a b <= ; Variable bounds a <= ; b <= ; ===================== Results correct : a = b = value = Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction new double[] { } ; Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint> ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; podmienky add new LinearConstraint new double[] { } Relationship LEQ ; SimplexSolver solver = new SimplexSolver ; RealPointValuePair result = solver optimize kritFcia podmienky GoalType MAXIMIZE true ; ===================== Results incorrect : a = b = value = P S I used the latest software from the repository including MATH fix ,1
0,Closure,Break in finally block isn t optimized properly,None,None,None,1
0,Closure,Erroneous optimization in ADVANCED OPTIMIZATIONS mode,None,None,None,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,OAKfeadc,PropertyIndex cost calculation is faulty,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than 100 nodes  The high value it returns can be higher than the traversal index which has a max of 10M but can be less smaller For example: 100 nodes in the index: with a single level content cost is 6250000 adding a second level content data cost jumps to 1 544804416E9 101 nodes in the index: with a single level content cost is 100 adding a second level content data stays at 100 100 nodes 12 levels deep cost is 2 147483647E9 101 nodes 12 levels deep cost is 6 7108864E7,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than  nodes  The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example:  nodes in the index: with a single level content cost is  adding a second level content data cost jumps to  E  nodes in the index: with a single level content cost is  adding a second level content data stays at   nodes  levels deep cost is  E  nodes  levels deep cost is  E,The cost calculation can easily go out of bounds when it needs to estimate whenever there are more than nodes The high value it returns can be higher than the traversal index which has a max of M but can be less smaller For example: nodes in the index: with a single level content cost is adding a second level content data cost jumps to E nodes in the index: with a single level content cost is adding a second level content data stays at nodes levels deep cost is E nodes levels deep cost is E,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,MATHcb, RegulaFalsiSolver failure,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x  - Math pow Math PI 3 0 ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve 100 f 1 10 ; } {code} fails with {noformat} illegal state: maximal count 100  exceeded: evaluations {noformat} Using PegasusSolver the answer is found after 17 evaluations ,The following unit test: {code}  Test public void testBug   { final UnivariateRealFunction f = new UnivariateRealFunction   {  Override public double value double x  { return Math exp x   Math pow Math PI   ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver  ; double root = solver solve  f   ; } {code} fails with {noformat} illegal state: maximal count   exceeded: evaluations {noformat} Using PegasusSolver the answer is found after  evaluations ,The following unit test: {code} Test public void testBug { final UnivariateRealFunction f = new UnivariateRealFunction { Override public double value double x { return Math exp x Math pow Math PI ; } }; UnivariateRealSolver solver = new RegulaFalsiSolver ; double root = solver solve f ; } {code} fails with {noformat} illegal state: maximal count exceeded: evaluations {noformat} Using PegasusSolver the answer is found after evaluations ,1
0,Bears,ClassGeneratingPropertyAccessorFactory isTypeInjectable   fails with NPE for entities in default packages [DATACMNS-1201],opened and commented Introspecting ClassGeneratingPropertyAccessorFactory support for an entity fails with an NPE if the entity resides in the default package Affects: 1 13 8 Ingalls SR8  2 0 GA Kay  Referenced from: pull request  256 Backported to: 2 0 1 Kay SR1  1 13 9 Ingalls SR9 ,opened and commented Introspecting ClassGeneratingPropertyAccessorFactory support for an entity fails with an NPE if the entity resides in the default package Affects:    Ingalls SR    GA Kay  Referenced from: pull request   Backported to:    Kay SR     Ingalls SR ,opened and commented Introspecting ClassGeneratingPropertyAccessorFactory support for an entity fails with an NPE if the entity resides in the default package Affects: Ingalls SR GA Kay Referenced from: pull request Backported to: Kay SR Ingalls SR ,1
0,Bears,AnnotationRevisionMetadata throws ClassCastException [DATACMNS-1173],opened and commented AnnotationRevisionMetadata throws ClassCastException at line 90 : Most likely leftovers during migration to java util Optional Affects: 2 0 RC3 Kay ,opened and commented AnnotationRevisionMetadata throws ClassCastException at line  : Most likely leftovers during migration to java util Optional Affects:   RC Kay ,opened and commented AnnotationRevisionMetadata throws ClassCastException at line : Most likely leftovers during migration to java util Optional Affects: RC Kay ,1
0,Bears,ClassCastExecption,Hi I have started using a meitrack tc68s device however when I try and generate a summary trip report it returns the following error in console: The device is not in the future and has the correct timezone also I am using the official build Any recommendation All the other osram works fine ,Hi I have started using a meitrack tcs device however when I try and generate a summary trip report it returns the following error in console: The device is not in the future and has the correct timezone also I am using the official build Any recommendation All the other osram works fine ,Hi I have started using a meitrack tcs device however when I try and generate a summary trip report it returns the following error in console: The device is not in the future and has the correct timezone also I am using the official build Any recommendation All the other osram works fine ,1
0,Bears,address-controller: NPE when required parameters address plan or type  are not set,Description: When required parameter address plan or type  in address definition is not set then it cause NPE in address-controller https: github com EnMasseProject enmasse blob master address-model-lib src main java io enmasse address model v1 AddressV1Deserializer java L36 Steps to reproduce: create brokered address-space brokered-space create address without required parameter: brokered incorrect address json Automated test: we have no automated test for that yet output from address-controller log:,Description: When required parameter address plan or type  in address definition is not set then it cause NPE in addresscontroller https: github com EnMasseProject enmasse blob master addressmodellib src main java io enmasse address model v AddressVDeserializer java L Steps to reproduce: create brokered addressspace brokeredspace create address without required parameter: brokered incorrect address json Automated test: we have no automated test for that yet output from addresscontroller log:,Description: When required parameter address plan or type in address definition is not set then it cause NPE in addresscontroller https: github com EnMasseProject enmasse blob master addressmodellib src main java io enmasse address model v AddressVDeserializer java L Steps to reproduce: create brokered addressspace brokeredspace create address without required parameter: brokered incorrect address json Automated test: we have no automated test for that yet output from addresscontroller log:,1
0,Bears,Locale deserialize zh-hant CN ,zh-hant CN will convert to zh HANT cn Locale include language country variant  Locale toString   use to split then {language} {country} {variant}   |  {script}-{extensions} but Jackson deserialize Locale use - or : code: LocaleHandle readResolve   iana language-tags rfc4647 language lookup in jdk1 5 -> 1 8,zhhant CN will convert to zh HANT cn Locale include language country variant  Locale toString   use to split then {language} {country} {variant}   |  {script}{extensions} but Jackson deserialize Locale use  or : code: LocaleHandle readResolve   iana languagetags rfc language lookup in jdk  >  ,zhhant CN will convert to zh HANT cn Locale include language country variant Locale toString use to split then {language} {country} {variant} | {script}{extensions} but Jackson deserialize Locale use or : code: LocaleHandle readResolve iana languagetags rfc language lookup in jdk > ,1
0,Bears,rest api returns wrong address status { isReady :true phase : Pending },address-space: standard addresses: queue sharded-queue  topic sharded-topic  addresses deployed into address-space are ready to use simple send receive  but status phase is set to Pending reproducer create deploy get all addresses result: address space definition: standardSpace json addresses definition: standard qt json however in standard-controller log you can see that addresses are in phase Active: ConfigMap of myqueue contains phase Active as well I ll try to reproduce with brokered ,addressspace: standard addresses: queue shardedqueue  topic shardedtopic  addresses deployed into addressspace are ready to use simple send receive  but status phase is set to Pending reproducer create deploy get all addresses result: address space definition: standardSpace json addresses definition: standard qt json however in standardcontroller log you can see that addresses are in phase Active: ConfigMap of myqueue contains phase Active as well I ll try to reproduce with brokered ,addressspace: standard addresses: queue shardedqueue topic shardedtopic addresses deployed into addressspace are ready to use simple send receive but status phase is set to Pending reproducer create deploy get all addresses result: address space definition: standardSpace json addresses definition: standard qt json however in standardcontroller log you can see that addresses are in phase Active: ConfigMap of myqueue contains phase Active as well I ll try to reproduce with brokered ,1
0,Bears,How could I disable static imports in the v55 output ,I found v53 are producing static imports ,I found v are producing static imports ,I found v are producing static imports ,1
0,Bears,EntityInstantiators deallocate params required for instantiation of parent object [DATACMNS-1175],opened and commented Fetching nested document from MongoDB into Kotlin data class structure will sometimes result in NullPointerException This is caused by DefaultingKotlinClassInstantiatorAdapter createInstance   calling ClassGeneratingEntityInstantiator deallocateArguments   method cleaning up the shared params array Doing this while instantiating a child object will clean up all previously prepared arguments for parents constructor and thus causing NPEs on non-null parameters Note that everything was fine while using version of Spring Data bundled with Spring Boot 2 0 0 M3 Affects: 2 0 RC3 Kay  Referenced from: pull request  247 and commits ,opened and commented Fetching nested document from MongoDB into Kotlin data class structure will sometimes result in NullPointerException This is caused by DefaultingKotlinClassInstantiatorAdapter createInstance   calling ClassGeneratingEntityInstantiator deallocateArguments   method cleaning up the shared params array Doing this while instantiating a child object will clean up all previously prepared arguments for parents constructor and thus causing NPEs on nonnull parameters Note that everything was fine while using version of Spring Data bundled with Spring Boot    M Affects:   RC Kay  Referenced from: pull request   and commits ,opened and commented Fetching nested document from MongoDB into Kotlin data class structure will sometimes result in NullPointerException This is caused by DefaultingKotlinClassInstantiatorAdapter createInstance calling ClassGeneratingEntityInstantiator deallocateArguments method cleaning up the shared params array Doing this while instantiating a child object will clean up all previously prepared arguments for parents constructor and thus causing NPEs on nonnull parameters Note that everything was fine while using version of Spring Data bundled with Spring Boot M Affects: RC Kay Referenced from: pull request and commits ,1
0,Bears,Failing generic type resolution of generic types within nested generic fields [DATACMNS-1196],opened and commented It seems that the type resolution is not working properly when having nested object composition with generic type Example of model: constructors getters ommited And create instance of Outer with When we create an instance of Outer which has reference to instance of Generic whose generic type is MyEnum then if we save Outer instance using MongoTemplate it s persisted in db correctly converted to mongo s document { But when we try to read it from db it is mapped incorrectly back to Outer Field myList in instance of Inner contains a List which contains instances of String but field elem in instance of Inner is mapped correctly and it really contains an instance of MyEnum Seems that problem is in MongoConverter I m attaching a simple project which is able to reproduce problem described above In tests I m not actually storing an instance to mongo collection but rather using only MongoConverter to convert an instance to Document and than back to Outer I don t know if workaround for this cold be writing a custom Converter My workaround for this in real project  was to manually convert a Document to some domain specific instance but that is really annoying I know that mapping from mongo types back can be tricky and sometimes type information is lost but that is not case here For comparison I ve tried Jackson s ObjectMapper to do serialization of instance of Outer to JSON string and than de-serialize JSON on back to Outer and it seems that Jackson resolves generic types correctly Affects: 1 13 8 Ingalls SR8  2 0 GA Kay  Attachments: Backported to: 2 0 1 Kay SR1  1 13 9 Ingalls SR9 ,opened and commented It seems that the type resolution is not working properly when having nested object composition with generic type Example of model: constructors getters ommited And create instance of Outer with When we create an instance of Outer which has reference to instance of Generic whose generic type is MyEnum then if we save Outer instance using MongoTemplate it s persisted in db correctly converted to mongo s document { But when we try to read it from db it is mapped incorrectly back to Outer Field myList in instance of Inner contains a List which contains instances of String but field elem in instance of Inner is mapped correctly and it really contains an instance of MyEnum Seems that problem is in MongoConverter I m attaching a simple project which is able to reproduce problem described above In tests I m not actually storing an instance to mongo collection but rather using only MongoConverter to convert an instance to Document and than back to Outer I don t know if workaround for this cold be writing a custom Converter My workaround for this in real project  was to manually convert a Document to some domain specific instance but that is really annoying I know that mapping from mongo types back can be tricky and sometimes type information is lost but that is not case here For comparison I ve tried Jackson s ObjectMapper to do serialization of instance of Outer to JSON string and than deserialize JSON on back to Outer and it seems that Jackson resolves generic types correctly Affects:    Ingalls SR    GA Kay  Attachments: Backported to:    Kay SR     Ingalls SR ,opened and commented It seems that the type resolution is not working properly when having nested object composition with generic type Example of model: constructors getters ommited And create instance of Outer with When we create an instance of Outer which has reference to instance of Generic whose generic type is MyEnum then if we save Outer instance using MongoTemplate it s persisted in db correctly converted to mongo s document { But when we try to read it from db it is mapped incorrectly back to Outer Field myList in instance of Inner contains a List which contains instances of String but field elem in instance of Inner is mapped correctly and it really contains an instance of MyEnum Seems that problem is in MongoConverter I m attaching a simple project which is able to reproduce problem described above In tests I m not actually storing an instance to mongo collection but rather using only MongoConverter to convert an instance to Document and than back to Outer I don t know if workaround for this cold be writing a custom Converter My workaround for this in real project was to manually convert a Document to some domain specific instance but that is really annoying I know that mapping from mongo types back can be tricky and sometimes type information is lost but that is not case here For comparison I ve tried Jackson s ObjectMapper to do serialization of instance of Outer to JSON string and than deserialize JSON on back to Outer and it seems that Jackson resolves generic types correctly Affects: Ingalls SR GA Kay Attachments: Backported to: Kay SR Ingalls SR ,1
0,Bears,ParentNotInitializedException on CtComments,Hello When I build JavaFileTest from javapoet with comments enabled the build throw me the following error: snippet example: assertThat source ,Hello When I build JavaFileTest from javapoet with comments enabled the build throw me the following error: snippet example: assertThat source ,Hello When I build JavaFileTest from javapoet with comments enabled the build throw me the following error: snippet example: assertThat source ,1
0,Bears,CtTypeReferenceImpl getSuperClass   fails in noClasspath mode,The method has the following implementation: As you can see it doesn t check for noClasspath and thus may fail when calling getActualClass   ,The method has the following implementation: As you can see it doesn t check for noClasspath and thus may fail when calling getActualClass   ,The method has the following implementation: As you can see it doesn t check for noClasspath and thus may fail when calling getActualClass ,1
0,Bears,address-controller allows to create multiple addresses with the same spec address value,reproducible via following steps: create standard address space reproducible with brokered as well  deploy 3 addresses into this address space all addresses were created successfully console shows only one of those addresses next address appears once previous one is removed And only first of multiple addresses has isReady attribute set to true in configMap standard anycast json,reproducible via following steps: create standard address space reproducible with brokered as well  deploy  addresses into this address space all addresses were created successfully console shows only one of those addresses next address appears once previous one is removed And only first of multiple addresses has isReady attribute set to true in configMap standard anycast json,reproducible via following steps: create standard address space reproducible with brokered as well deploy addresses into this address space all addresses were created successfully console shows only one of those addresses next address appears once previous one is removed And only first of multiple addresses has isReady attribute set to true in configMap standard anycast json,1
0,Bears,Hibernate Subselect Entity not supported by EntityMetamodelImpl,Description After playing a bit with table functions see also  181   I had the idea to experiment with mapping a generate series query to an entity using the annotation Find below the produced stack trace A trivial work around is to wrap the query into to a view and map that instead I am uncertain whether a fix for this is worthwhile but it could perhaps be a step towards implementing table functions  181   Expected behavior Actual behavior Steps to reproduce Environment Version: 1 2 0 Alpha3 JPA-Provider: Hibernate 5 2 12 DBMS: PostgresSQL Application Server: Wildfly,Description After playing a bit with table functions see also     I had the idea to experiment with mapping a generate series query to an entity using the annotation Find below the produced stack trace A trivial work around is to wrap the query into to a view and map that instead I am uncertain whether a fix for this is worthwhile but it could perhaps be a step towards implementing table functions     Expected behavior Actual behavior Steps to reproduce Environment Version:    Alpha JPAProvider: Hibernate    DBMS: PostgresSQL Application Server: Wildfly,Description After playing a bit with table functions see also I had the idea to experiment with mapping a generate series query to an entity using the annotation Find below the produced stack trace A trivial work around is to wrap the query into to a view and map that instead I am uncertain whether a fix for this is worthwhile but it could perhaps be a step towards implementing table functions Expected behavior Actual behavior Steps to reproduce Environment Version: Alpha JPAProvider: Hibernate DBMS: PostgresSQL Application Server: Wildfly,1
0,Bears,Unable to set a compression input output decorator to a SmileFactory,I have a special need for the riak-java-client which only allows me to use an ObjectMapper to serialize deserialize key-values I would like to decorate a SmileFactory with compressors like LZ4 Snappy or GZip but at the moment this is not possible when I try a mapper like the following: This is the exception I get: I used Gzip as an example in reality I m using both LZ4 and Gzip and both throw exceptions when I try with a SmileFactory this works perfectly with a JsonFactory the reason for me to prefer a SmileFactory over a JsonFactory is because it is notice-able faster than the JsonFactory so basically it ll help compensate the price I pay for compression ,I have a special need for the riakjavaclient which only allows me to use an ObjectMapper to serialize deserialize keyvalues I would like to decorate a SmileFactory with compressors like LZ Snappy or GZip but at the moment this is not possible when I try a mapper like the following: This is the exception I get: I used Gzip as an example in reality I m using both LZ and Gzip and both throw exceptions when I try with a SmileFactory this works perfectly with a JsonFactory the reason for me to prefer a SmileFactory over a JsonFactory is because it is noticeable faster than the JsonFactory so basically it ll help compensate the price I pay for compression ,I have a special need for the riakjavaclient which only allows me to use an ObjectMapper to serialize deserialize keyvalues I would like to decorate a SmileFactory with compressors like LZ Snappy or GZip but at the moment this is not possible when I try a mapper like the following: This is the exception I get: I used Gzip as an example in reality I m using both LZ and Gzip and both throw exceptions when I try with a SmileFactory this works perfectly with a JsonFactory the reason for me to prefer a SmileFactory over a JsonFactory is because it is noticeable faster than the JsonFactory so basically it ll help compensate the price I pay for compression ,1
0,Bears,feat: add support for {java version} in pom xml,Hi I have an issue creating a MavenLauncher for projects that have {java version} in their POM xml Replacing it with 1 8 for example seems to work around Thank you for your help ,Hi I have an issue creating a MavenLauncher for projects that have {java version} in their POM xml Replacing it with   for example seems to work around Thank you for your help ,Hi I have an issue creating a MavenLauncher for projects that have {java version} in their POM xml Replacing it with for example seems to work around Thank you for your help ,1
0,Bears,ClassGeneratingPropertyAccessorFactory needs custom ClassLoader for defineClass   [DATACMNS-1422],opened and commented The ClassGeneratingPropertyAccessorFactory fails to generate classes in an OSGi environment where the ClassLoader for the model project the store implementation and Spring Data is different Here is the error we are facing: The problem seems to be that PropertyAccessorClassGenerator generateBytecode   adds the interface PersistentPropertyAccessor which lives in Spring Data In generateCustomAccessorClass   the ClassLoader of the model entity is used Therefore the ClassLoader of the custom model project needs access to all classes which are added by the factory especially the package org springframework data mapping   To resolve this problem a child ClassLoader of the entity should be used that is able to access both projects: Spring Data and the custom entity model Else this has to fail because different classes are mixed which cannot be accessed by a single ClassLoader Affects: 2 1 2 Lovelace SR2  Attachments: Referenced from: pull request  324 Backported to: 2 1 3 Lovelace SR3 ,opened and commented The ClassGeneratingPropertyAccessorFactory fails to generate classes in an OSGi environment where the ClassLoader for the model project the store implementation and Spring Data is different Here is the error we are facing: The problem seems to be that PropertyAccessorClassGenerator generateBytecode   adds the interface PersistentPropertyAccessor which lives in Spring Data In generateCustomAccessorClass   the ClassLoader of the model entity is used Therefore the ClassLoader of the custom model project needs access to all classes which are added by the factory especially the package org springframework data mapping   To resolve this problem a child ClassLoader of the entity should be used that is able to access both projects: Spring Data and the custom entity model Else this has to fail because different classes are mixed which cannot be accessed by a single ClassLoader Affects:    Lovelace SR  Attachments: Referenced from: pull request   Backported to:    Lovelace SR ,opened and commented The ClassGeneratingPropertyAccessorFactory fails to generate classes in an OSGi environment where the ClassLoader for the model project the store implementation and Spring Data is different Here is the error we are facing: The problem seems to be that PropertyAccessorClassGenerator generateBytecode adds the interface PersistentPropertyAccessor which lives in Spring Data In generateCustomAccessorClass the ClassLoader of the model entity is used Therefore the ClassLoader of the custom model project needs access to all classes which are added by the factory especially the package org springframework data mapping To resolve this problem a child ClassLoader of the entity should be used that is able to access both projects: Spring Data and the custom entity model Else this has to fail because different classes are mixed which cannot be accessed by a single ClassLoader Affects: Lovelace SR Attachments: Referenced from: pull request Backported to: Lovelace SR ,1
0,Bears,Calling blacklistLibOrExtJars without arguments causes an Exception,Calling blacklistLibOrExtJars   without arguments throws java lang IllegalArgumentException: Can only blacklist jars by leafname: System Library Java Extensions MRJToolkit jar while whitelistLibOrExtJars   without arguments works fine ,Calling blacklistLibOrExtJars   without arguments throws java lang IllegalArgumentException: Can only blacklist jars by leafname: System Library Java Extensions MRJToolkit jar while whitelistLibOrExtJars   without arguments works fine ,Calling blacklistLibOrExtJars without arguments throws java lang IllegalArgumentException: Can only blacklist jars by leafname: System Library Java Extensions MRJToolkit jar while whitelistLibOrExtJars without arguments works fine ,1
0,Bears,One-to-many with integer ids retrieval broken,How to Reproduce Upload: string-id xlsx Go to dataexplorer select Subjects table I don t like the order of the samples so I want to change the ID attribute datatype of the samples to int Upload: int-id xlsx Go to your table again Expected behavior My beautiful table nicely int sorted --> happy datamanager Observed behavior --> Sad datamanager,How to Reproduce Upload: stringid xlsx Go to dataexplorer select Subjects table I don t like the order of the samples so I want to change the ID attribute datatype of the samples to int Upload: intid xlsx Go to your table again Expected behavior My beautiful table nicely int sorted > happy datamanager Observed behavior > Sad datamanager,How to Reproduce Upload: stringid xlsx Go to dataexplorer select Subjects table I don t like the order of the samples so I want to change the ID attribute datatype of the samples to int Upload: intid xlsx Go to your table again Expected behavior My beautiful table nicely int sorted > happy datamanager Observed behavior > Sad datamanager,1
0,Bears,NPE for google cloud storage,Hi Any time I try to access Resource from the google storage it throws the following NPE It happens on both read and write Here is how the pom looks like Here is the code I even tried checking out the entire repo and just run the code as it is from spring-cloud-gcp-storage-resource-sample and class WebController by changing my bucket name and still get the same NPE I removed the entire m2 directory and started all over all and still the issue persists I double checked I have access to my bucket and even tried the same form my service account that have project admin access but the problem persists,Hi Any time I try to access Resource from the google storage it throws the following NPE It happens on both read and write Here is how the pom looks like Here is the code I even tried checking out the entire repo and just run the code as it is from springcloudgcpstorageresourcesample and class WebController by changing my bucket name and still get the same NPE I removed the entire m directory and started all over all and still the issue persists I double checked I have access to my bucket and even tried the same form my service account that have project admin access but the problem persists,Hi Any time I try to access Resource from the google storage it throws the following NPE It happens on both read and write Here is how the pom looks like Here is the code I even tried checking out the entire repo and just run the code as it is from springcloudgcpstorageresourcesample and class WebController by changing my bucket name and still get the same NPE I removed the entire m directory and started all over all and still the issue persists I double checked I have access to my bucket and even tried the same form my service account that have project admin access but the problem persists,1
0,Bears,FromStringDeserializer ignores registered DeserializationProblemHandler for java util UUID,Culprit appears to be lines 155-161 of FromStringDeserializer : The above lines appear to show that the exception will be thrown regardless of any problem handling logic Test Case: The handler handles the issue properly; but an exception is thrown anyway:,Culprit appears to be lines  of FromStringDeserializer : The above lines appear to show that the exception will be thrown regardless of any problem handling logic Test Case: The handler handles the issue properly; but an exception is thrown anyway:,Culprit appears to be lines of FromStringDeserializer : The above lines appear to show that the exception will be thrown regardless of any problem handling logic Test Case: The handler handles the issue properly; but an exception is thrown anyway:,1
0,Bears,Add support for handling primitive discrepancy problem with type refinements, note: derived from FasterXML jackson-module-jaxb-annotations 64   The problem is that although int and java lang Integer are related logically they are not related by inheritance or implementation  Since some legacy code may try refinements in this axis it d be nice to handle this somehow Two basic approaches would be: Just ignore primitive wrapper override return original type as is Allow wrapper to refine primitive return wrapper There is also related question of whether to allow int to long and similar refinements but start with basics , note: derived from FasterXML jacksonmodulejaxbannotations    The problem is that although int and java lang Integer are related logically they are not related by inheritance or implementation  Since some legacy code may try refinements in this axis it d be nice to handle this somehow Two basic approaches would be: Just ignore primitive wrapper override return original type as is Allow wrapper to refine primitive return wrapper There is also related question of whether to allow int to long and similar refinements but start with basics , note: derived from FasterXML jacksonmodulejaxbannotations The problem is that although int and java lang Integer are related logically they are not related by inheritance or implementation Since some legacy code may try refinements in this axis it d be nice to handle this somehow Two basic approaches would be: Just ignore primitive wrapper override return original type as is Allow wrapper to refine primitive return wrapper There is also related question of whether to allow int to long and similar refinements but start with basics ,1
0,Bears,Importing an entitytype with several columns with the same name import without errors,How to Reproduce Import a datasheet with multiple columns that have the same name Expected behavior An error telling me to only use the name of every attribute once per entitytype Observed behavior Everything imports fine and I have issues much later then one would expect ,How to Reproduce Import a datasheet with multiple columns that have the same name Expected behavior An error telling me to only use the name of every attribute once per entitytype Observed behavior Everything imports fine and I have issues much later then one would expect ,How to Reproduce Import a datasheet with multiple columns that have the same name Expected behavior An error telling me to only use the name of every attribute once per entitytype Observed behavior Everything imports fine and I have issues much later then one would expect ,1
0,Bears,Changes to SourcePosition in 5 5 0 ,Hello according to  1081 I don t find any mentions of changes to the SourcePosition In our use case we want to calculate the size of constructors and methods Which worked just fine in 5 4 Now with the 5 5 Snapshot I want to analyze a file which has a inner private class with no constructors Spoon generates a default private constructor with one statement -> super   The start line of this constructor is 1 and getPosition   getFile   returns null while the statements super   line is 383 and it has a file My method throws a NP as my method size calculation now is wrong and gets passed the threshold and I try to access the file of the generated private constructor I always can implement the case to ignore generated constructors but I just want to make sure this is intented or not ,Hello according to   I don t find any mentions of changes to the SourcePosition In our use case we want to calculate the size of constructors and methods Which worked just fine in   Now with the   Snapshot I want to analyze a file which has a inner private class with no constructors Spoon generates a default private constructor with one statement > super   The start line of this constructor is  and getPosition   getFile   returns null while the statements super   line is  and it has a file My method throws a NP as my method size calculation now is wrong and gets passed the threshold and I try to access the file of the generated private constructor I always can implement the case to ignore generated constructors but I just want to make sure this is intented or not ,Hello according to I don t find any mentions of changes to the SourcePosition In our use case we want to calculate the size of constructors and methods Which worked just fine in Now with the Snapshot I want to analyze a file which has a inner private class with no constructors Spoon generates a default private constructor with one statement > super The start line of this constructor is and getPosition getFile returns null while the statements super line is and it has a file My method throws a NP as my method size calculation now is wrong and gets passed the threshold and I try to access the file of the generated private constructor I always can implement the case to ignore generated constructors but I just want to make sure this is intented or not ,1
0,Bears,Enum key for Map ignores SerializationFeature WRITE ENUMS USING INDEX,Version: latest 2 8 Failing unit tests added here: https: github com SolaKun jackson-databind commit 6e095f75edd1de3eb33be5950c56d562bd6d584a Only java util Map test case provided but doesn t work with EnumMap as well ,Version: latest   Failing unit tests added here: https: github com SolaKun jacksondatabind commit efedddeebbecdbdda Only java util Map test case provided but doesn t work with EnumMap as well ,Version: latest Failing unit tests added here: https: github com SolaKun jacksondatabind commit efedddeebbecdbdda Only java util Map test case provided but doesn t work with EnumMap as well ,1
0,Bears, JsonEnumDefaultValue should take precedence over FAIL ON NUMBERS FOR ENUMS,Consider the following ObjectMapper definition: With this ObjectMapper when one attempts to deserialize an enum value V for an enum with an  JsonEnumDefaultValue element the deserialization will: Pass if Pass if Fail if To me this seems highly unintuitive I would have expected the READ UNKNOWN ENUM VALUES USING DEFAULT VALUE feature to take precedence over the FAIL ON NUMBERS FOR ENUMS feature in those cases where it applies i e when deserializing an enum with a default element  I ve put together a test class enumerating the relevant cases See the inline comments towards the bottom In four cases I feel that Jackson s current behavior is not as one might expect Would love to hear your thoughts on this If there is some other feature I should enable to get the behavior I m looking for let me know :   ,Consider the following ObjectMapper definition: With this ObjectMapper when one attempts to deserialize an enum value V for an enum with an  JsonEnumDefaultValue element the deserialization will: Pass if Pass if Fail if To me this seems highly unintuitive I would have expected the READ UNKNOWN ENUM VALUES USING DEFAULT VALUE feature to take precedence over the FAIL ON NUMBERS FOR ENUMS feature in those cases where it applies i e when deserializing an enum with a default element  I ve put together a test class enumerating the relevant cases See the inline comments towards the bottom In four cases I feel that Jackson s current behavior is not as one might expect Would love to hear your thoughts on this If there is some other feature I should enable to get the behavior I m looking for let me know :   ,Consider the following ObjectMapper definition: With this ObjectMapper when one attempts to deserialize an enum value V for an enum with an JsonEnumDefaultValue element the deserialization will: Pass if Pass if Fail if To me this seems highly unintuitive I would have expected the READ UNKNOWN ENUM VALUES USING DEFAULT VALUE feature to take precedence over the FAIL ON NUMBERS FOR ENUMS feature in those cases where it applies i e when deserializing an enum with a default element I ve put together a test class enumerating the relevant cases See the inline comments towards the bottom In four cases I feel that Jackson s current behavior is not as one might expect Would love to hear your thoughts on this If there is some other feature I should enable to get the behavior I m looking for let me know : ,1
0,Bears,Wrong serializer causing JsonMappingException,I m using spring-data-rest 3 0 0  which uses jackson-databind 2 9 0 pr2 I m not sure what have changed since not so long ago I had an functional application But now I m getting: Could not write JSON document: java lang Double cannot be cast to java lang Integer through reference chain: org springframework data rest webmvc json PersistentEntityJackson2Module PersistentEntityResourceSerializer 1[ content ]-> Contrato[ storageUtilizado ] ; nested exception is com fasterxml jackson databind JsonMappingException: java lang Double cannot be cast to java lang Integer through reference chain: org springframework data rest webmvc json PersistentEntityJackson2Module PersistentEntityResourceSerializer 1[ content ]-> Contrato[ storageUtilizado ]  I ve been stucked with this problem for a while and I m just assuming that there is something wrong when de Serializer for this specific field is defined I need at least some directions ,I m using springdatarest     which uses jacksondatabind    pr I m not sure what have changed since not so long ago I had an functional application But now I m getting: Could not write JSON document: java lang Double cannot be cast to java lang Integer through reference chain: org springframework data rest webmvc json PersistentEntityJacksonModule PersistentEntityResourceSerializer [ content ]> Contrato[ storageUtilizado ] ; nested exception is com fasterxml jackson databind JsonMappingException: java lang Double cannot be cast to java lang Integer through reference chain: org springframework data rest webmvc json PersistentEntityJacksonModule PersistentEntityResourceSerializer [ content ]> Contrato[ storageUtilizado ]  I ve been stucked with this problem for a while and I m just assuming that there is something wrong when de Serializer for this specific field is defined I need at least some directions ,I m using springdatarest which uses jacksondatabind pr I m not sure what have changed since not so long ago I had an functional application But now I m getting: Could not write JSON document: java lang Double cannot be cast to java lang Integer through reference chain: org springframework data rest webmvc json PersistentEntityJacksonModule PersistentEntityResourceSerializer [ content ]> Contrato[ storageUtilizado ] ; nested exception is com fasterxml jackson databind JsonMappingException: java lang Double cannot be cast to java lang Integer through reference chain: org springframework data rest webmvc json PersistentEntityJacksonModule PersistentEntityResourceSerializer [ content ]> Contrato[ storageUtilizado ] I ve been stucked with this problem for a while and I m just assuming that there is something wrong when de Serializer for this specific field is defined I need at least some directions ,1
0,Bears,Invalid generics resolution for locally declared wildcard and fully resolved target type [DATACMNS-1138],opened and commented Given the following context: An entity declares a field which type is a class with a wildcard type An implementation of the field s class is typed with a custom object A custom converter has been declared for the custom object We persist an entity with the custom class in Mongo Then when we retrieve the entity from the database the field with the custom type is not deserialized by the custom converter This problem does not happen if: We remove the wildcard from the declared field We use a type that does not require a custom converter e g Integer  I m not sure if this description is clear please take a look at the project on GitHub: https: github com mclem spring-data-mongodb-generics to reproduce the problem by running mvn test Affects: 1 12 11 Hopper SR11  1 13 6 Ingalls SR6  2 0 RC2 Kay  Reference URL: https: github com mclem spring-data-mongodb-generics Issue Links: Backported to: 1 13 7 Ingalls SR7  1 12 12 Hopper SR12 ,opened and commented Given the following context: An entity declares a field which type is a class with a wildcard type An implementation of the field s class is typed with a custom object A custom converter has been declared for the custom object We persist an entity with the custom class in Mongo Then when we retrieve the entity from the database the field with the custom type is not deserialized by the custom converter This problem does not happen if: We remove the wildcard from the declared field We use a type that does not require a custom converter e g Integer  I m not sure if this description is clear please take a look at the project on GitHub: https: github com mclem springdatamongodbgenerics to reproduce the problem by running mvn test Affects:    Hopper SR     Ingalls SR    RC Kay  Reference URL: https: github com mclem springdatamongodbgenerics Issue Links: Backported to:    Ingalls SR     Hopper SR ,opened and commented Given the following context: An entity declares a field which type is a class with a wildcard type An implementation of the field s class is typed with a custom object A custom converter has been declared for the custom object We persist an entity with the custom class in Mongo Then when we retrieve the entity from the database the field with the custom type is not deserialized by the custom converter This problem does not happen if: We remove the wildcard from the declared field We use a type that does not require a custom converter e g Integer I m not sure if this description is clear please take a look at the project on GitHub: https: github com mclem springdatamongodbgenerics to reproduce the problem by running mvn test Affects: Hopper SR Ingalls SR RC Kay Reference URL: https: github com mclem springdatamongodbgenerics Issue Links: Backported to: Ingalls SR Hopper SR ,1
0,Bears,MU-201 v3 xx doesnt work ,Hi i ve tried to install my tracker in Traccar but it doesn t work The Logfile was generated and everything is running but not the tracker HEX is translatet to: Port 5051 How can i add the device Kind regards Daniel,Hi i ve tried to install my tracker in Traccar but it doesn t work The Logfile was generated and everything is running but not the tracker HEX is translatet to: Port  How can i add the device Kind regards Daniel,Hi i ve tried to install my tracker in Traccar but it doesn t work The Logfile was generated and everything is running but not the tracker HEX is translatet to: Port How can i add the device Kind regards Daniel,1
0,Bears,CtFieldReference getDefaultExpression   returns initializer from a field of another class,Hi I m trying to collect and evaluate certain strings in the source repository I tried VisitorPartialEvaluator but it runs into an infinite loop The reason of this is that fields get mixed up The code setup is like this: Now if you try to read the return value of the getKey   method the CtFieldReference object will return the default value of ClassB PREFIX not BaseClass PREFIX ,Hi I m trying to collect and evaluate certain strings in the source repository I tried VisitorPartialEvaluator but it runs into an infinite loop The reason of this is that fields get mixed up The code setup is like this: Now if you try to read the return value of the getKey   method the CtFieldReference object will return the default value of ClassB PREFIX not BaseClass PREFIX ,Hi I m trying to collect and evaluate certain strings in the source repository I tried VisitorPartialEvaluator but it runs into an infinite loop The reason of this is that fields get mixed up The code setup is like this: Now if you try to read the return value of the getKey method the CtFieldReference object will return the default value of ClassB PREFIX not BaseClass PREFIX ,1
0,Bears,Converting to Vavr Option fails for present value [DATACMNS-1087],opened and commented Curently QueryExecutionConverters tries to invoke Vavr s Optional of like an instance method rather than static one This causes exception: Affects: 1 13 4 Ingalls SR4  Referenced from: commits ,opened and commented Curently QueryExecutionConverters tries to invoke Vavr s Optional of like an instance method rather than static one This causes exception: Affects:    Ingalls SR  Referenced from: commits ,opened and commented Curently QueryExecutionConverters tries to invoke Vavr s Optional of like an instance method rather than static one This causes exception: Affects: Ingalls SR Referenced from: commits ,1
0,Bears, JsonProperty access = Access READ ONLY  - unexpected behaviour,Hey I was hoping to make use of  JsonProperty access = Access READ ONLY  but failed Assume this class: I couldn t find a way to stop the deserializer from attempting to deserialize the field fullName The only thing that helps is to create a setter and annotate it with  JsonIgnore However that setter does not make sense and I don t want to have it Is this a bug in behaviour or am I missing something Thanks,Hey I was hoping to make use of  JsonProperty access = Access READ ONLY  but failed Assume this class: I couldn t find a way to stop the deserializer from attempting to deserialize the field fullName The only thing that helps is to create a setter and annotate it with  JsonIgnore However that setter does not make sense and I don t want to have it Is this a bug in behaviour or am I missing something Thanks,Hey I was hoping to make use of JsonProperty access = Access READ ONLY but failed Assume this class: I couldn t find a way to stop the deserializer from attempting to deserialize the field fullName The only thing that helps is to create a setter and annotate it with JsonIgnore However that setter does not make sense and I don t want to have it Is this a bug in behaviour or am I missing something Thanks,1
0,Bears,ParentNotInitializedException when processing comments with -c,I am aware that comments can be processed using the command -c since Spoon 5 2 0 Thanks for this feature When using Spoon to process comments in either code snippet below ParentNotInitializedException will be thrown An empty processor can be used to reproduce this issue This happens in both Spoon 5 2 and 5 4 public class Comment 1 { } public class Comment2 { } Details of the exception are as follows spoon reflect declaration ParentNotInitializedException: parent not initialized for class spoon support reflect code CtCommentImpl home jifeng workspace Temp4 src main java example Comment1 java:17  at spoon support reflect declaration CtElementImpl getParent CtElementImpl java:284  at spoon support compiler jdt JDTCommentBuilder insertCommentInAST JDTCommentBuilder java:377  at spoon support compiler jdt JDTCommentBuilder buildComment JDTCommentBuilder java:131  at spoon support compiler jdt JDTCommentBuilder build JDTCommentBuilder java:96  at spoon support compiler jdt JDTBasedSpoonCompiler buildSources JDTBasedSpoonCompiler java:387  at spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java:116  at spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java:99  at spoon Launcher buildModel Launcher java:712  at spoon Launcher run Launcher java:663  at spoon Launcher run Launcher java:106  at spoon Launcher main Launcher java:99 ,I am aware that comments can be processed using the command c since Spoon    Thanks for this feature When using Spoon to process comments in either code snippet below ParentNotInitializedException will be thrown An empty processor can be used to reproduce this issue This happens in both Spoon   and   public class Comment  { } public class Comment { } Details of the exception are as follows spoon reflect declaration ParentNotInitializedException: parent not initialized for class spoon support reflect code CtCommentImpl home jifeng workspace Temp src main java example Comment java:  at spoon support reflect declaration CtElementImpl getParent CtElementImpl java:  at spoon support compiler jdt JDTCommentBuilder insertCommentInAST JDTCommentBuilder java:  at spoon support compiler jdt JDTCommentBuilder buildComment JDTCommentBuilder java:  at spoon support compiler jdt JDTCommentBuilder build JDTCommentBuilder java:  at spoon support compiler jdt JDTBasedSpoonCompiler buildSources JDTBasedSpoonCompiler java:  at spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java:  at spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java:  at spoon Launcher buildModel Launcher java:  at spoon Launcher run Launcher java:  at spoon Launcher run Launcher java:  at spoon Launcher main Launcher java: ,I am aware that comments can be processed using the command c since Spoon Thanks for this feature When using Spoon to process comments in either code snippet below ParentNotInitializedException will be thrown An empty processor can be used to reproduce this issue This happens in both Spoon and public class Comment { } public class Comment { } Details of the exception are as follows spoon reflect declaration ParentNotInitializedException: parent not initialized for class spoon support reflect code CtCommentImpl home jifeng workspace Temp src main java example Comment java: at spoon support reflect declaration CtElementImpl getParent CtElementImpl java: at spoon support compiler jdt JDTCommentBuilder insertCommentInAST JDTCommentBuilder java: at spoon support compiler jdt JDTCommentBuilder buildComment JDTCommentBuilder java: at spoon support compiler jdt JDTCommentBuilder build JDTCommentBuilder java: at spoon support compiler jdt JDTBasedSpoonCompiler buildSources JDTBasedSpoonCompiler java: at spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java: at spoon support compiler jdt JDTBasedSpoonCompiler build JDTBasedSpoonCompiler java: at spoon Launcher buildModel Launcher java: at spoon Launcher run Launcher java: at spoon Launcher run Launcher java: at spoon Launcher main Launcher java: ,1
0,Bears,Extraneous type id mapping added for base type itself,Looks like type id name  matching base type is included in type resolution list automatically While this might be useful sometimes it seems quite odd and probably should only be included if: Base type is concrete and Base type has explicit name not add if default name used ,Looks like type id name  matching base type is included in type resolution list automatically While this might be useful sometimes it seems quite odd and probably should only be included if: Base type is concrete and Base type has explicit name not add if default name used ,Looks like type id name matching base type is included in type resolution list automatically While this might be useful sometimes it seems quite odd and probably should only be included if: Base type is concrete and Base type has explicit name not add if default name used ,1
0,Bears,Wrong constructor picked up when deserializing object,I discovered an issue with Jackson 2 7 8 and Jackson 2 8 4  when several constructors have parameters annotated with  JsonProperty but only one is annotated with  JsonCreator Here s a test case to reproduce it: This test throws an the following exception: After some debugging it looks like that BasicDeserializerFactory  addDeserializerConstructors   is looping over all the constructors and is not favoring an explicit constructor over a non-explicit one I actually don t know what should be the expected behavior: should jackson fail when two constructors are annotated or should jackson favor the one annotated with  JsonCreator Both options look reasonable to me and I m actually removing one of the constructors  ,I discovered an issue with Jackson    and Jackson     when several constructors have parameters annotated with  JsonProperty but only one is annotated with  JsonCreator Here s a test case to reproduce it: This test throws an the following exception: After some debugging it looks like that BasicDeserializerFactory  addDeserializerConstructors   is looping over all the constructors and is not favoring an explicit constructor over a nonexplicit one I actually don t know what should be the expected behavior: should jackson fail when two constructors are annotated or should jackson favor the one annotated with  JsonCreator Both options look reasonable to me and I m actually removing one of the constructors  ,I discovered an issue with Jackson and Jackson when several constructors have parameters annotated with JsonProperty but only one is annotated with JsonCreator Here s a test case to reproduce it: This test throws an the following exception: After some debugging it looks like that BasicDeserializerFactory addDeserializerConstructors is looping over all the constructors and is not favoring an explicit constructor over a nonexplicit one I actually don t know what should be the expected behavior: should jackson fail when two constructors are annotated or should jackson favor the one annotated with JsonCreator Both options look reasonable to me and I m actually removing one of the constructors ,1
0,Bears,DeserializationFeature UNWRAP SINGLE VALUE ARRAYS only works for POJOs Maps,Documentation of DeserializationFeature UNWRAP SINGLE VALUE ARRAYS only mentiones exceptional behavior for more than one value in the array If more than one value is found in the array a JsonMappingException is thrown   But trying to parse { value : [] } with value as String produces the following Stacktrace: Parsing as null might be expected instead  This shouldn t be problematic when using DeserializationFeature ACCEPT EMPTY ARRAY AS NULL OBJECT but it does not take precedence over DeserializationFeature UNWRAP SINGLE VALUE ARRAYS bug   and still gives me the error from above Are there any workarounds I still need to map single element arrays that sometimes appear to be empty I am using version 2 5 1 tested also 2 6 0: same behavior ,Documentation of DeserializationFeature UNWRAP SINGLE VALUE ARRAYS only mentiones exceptional behavior for more than one value in the array If more than one value is found in the array a JsonMappingException is thrown   But trying to parse { value : [] } with value as String produces the following Stacktrace: Parsing as null might be expected instead  This shouldn t be problematic when using DeserializationFeature ACCEPT EMPTY ARRAY AS NULL OBJECT but it does not take precedence over DeserializationFeature UNWRAP SINGLE VALUE ARRAYS bug   and still gives me the error from above Are there any workarounds I still need to map single element arrays that sometimes appear to be empty I am using version    tested also   : same behavior ,Documentation of DeserializationFeature UNWRAP SINGLE VALUE ARRAYS only mentiones exceptional behavior for more than one value in the array If more than one value is found in the array a JsonMappingException is thrown But trying to parse { value : [] } with value as String produces the following Stacktrace: Parsing as null might be expected instead This shouldn t be problematic when using DeserializationFeature ACCEPT EMPTY ARRAY AS NULL OBJECT but it does not take precedence over DeserializationFeature UNWRAP SINGLE VALUE ARRAYS bug and still gives me the error from above Are there any workarounds I still need to map single element arrays that sometimes appear to be empty I am using version tested also : same behavior ,1
0,Bears,Repository findOne method fails to return row for row level secured entity type if first row isn t readable,Code inspection FindOne shouldn t check if first row of delegate is readable but find first readable row ,Code inspection FindOne shouldn t check if first row of delegate is readable but find first readable row ,Code inspection FindOne shouldn t check if first row of delegate is readable but find first readable row ,1
0,Bears,MapSerializer orderEntries   throws NPE when operating on ConcurrentHashMap,It seems that the fix introduced for  1411 in 2 8 can be problematic for ConcurrentSkipListMap and possibly other map data structures  doc for ConcurrentSkipListMap doGet  ,It seems that the fix introduced for   in   can be problematic for ConcurrentSkipListMap and possibly other map data structures  doc for ConcurrentSkipListMap doGet  ,It seems that the fix introduced for in can be problematic for ConcurrentSkipListMap and possibly other map data structures doc for ConcurrentSkipListMap doGet ,1
0,Bears,NPE importing EMX with abtract entity type data,How to Reproduce Import this file Expected behavior Success or if I am not allowed to add data to abstract entities I expect a message Observed behavior Importer hangs server logs report a null pointer exception in the dataservice add   method ,How to Reproduce Import this file Expected behavior Success or if I am not allowed to add data to abstract entities I expect a message Observed behavior Importer hangs server logs report a null pointer exception in the dataservice add   method ,How to Reproduce Import this file Expected behavior Success or if I am not allowed to add data to abstract entities I expect a message Observed behavior Importer hangs server logs report a null pointer exception in the dataservice add method ,1
0,Bears,DateTimeSerializerBase ignores configured date format when creating contextual,DateTimeSerializerBase createContextual creates a new serializer with StdDateFormat DATE FORMAT STR ISO8601 format instead of re-using the actual format that may have been specified on the configuration See the following code: Using the  JsonFormat annotation on a field will therefore reset the format to Jackson s default even if the annotation doesn t specify any custom format DateBasedDeserializer createContextual behaves differently and tries to re-use the configured format: Shouldn t the serializer follow the same approach ,DateTimeSerializerBase createContextual creates a new serializer with StdDateFormat DATE FORMAT STR ISO format instead of reusing the actual format that may have been specified on the configuration See the following code: Using the  JsonFormat annotation on a field will therefore reset the format to Jackson s default even if the annotation doesn t specify any custom format DateBasedDeserializer createContextual behaves differently and tries to reuse the configured format: Shouldn t the serializer follow the same approach ,DateTimeSerializerBase createContextual creates a new serializer with StdDateFormat DATE FORMAT STR ISO format instead of reusing the actual format that may have been specified on the configuration See the following code: Using the JsonFormat annotation on a field will therefore reset the format to Jackson s default even if the annotation doesn t specify any custom format DateBasedDeserializer createContextual behaves differently and tries to reuse the configured format: Shouldn t the serializer follow the same approach ,1
0,Bears,ProxyingHandlerMethodArgumentResolver handles interfaces not intended for projection [DATACMNS-776],opened and commented A Spring Boot application that depends on spring-boot-starter-data-pa and uses Spring Mobile will create a proxy for Spring Mobile s Device interface when it s injected into a handler method Calling isMobile on this proxy fails as follows: The culprit is ProxyingHandlerMethodArgumentResolver which takes responsibility for any argument that s an interface I can work around the problem by ensuring that Spring Mobile s DeviceHandlerMethodArgumentResolver appears before ProxyingHandlerMethodArgumentResolver in Spring MVC s list of argument resolvers but I d prefer not to have to do so Can ProxyingHandlerMethodArgumentResolver be fixed so that it either doesn t claim responsibility for anything that s an interface or so that it returns a working proxy Affects: 1 10 2 Fowler SR2  1 11 GA Gosling  Issue Links: Backported to: 1 13 GA Ingalls  1 12 7 Hopper SR7  1 11 7 Gosling SR7  4 votes 8 watchers,opened and commented A Spring Boot application that depends on springbootstarterdatapa and uses Spring Mobile will create a proxy for Spring Mobile s Device interface when it s injected into a handler method Calling isMobile on this proxy fails as follows: The culprit is ProxyingHandlerMethodArgumentResolver which takes responsibility for any argument that s an interface I can work around the problem by ensuring that Spring Mobile s DeviceHandlerMethodArgumentResolver appears before ProxyingHandlerMethodArgumentResolver in Spring MVC s list of argument resolvers but I d prefer not to have to do so Can ProxyingHandlerMethodArgumentResolver be fixed so that it either doesn t claim responsibility for anything that s an interface or so that it returns a working proxy Affects:    Fowler SR    GA Gosling  Issue Links: Backported to:   GA Ingalls     Hopper SR     Gosling SR   votes  watchers,opened and commented A Spring Boot application that depends on springbootstarterdatapa and uses Spring Mobile will create a proxy for Spring Mobile s Device interface when it s injected into a handler method Calling isMobile on this proxy fails as follows: The culprit is ProxyingHandlerMethodArgumentResolver which takes responsibility for any argument that s an interface I can work around the problem by ensuring that Spring Mobile s DeviceHandlerMethodArgumentResolver appears before ProxyingHandlerMethodArgumentResolver in Spring MVC s list of argument resolvers but I d prefer not to have to do so Can ProxyingHandlerMethodArgumentResolver be fixed so that it either doesn t claim responsibility for anything that s an interface or so that it returns a working proxy Affects: Fowler SR GA Gosling Issue Links: Backported to: GA Ingalls Hopper SR Gosling SR votes watchers,1
0,Bears,bug in removeStatement,In this example if you want to remove the second i with block removeStatement block getStatement 3 ; Spoon removes the first one found by  martinezmatias thanks  ,In this example if you want to remove the second i with block removeStatement block getStatement  ; Spoon removes the first one found by  martinezmatias thanks  ,In this example if you want to remove the second i with block removeStatement block getStatement ; Spoon removes the first one found by martinezmatias thanks ,1
0,Bears,RepositoryBeanNameGenerator fails to resolve bean names for custom implementations detected via Spring s component index [DATACMNS-1115],opened and commented After upgrading to Spring Boot 2 0 0 M2 and Spring Data Kay M4 I cannot start my microservices any more which are accessing MongoDB A testcase is appended to produce the stacktrace below First I thought it is a Spring Boot issue spring-projects spring-boot 9780 Stacktrace: Affects: 2 0 M4 Kay  Attachments: Backported to: 1 13 5 Ingalls SR5  1 12 12 Hopper SR12 ,opened and commented After upgrading to Spring Boot    M and Spring Data Kay M I cannot start my microservices any more which are accessing MongoDB A testcase is appended to produce the stacktrace below First I thought it is a Spring Boot issue springprojects springboot  Stacktrace: Affects:   M Kay  Attachments: Backported to:    Ingalls SR     Hopper SR ,opened and commented After upgrading to Spring Boot M and Spring Data Kay M I cannot start my microservices any more which are accessing MongoDB A testcase is appended to produce the stacktrace below First I thought it is a Spring Boot issue springprojects springboot Stacktrace: Affects: M Kay Attachments: Backported to: Ingalls SR Hopper SR ,1
0,Bears,element toString   crashes with a NP in DefaultJavaPrettyPrinter visitCtTypeReference  ,When analyzing elasticsearch we get a NP when calling element toString   As this has something to do with type references I can t give you a concrete source file with this problem but rather a part of the project as tar archive elasticsearch tar gz  ,When analyzing elasticsearch we get a NP when calling element toString   As this has something to do with type references I can t give you a concrete source file with this problem but rather a part of the project as tar archive elasticsearch tar gz  ,When analyzing elasticsearch we get a NP when calling element toString As this has something to do with type references I can t give you a concrete source file with this problem but rather a part of the project as tar archive elasticsearch tar gz ,1
0,Bears,meitrack temp sensor with negative value,Hi Anton I m receiving a wrong value from temp sensor for negative temp values example: data for temp is 06FB2E which should translate to -12 34°C according to doc for protocol v3 Could you please check if traccar is reading temp correctly for negative values a sample data to test with: Regards ,Hi Anton I m receiving a wrong value from temp sensor for negative temp values example: data for temp is FBE which should translate to  °C according to doc for protocol v Could you please check if traccar is reading temp correctly for negative values a sample data to test with: Regards ,Hi Anton I m receiving a wrong value from temp sensor for negative temp values example: data for temp is FBE which should translate to °C according to doc for protocol v Could you please check if traccar is reading temp correctly for negative values a sample data to test with: Regards ,1
0,Bears,Jackson configuration is not used by ProjectingJackson2HttpMessageConverter [DATACMNS-1152],opened and commented ProjectingJackson2HttpMessageConverter is not using the default MappingJackson2HttpMessageConverter constructor to instantiate an ObjectMapper that uses Jackson2ObjectMapperBuilder to create a Jackson ObjectMapper based on application configuration  instead ObjectMapper is created directly in SpringDataWebConfiguration extendMessageConverters   That causes ProjectingJackson2HttpMessageConverter to not use Jackson configuration from application properties to create the ObjectMapper and there is no possibility to configure Jackson ObjectMapper That also breaks MappingJackson2HttpMessageConverter configuration functionality To solve that issue ObjectMapper creation should be delegated to MappingJackson2HttpMessageConverter default constructor Affects: 1 13 6 Ingalls SR6  2 0 RC2 Kay  Backported to: 1 13 7 Ingalls SR7 ,opened and commented ProjectingJacksonHttpMessageConverter is not using the default MappingJacksonHttpMessageConverter constructor to instantiate an ObjectMapper that uses JacksonObjectMapperBuilder to create a Jackson ObjectMapper based on application configuration  instead ObjectMapper is created directly in SpringDataWebConfiguration extendMessageConverters   That causes ProjectingJacksonHttpMessageConverter to not use Jackson configuration from application properties to create the ObjectMapper and there is no possibility to configure Jackson ObjectMapper That also breaks MappingJacksonHttpMessageConverter configuration functionality To solve that issue ObjectMapper creation should be delegated to MappingJacksonHttpMessageConverter default constructor Affects:    Ingalls SR    RC Kay  Backported to:    Ingalls SR ,opened and commented ProjectingJacksonHttpMessageConverter is not using the default MappingJacksonHttpMessageConverter constructor to instantiate an ObjectMapper that uses JacksonObjectMapperBuilder to create a Jackson ObjectMapper based on application configuration instead ObjectMapper is created directly in SpringDataWebConfiguration extendMessageConverters That causes ProjectingJacksonHttpMessageConverter to not use Jackson configuration from application properties to create the ObjectMapper and there is no possibility to configure Jackson ObjectMapper That also breaks MappingJacksonHttpMessageConverter configuration functionality To solve that issue ObjectMapper creation should be delegated to MappingJacksonHttpMessageConverter default constructor Affects: Ingalls SR RC Kay Backported to: Ingalls SR ,1
0,Bears,Repositories does not expose registered repository for proxy type [DATACMNS-1215],opened and commented Converting an entity to an ID using DomainClassConverter ToIdConverter fails if the entity instance is actually a proxy This is because DomainClassConverter ToIdConverter matches   only checks for a repository with the sourceType getType   In the case of a Hibernate proxy this type is EntityClass jvst     but the repository is registered with the key EntityClass For my application the inability to convert a proxy causes an exception in Thymeleaf template generation which prevents the page from loading completely It may not be possible to know when the persistence provider will return a proxy or a raw entity For example the JpaRepository getOne   method may return a proxy or may cause subsequent queries to return proxies It would be helpful if DomainClassConverter attempted at least one additional match by going one step up in the class hierarchy sort of like GenericConversionService Converters find   does it  because the entity class is the superclass of the proxy and this would prevent the failure Affects: 1 13 8 Ingalls SR8  Reference URL: https: stackoverflow com q 47318903 3179666 Backported to: 2 0 2 Kay SR2  1 13 9 Ingalls SR9 ,opened and commented Converting an entity to an ID using DomainClassConverter ToIdConverter fails if the entity instance is actually a proxy This is because DomainClassConverter ToIdConverter matches   only checks for a repository with the sourceType getType   In the case of a Hibernate proxy this type is EntityClass jvst     but the repository is registered with the key EntityClass For my application the inability to convert a proxy causes an exception in Thymeleaf template generation which prevents the page from loading completely It may not be possible to know when the persistence provider will return a proxy or a raw entity For example the JpaRepository getOne   method may return a proxy or may cause subsequent queries to return proxies It would be helpful if DomainClassConverter attempted at least one additional match by going one step up in the class hierarchy sort of like GenericConversionService Converters find   does it  because the entity class is the superclass of the proxy and this would prevent the failure Affects:    Ingalls SR  Reference URL: https: stackoverflow com q   Backported to:    Kay SR     Ingalls SR ,opened and commented Converting an entity to an ID using DomainClassConverter ToIdConverter fails if the entity instance is actually a proxy This is because DomainClassConverter ToIdConverter matches only checks for a repository with the sourceType getType In the case of a Hibernate proxy this type is EntityClass jvst but the repository is registered with the key EntityClass For my application the inability to convert a proxy causes an exception in Thymeleaf template generation which prevents the page from loading completely It may not be possible to know when the persistence provider will return a proxy or a raw entity For example the JpaRepository getOne method may return a proxy or may cause subsequent queries to return proxies It would be helpful if DomainClassConverter attempted at least one additional match by going one step up in the class hierarchy sort of like GenericConversionService Converters find does it because the entity class is the superclass of the proxy and this would prevent the failure Affects: Ingalls SR Reference URL: https: stackoverflow com q Backported to: Kay SR Ingalls SR ,1
0,Bears,Exception at compilation due to a constructor with private visibility,Hello I m having an issue while instrumenting the source code of AssertJ with Spoon The instrumentation part will work but the compilation part will fail due to the following error: I created a small Maven project with the part of the AssertJ source code that I cannot instrument compile with Spoon The project architecture is the following: According to the Exception message the problems comes from the class BooleanArraysBaseTest which contains the following code: The statement arrays = new BooleanArrays  ; refers to the BooleanArrays class contained in the same package internal   which is a Singleton having a constructor with the package visibility: The other class also called BooleanArrays but contained in the other package test   has a private constructor My Launcher configuration is the following: Is there something wrong with my configuration I managed to instrument several other projects but not this one Tell me if you need any other information An archive containing this project is available here Thank you Thibault,Hello I m having an issue while instrumenting the source code of AssertJ with Spoon The instrumentation part will work but the compilation part will fail due to the following error: I created a small Maven project with the part of the AssertJ source code that I cannot instrument compile with Spoon The project architecture is the following: According to the Exception message the problems comes from the class BooleanArraysBaseTest which contains the following code: The statement arrays = new BooleanArrays  ; refers to the BooleanArrays class contained in the same package internal   which is a Singleton having a constructor with the package visibility: The other class also called BooleanArrays but contained in the other package test   has a private constructor My Launcher configuration is the following: Is there something wrong with my configuration I managed to instrument several other projects but not this one Tell me if you need any other information An archive containing this project is available here Thank you Thibault,Hello I m having an issue while instrumenting the source code of AssertJ with Spoon The instrumentation part will work but the compilation part will fail due to the following error: I created a small Maven project with the part of the AssertJ source code that I cannot instrument compile with Spoon The project architecture is the following: According to the Exception message the problems comes from the class BooleanArraysBaseTest which contains the following code: The statement arrays = new BooleanArrays ; refers to the BooleanArrays class contained in the same package internal which is a Singleton having a constructor with the package visibility: The other class also called BooleanArrays but contained in the other package test has a private constructor My Launcher configuration is the following: Is there something wrong with my configuration I managed to instrument several other projects but not this one Tell me if you need any other information An archive containing this project is available here Thank you Thibault,1
0,Bears,Stop receiving records with error Last request was dispatched at but no response as of Cancelling subscription and restarting KCL 2 0 ,I have a Kinesis stream of 2 shards with data published to it continuously I use KCL 2 0 1 java to connect to the stream with polling by populating retrievalConfig retrievalSpecificConfig with a PollingConfig object  It works completely fine and keeps receiving messages from both shards for the first 10 minutes After that it stops receiving any message even there is data continuously published to the stream I leave the process running for 5 more minutes and issue persists After that I restart the process and it starts receiving messages again from both shards but stops receiving messages again after running for 10 minutes Issue happens repeatedly No throttling error is seen in logs Instead following errors are seen in logs: 2018-10-19 14:12:43 531 ERROR [main] shardId-000000000000: Last request was dispatched at 2018-10-19T03:12:07 772Z but no response as of 2018-10-19T03:12:43 531Z PT35 759S  Cancelling subscription and restarting This kind of logs appear once for every 35 seconds for each shard When it first appeared it happened to shardId-000000000000 and no more messages are received from this shard Then it appeared for shardId-000000000001 as well and no more message is received from this shard To isolate the publishing factor I ve done another test where I first published lots of data to the stream without consuming Then I stop publishing and start the consumer application Same behaviours are observed Same behaviours are observed with KCL 2 0 3 I ve extracted and attached the relevant application logs and error logs for reference app log error log Any idea ,I have a Kinesis stream of  shards with data published to it continuously I use KCL    java to connect to the stream with polling by populating retrievalConfig retrievalSpecificConfig with a PollingConfig object  It works completely fine and keeps receiving messages from both shards for the first  minutes After that it stops receiving any message even there is data continuously published to the stream I leave the process running for  more minutes and issue persists After that I restart the process and it starts receiving messages again from both shards but stops receiving messages again after running for  minutes Issue happens repeatedly No throttling error is seen in logs Instead following errors are seen in logs:  ::  ERROR [main] shardId: Last request was dispatched at T:: Z but no response as of T:: Z PT S  Cancelling subscription and restarting This kind of logs appear once for every  seconds for each shard When it first appeared it happened to shardId and no more messages are received from this shard Then it appeared for shardId as well and no more message is received from this shard To isolate the publishing factor I ve done another test where I first published lots of data to the stream without consuming Then I stop publishing and start the consumer application Same behaviours are observed Same behaviours are observed with KCL    I ve extracted and attached the relevant application logs and error logs for reference app log error log Any idea ,I have a Kinesis stream of shards with data published to it continuously I use KCL java to connect to the stream with polling by populating retrievalConfig retrievalSpecificConfig with a PollingConfig object It works completely fine and keeps receiving messages from both shards for the first minutes After that it stops receiving any message even there is data continuously published to the stream I leave the process running for more minutes and issue persists After that I restart the process and it starts receiving messages again from both shards but stops receiving messages again after running for minutes Issue happens repeatedly No throttling error is seen in logs Instead following errors are seen in logs: :: ERROR [main] shardId: Last request was dispatched at T:: Z but no response as of T:: Z PT S Cancelling subscription and restarting This kind of logs appear once for every seconds for each shard When it first appeared it happened to shardId and no more messages are received from this shard Then it appeared for shardId as well and no more message is received from this shard To isolate the publishing factor I ve done another test where I first published lots of data to the stream without consuming Then I stop publishing and start the consumer application Same behaviours are observed Same behaviours are observed with KCL I ve extracted and attached the relevant application logs and error logs for reference app log error log Any idea ,1
0,Bears,Blank map and no pointer when tracker is sending vibration alarm,Hello Im very happy with the traccar platform but got a strange issue I got about 40 trackers connected but 2 is missing map and pointers I noticed those 2 trackers is marked with ´vibration´ alarm and ignition OFF Is it a bug or am I doing something wrong trackers is running on h02 protocol Thanks,Hello Im very happy with the traccar platform but got a strange issue I got about  trackers connected but  is missing map and pointers I noticed those  trackers is marked with ´vibration´ alarm and ignition OFF Is it a bug or am I doing something wrong trackers is running on h protocol Thanks,Hello Im very happy with the traccar platform but got a strange issue I got about trackers connected but is missing map and pointers I noticed those trackers is marked with ´vibration´ alarm and ignition OFF Is it a bug or am I doing something wrong trackers is running on h protocol Thanks,1
0,Bears,Variable called java messes with the imports,Hello I m Spooning the JUnit4 source code and in the following class a variable has been named java : String java = System getProperty java home   File separator bin File separator java ; I configured my launcher with launcher getEnvironment   setAutoImports false ; after running the launcher the following code is generated: java lang String java = java lang System getProperty java home   java io File separator  bin   java io File separator  java ; Which is completely normal but the compilation will fail because java lang System refers to the java String declared earlier which has no lang attribute obviously  Since my previous issue I m running Spoon using launcher getEnvironment   setAutoImports false ; Since it is quite specific I m renaming the Java variable in the source code but it can be a bit time-consuming when there s multiple classes with a similar variable Thibault,Hello I m Spooning the JUnit source code and in the following class a variable has been named java : String java = System getProperty java home   File separator bin File separator java ; I configured my launcher with launcher getEnvironment   setAutoImports false ; after running the launcher the following code is generated: java lang String java = java lang System getProperty java home   java io File separator  bin   java io File separator  java ; Which is completely normal but the compilation will fail because java lang System refers to the java String declared earlier which has no lang attribute obviously  Since my previous issue I m running Spoon using launcher getEnvironment   setAutoImports false ; Since it is quite specific I m renaming the Java variable in the source code but it can be a bit timeconsuming when there s multiple classes with a similar variable Thibault,Hello I m Spooning the JUnit source code and in the following class a variable has been named java : String java = System getProperty java home File separator bin File separator java ; I configured my launcher with launcher getEnvironment setAutoImports false ; after running the launcher the following code is generated: java lang String java = java lang System getProperty java home java io File separator bin java io File separator java ; Which is completely normal but the compilation will fail because java lang System refers to the java String declared earlier which has no lang attribute obviously Since my previous issue I m running Spoon using launcher getEnvironment setAutoImports false ; Since it is quite specific I m renaming the Java variable in the source code but it can be a bit timeconsuming when there s multiple classes with a similar variable Thibault,1
0,Bears,When true setOneIndexedParameters still behaves as false in the links of the json response [DATACMNS-563],opened and commented When setting this to true the argument 1 accepted from the HTTP request is indeed considered to be the index of the first page but the json response still displays links as if the first page is indexed 0 For example requesting the page 3 gets the page 3 but the links are described ignoring the index start at 1 The prev link should show 2 and the next link should show 4 As it stands now the next page link has the same index as the current page in the request Affects: 1 8 2 Dijkstra SR2  Referenced from: pull request  267 Backported to: 2 0 3 Kay SR3  1 13 10 Ingalls SR10 ,opened and commented When setting this to true the argument  accepted from the HTTP request is indeed considered to be the index of the first page but the json response still displays links as if the first page is indexed  For example requesting the page  gets the page  but the links are described ignoring the index start at  The prev link should show  and the next link should show  As it stands now the next page link has the same index as the current page in the request Affects:    Dijkstra SR  Referenced from: pull request   Backported to:    Kay SR     Ingalls SR ,opened and commented When setting this to true the argument accepted from the HTTP request is indeed considered to be the index of the first page but the json response still displays links as if the first page is indexed For example requesting the page gets the page but the links are described ignoring the index start at The prev link should show and the next link should show As it stands now the next page link has the same index as the current page in the request Affects: Dijkstra SR Referenced from: pull request Backported to: Kay SR Ingalls SR ,1
0,Bears,cGuard protocol decoding issue,I ve got a pair of cGuard Atom devices one of the them is 2015 and another one - 2016 I m trying to install and configure the Traccar server inside Docker  to acquire data from the devices Traccar version: 3 10 cGuard Atom fw: 3 2 3 the latest available  The server successfully detects a new device 2017-04-09 03:06:43 WARN: Unknown device - 35338606530   and after a couple of minutes begins to decode gps-data However the navi data seem to be being decoded incorrectly All the testing time coordinates are zeroes the datetime mark correspond to Unix epoch time etc see below  The hex-decoder on the Trackar site correctly decodes HEX-parts of the data:,I ve got a pair of cGuard Atom devices one of the them is  and another one   I m trying to install and configure the Traccar server inside Docker  to acquire data from the devices Traccar version:   cGuard Atom fw:    the latest available  The server successfully detects a new device  :: WARN: Unknown device     and after a couple of minutes begins to decode gpsdata However the navi data seem to be being decoded incorrectly All the testing time coordinates are zeroes the datetime mark correspond to Unix epoch time etc see below  The hexdecoder on the Trackar site correctly decodes HEXparts of the data:,I ve got a pair of cGuard Atom devices one of the them is and another one I m trying to install and configure the Traccar server inside Docker to acquire data from the devices Traccar version: cGuard Atom fw: the latest available The server successfully detects a new device :: WARN: Unknown device and after a couple of minutes begins to decode gpsdata However the navi data seem to be being decoded incorrectly All the testing time coordinates are zeroes the datetime mark correspond to Unix epoch time etc see below The hexdecoder on the Trackar site correctly decodes HEXparts of the data:,1
0,Bears,AbstractPersistentProperty getRawType   does not consider generics [DATACMNS-1139],opened and commented AbstractPersistentProperty getRawType   currently uses the field s or property descriptor s type which in turn doesn t use our generics resolution mechanism which means for generic fields you ll get different results if you call   getTypeInformation   getType   and   getRawType   Affects: 1 12 11 Hopper SR11  1 13 6 Ingalls SR6  2 0 RC2 Kay  Backported to: 1 13 7 Ingalls SR7  1 12 12 Hopper SR12 ,opened and commented AbstractPersistentProperty getRawType   currently uses the field s or property descriptor s type which in turn doesn t use our generics resolution mechanism which means for generic fields you ll get different results if you call   getTypeInformation   getType   and   getRawType   Affects:    Hopper SR     Ingalls SR    RC Kay  Backported to:    Ingalls SR     Hopper SR ,opened and commented AbstractPersistentProperty getRawType currently uses the field s or property descriptor s type which in turn doesn t use our generics resolution mechanism which means for generic fields you ll get different results if you call getTypeInformation getType and getRawType Affects: Hopper SR Ingalls SR RC Kay Backported to: Ingalls SR Hopper SR ,1
0,Bears,should use provided pullRequestTitle when creating the PR,Summary Related to societe-generale ci-droid 6 : new pullRequestTitle field needs to be taken into account when creating the PR Type of Issue It is a : Motivation Current Behavior the PR is created but takes the commitMessage as title : now that a dedicated field pullRequestTitle  has been introduced in the model we should use it Expected Behavior use pullRequestTitle if provided - otherwise use the branch name as PR title Steps to Reproduce for bugs  Your Environment Version used: 1 0 5 OS and version: Version of libs used:,Summary Related to societegenerale cidroid  : new pullRequestTitle field needs to be taken into account when creating the PR Type of Issue It is a : Motivation Current Behavior the PR is created but takes the commitMessage as title : now that a dedicated field pullRequestTitle  has been introduced in the model we should use it Expected Behavior use pullRequestTitle if provided  otherwise use the branch name as PR title Steps to Reproduce for bugs  Your Environment Version used:    OS and version: Version of libs used:,Summary Related to societegenerale cidroid : new pullRequestTitle field needs to be taken into account when creating the PR Type of Issue It is a : Motivation Current Behavior the PR is created but takes the commitMessage as title : now that a dedicated field pullRequestTitle has been introduced in the model we should use it Expected Behavior use pullRequestTitle if provided otherwise use the branch name as PR title Steps to Reproduce for bugs Your Environment Version used: OS and version: Version of libs used:,1
0,Bears,YamlGenerator closes the target stream when configured not to,Bug description YamlGenerator closes the target stream when configured not to Versions used jackson-dataformat-yaml 2 9 2 jackson-databind 2 9 6 Expected result The target stream not closed when writing a value No output when running reproduction script program Actual result The target stream is closed when using the YamlGenerator with the following output when running the reproduction script program Steps to reproduce,Bug description YamlGenerator closes the target stream when configured not to Versions used jacksondataformatyaml    jacksondatabind    Expected result The target stream not closed when writing a value No output when running reproduction script program Actual result The target stream is closed when using the YamlGenerator with the following output when running the reproduction script program Steps to reproduce,Bug description YamlGenerator closes the target stream when configured not to Versions used jacksondataformatyaml jacksondatabind Expected result The target stream not closed when writing a value No output when running reproduction script program Actual result The target stream is closed when using the YamlGenerator with the following output when running the reproduction script program Steps to reproduce,1
0,Bears,Context must read system properties to rewrite properties from file ,Context must read system properties to rewrite properties from file ,Context must read system properties to rewrite properties from file ,Context must read system properties to rewrite properties from file ,1
0,Bears,ReactiveCommandSegmentCommandFactory resolves StreamingOutput for all reactive types,I m using Redis Lettuce dynamic client as described in official documentation https: github com lettuce-io lettuce-core wiki Redis-Command-Interfaces command-interfaces response-types My commands interface looks exactly the same The problem is when method get cannot find value by key there s exception thrown instead of returning empty Mono When using predefined RedisReactiveCommands get works fine it returns empty Mono So it seems like a bug to me The Redis Lettuce version being used is < Also checked with 5 0 4 RELEASE - issue remained,I m using Redis Lettuce dynamic client as described in official documentation https: github com lettuceio lettucecore wiki RedisCommandInterfaces commandinterfaces responsetypes My commands interface looks exactly the same The problem is when method get cannot find value by key there s exception thrown instead of returning empty Mono When using predefined RedisReactiveCommands get works fine it returns empty Mono So it seems like a bug to me The Redis Lettuce version being used is < Also checked with    RELEASE  issue remained,I m using Redis Lettuce dynamic client as described in official documentation https: github com lettuceio lettucecore wiki RedisCommandInterfaces commandinterfaces responsetypes My commands interface looks exactly the same The problem is when method get cannot find value by key there s exception thrown instead of returning empty Mono When using predefined RedisReactiveCommands get works fine it returns empty Mono So it seems like a bug to me The Redis Lettuce version being used is < Also checked with RELEASE issue remained,1
0,Bears,Large HTML File conversion to PDF hangs ,Hi I am trying to convert large HTML File approximately 600 pages which is not passing the conversion and hangs Following is my observation after debugging the core PdfRendererBuilder class file has following method call renderer layout  ; This action takes significant time but completes the process when I looked into it renderer createPDF   is trying to create entire PDF in memory document  and after completion it starts writing to OutputStream Can we write it directly to OutputStream page by page I think this might solve the problem Following is my code snippet please check the same if I am doing anything wrong here In above code snippet it is not completing builder run  ; process and hangs Please help me with the solution Thanks in advance ,Hi I am trying to convert large HTML File approximately  pages which is not passing the conversion and hangs Following is my observation after debugging the core PdfRendererBuilder class file has following method call renderer layout  ; This action takes significant time but completes the process when I looked into it renderer createPDF   is trying to create entire PDF in memory document  and after completion it starts writing to OutputStream Can we write it directly to OutputStream page by page I think this might solve the problem Following is my code snippet please check the same if I am doing anything wrong here In above code snippet it is not completing builder run  ; process and hangs Please help me with the solution Thanks in advance ,Hi I am trying to convert large HTML File approximately pages which is not passing the conversion and hangs Following is my observation after debugging the core PdfRendererBuilder class file has following method call renderer layout ; This action takes significant time but completes the process when I looked into it renderer createPDF is trying to create entire PDF in memory document and after completion it starts writing to OutputStream Can we write it directly to OutputStream page by page I think this might solve the problem Following is my code snippet please check the same if I am doing anything wrong here In above code snippet it is not completing builder run ; process and hangs Please help me with the solution Thanks in advance ,1
0,Bears,TracingP6SpyListener is not computing the Tags DB TYPE properly ,Type: bugfix In the TracingP6SpyListener class line 112 We should take into account that a url returned by a DatabaseMetaData can be null ,Type: bugfix In the TracingPSpyListener class line  We should take into account that a url returned by a DatabaseMetaData can be null ,Type: bugfix In the TracingPSpyListener class line We should take into account that a url returned by a DatabaseMetaData can be null ,1
0,Bears,CtElementImpl getMetadataKeys   throws NPE,I get NPE when invoking method getMetadataKeys   on CtElement Looking through source code it looks like metadata can be null It should have null check and return null like getMetadata   method or return empty set ,I get NPE when invoking method getMetadataKeys   on CtElement Looking through source code it looks like metadata can be null It should have null check and return null like getMetadata   method or return empty set ,I get NPE when invoking method getMetadataKeys on CtElement Looking through source code it looks like metadata can be null It should have null check and return null like getMetadata method or return empty set ,1
0,Bears,Processor is not using templated type when process method is in an abstract class,We define an abstract spoon Processor declaring a process method on a templated type: And create a concrete class extending the previous one: The problem is that both the concrete processors are receiving every classes that matches the upper bound of our template ,We define an abstract spoon Processor declaring a process method on a templated type: And create a concrete class extending the previous one: The problem is that both the concrete processors are receiving every classes that matches the upper bound of our template ,We define an abstract spoon Processor declaring a process method on a templated type: And create a concrete class extending the previous one: The problem is that both the concrete processors are receiving every classes that matches the upper bound of our template ,1
0,Bears,[generic type] Regression in being able to spoon Guava,It seems that  1218 introduced a regression on Guava project which is used by our CI to check the behaviour of Spoon see the trace : See full stack trace: https: ci inria fr sos job Guava 262 console,It seems that   introduced a regression on Guava project which is used by our CI to check the behaviour of Spoon see the trace : See full stack trace: https: ci inria fr sos job Guava  console,It seems that introduced a regression on Guava project which is used by our CI to check the behaviour of Spoon see the trace : See full stack trace: https: ci inria fr sos job Guava console,1
0,Bears,Persist fails on entity without id and version field if  EnableAuditing [DATACMNS-957],opened and commented Follow domain should be persist: It works as long as auditing is turned off After putting  EnableAuditing to application follows exception is thrown: Description: If auditing is enabled those steps are executed: Determine strategy to fill auditing fields Find fields that should be filled via auditing Fill found fields If strategy can t be determined because id and version is not available in domain  exception is thrown and object isn t persisted This exception is also thrown if you don t have any fields in model that are filled via auditing There is no need to throw this exception if no fields are filled via auditing Some code to make it clear: I ve patch for this ticket PR:  189 Issue Links: Referenced from: pull request  189 Backported to: 1 13 GA Ingalls  1 12 7 Hopper SR7  1 11 7 Gosling SR7 ,opened and commented Follow domain should be persist: It works as long as auditing is turned off After putting  EnableAuditing to application follows exception is thrown: Description: If auditing is enabled those steps are executed: Determine strategy to fill auditing fields Find fields that should be filled via auditing Fill found fields If strategy can t be determined because id and version is not available in domain  exception is thrown and object isn t persisted This exception is also thrown if you don t have any fields in model that are filled via auditing There is no need to throw this exception if no fields are filled via auditing Some code to make it clear: I ve patch for this ticket PR:   Issue Links: Referenced from: pull request   Backported to:   GA Ingalls     Hopper SR     Gosling SR ,opened and commented Follow domain should be persist: It works as long as auditing is turned off After putting EnableAuditing to application follows exception is thrown: Description: If auditing is enabled those steps are executed: Determine strategy to fill auditing fields Find fields that should be filled via auditing Fill found fields If strategy can t be determined because id and version is not available in domain exception is thrown and object isn t persisted This exception is also thrown if you don t have any fields in model that are filled via auditing There is no need to throw this exception if no fields are filled via auditing Some code to make it clear: I ve patch for this ticket PR: Issue Links: Referenced from: pull request Backported to: GA Ingalls Hopper SR Gosling SR ,1
0,Bears,Improve identifier metadata detection for XML based entity mappings [DATAJPA-658],opened and commented I have a model in POJO s and my persistence configuration in a separated project with an orm xml file I want to expose my persistence API and I have detected that entities are only configured when they are annotated with persistence annotations  Id for example  We cannot annotate our entities as they come from a target model which we don t have the source code It would be great that Spring Data REST were configurable using orm xml files or other xml source apart from annotations Thank you Affects: 1 7 1 Evans SR1  1 8 M1 Fowler  Issue Links: Referenced from: pull request  146 Backported to: 2 0 4 Kay SR4  1 11 11 Ingalls SR11  2 votes 6 watchers,opened and commented I have a model in POJO s and my persistence configuration in a separated project with an orm xml file I want to expose my persistence API and I have detected that entities are only configured when they are annotated with persistence annotations  Id for example  We cannot annotate our entities as they come from a target model which we don t have the source code It would be great that Spring Data REST were configurable using orm xml files or other xml source apart from annotations Thank you Affects:    Evans SR    M Fowler  Issue Links: Referenced from: pull request   Backported to:    Kay SR     Ingalls SR   votes  watchers,opened and commented I have a model in POJO s and my persistence configuration in a separated project with an orm xml file I want to expose my persistence API and I have detected that entities are only configured when they are annotated with persistence annotations Id for example We cannot annotate our entities as they come from a target model which we don t have the source code It would be great that Spring Data REST were configurable using orm xml files or other xml source apart from annotations Thank you Affects: Evans SR M Fowler Issue Links: Referenced from: pull request Backported to: Kay SR Ingalls SR votes watchers,1
0,Bears,A mapping service mapping error has its toString value inserted into an integrated dataset,How to Reproduce Go to the mapping service Create a new mapping project with Add TypeTestRef as new source Edit label attribute Fill in Create integrated dataset Expected behaviour Mapping fails because the validation for the label to label mapping contains script errors Observed behaviour The mapping is executed and the toString   value of the error is inserted as a label,How to Reproduce Go to the mapping service Create a new mapping project with Add TypeTestRef as new source Edit label attribute Fill in Create integrated dataset Expected behaviour Mapping fails because the validation for the label to label mapping contains script errors Observed behaviour The mapping is executed and the toString   value of the error is inserted as a label,How to Reproduce Go to the mapping service Create a new mapping project with Add TypeTestRef as new source Edit label attribute Fill in Create integrated dataset Expected behaviour Mapping fails because the validation for the label to label mapping contains script errors Observed behaviour The mapping is executed and the toString value of the error is inserted as a label,1
0,Bears,Infinite recursion when deserializing a class extending a Map with a recursive value type ,Hello I am using jackson-databind 2 8 8 and have a class with an unusual definition extending a Map where the values are of the type of the same class  It seems like I am facing an infinite recursion issue To reproduce you can re-use or inspire from the class defined here Then when executing the following code: When calling readValue   the mapper throws a StackOverflowException here s the stacktrace: Looking briefly into the code it seems like because of the recursive definition of the class the equals call in MapLikeType may never get out of this loop Any idea Thanks ,Hello I am using jacksondatabind    and have a class with an unusual definition extending a Map where the values are of the type of the same class  It seems like I am facing an infinite recursion issue To reproduce you can reuse or inspire from the class defined here Then when executing the following code: When calling readValue   the mapper throws a StackOverflowException here s the stacktrace: Looking briefly into the code it seems like because of the recursive definition of the class the equals call in MapLikeType may never get out of this loop Any idea Thanks ,Hello I am using jacksondatabind and have a class with an unusual definition extending a Map where the values are of the type of the same class It seems like I am facing an infinite recursion issue To reproduce you can reuse or inspire from the class defined here Then when executing the following code: When calling readValue the mapper throws a StackOverflowException here s the stacktrace: Looking briefly into the code it seems like because of the recursive definition of the class the equals call in MapLikeType may never get out of this loop Any idea Thanks ,1
0,Bears,StdDateFormat deserializes dates with no tz offset as UTC instead of configured timezone,Prior to version 2 8 9 dates without time zone or time offset eg 1970-01-01T00:00:00 000   were deserialised in the TimeZone set on the ObjectMapper Starting from 2 8 9 these dates are deserialised in UTC - which is a major breaking  change in behaviour Example:,Prior to version    dates without time zone or time offset eg T::    were deserialised in the TimeZone set on the ObjectMapper Starting from    these dates are deserialised in UTC  which is a major breaking  change in behaviour Example:,Prior to version dates without time zone or time offset eg T:: were deserialised in the TimeZone set on the ObjectMapper Starting from these dates are deserialised in UTC which is a major breaking change in behaviour Example:,1
0,Bears,ArrayIndexOutOfBoundsException on impossible non-static inner class constructor,Minimal repro: Fails like this: Validation is missing for this impossible constructor Works as expected when InnerSomething is static ,Minimal repro: Fails like this: Validation is missing for this impossible constructor Works as expected when InnerSomething is static ,Minimal repro: Fails like this: Validation is missing for this impossible constructor Works as expected when InnerSomething is static ,1
0,Bears, JsonIdentityReference not used when setup on class only,I am trying to setup  JsonIdentityInfo  JsonIdentityReference in order to serialize all references to a given class as Object Id and deserialize them later using a custom ObjectIdResolver to retrieve the proper referenced instance  I use  JsonIdentityReference alwaysAsId=true  in order to enforce exporting the object id in all cases It does not work as expected when I define the annotation only on the class but it works fine when I set it directly on the property  I would rather not have to define it on every property as I will probably miss some From what I see in BeanSerializerBase the alwaysAsId is reset when not ObjectIdInfo is found on the accessor: Shouldn t it be kept to the current value when no override is found I tried to set it back in the default ObjectIdInfo created with NAME FOR OBJECT REF but I am not sure if this is the right way to fix this Here is test I added in TestObjectIdSerialization for this case:,I am trying to setup  JsonIdentityInfo  JsonIdentityReference in order to serialize all references to a given class as Object Id and deserialize them later using a custom ObjectIdResolver to retrieve the proper referenced instance  I use  JsonIdentityReference alwaysAsId=true  in order to enforce exporting the object id in all cases It does not work as expected when I define the annotation only on the class but it works fine when I set it directly on the property  I would rather not have to define it on every property as I will probably miss some From what I see in BeanSerializerBase the alwaysAsId is reset when not ObjectIdInfo is found on the accessor: Shouldn t it be kept to the current value when no override is found I tried to set it back in the default ObjectIdInfo created with NAME FOR OBJECT REF but I am not sure if this is the right way to fix this Here is test I added in TestObjectIdSerialization for this case:,I am trying to setup JsonIdentityInfo JsonIdentityReference in order to serialize all references to a given class as Object Id and deserialize them later using a custom ObjectIdResolver to retrieve the proper referenced instance I use JsonIdentityReference alwaysAsId=true in order to enforce exporting the object id in all cases It does not work as expected when I define the annotation only on the class but it works fine when I set it directly on the property I would rather not have to define it on every property as I will probably miss some From what I see in BeanSerializerBase the alwaysAsId is reset when not ObjectIdInfo is found on the accessor: Shouldn t it be kept to the current value when no override is found I tried to set it back in the default ObjectIdInfo created with NAME FOR OBJECT REF but I am not sure if this is the right way to fix this Here is test I added in TestObjectIdSerialization for this case:,1
0,Bears,ACCEPT CASE INSENSITIVE PROPERTIES fails with  JsonUnwrapped, note: moved from FasterXML jackson-dataformat-csv 133   When trying to deserialize type like: with case-insensitive mapper mapper enable MapperFeature ACCEPT CASE INSENSITIVE PROPERTIES ;   I get exception:, note: moved from FasterXML jacksondataformatcsv    When trying to deserialize type like: with caseinsensitive mapper mapper enable MapperFeature ACCEPT CASE INSENSITIVE PROPERTIES ;   I get exception:, note: moved from FasterXML jacksondataformatcsv When trying to deserialize type like: with caseinsensitive mapper mapper enable MapperFeature ACCEPT CASE INSENSITIVE PROPERTIES ; I get exception:,1
0,Bears,Missing properties when deserializing using a builder class with a non-default constructor and a mutator annotated with  JsonUnwrapped,When deserializing using a builder class with a non-default constructor and any number of mutator methods annotated with  JsonUnwrapped the BuilderBasedDeserializer::deserializeUsingPropertyBasedWithUnwrapped method cuts short the process of adding SettableBeanProperties The logic dictates that once all properties necessary to construct the builder have been found the builder is constructed using all known SettableBeanProperties that have been found up to that point in the tokenizing process Therefore in the case that the builder has a single property required for construction and that property is found anywhere other than at the end of the JSON content any properties subsequent to the constructor property are not evaluated and are left with their default values Given the following classes: And given the following JSON string: { We will see the following output: However if we place the emp id property at the end of the JSON string we would get the following output: If we were to place emp age and emp first name and emp last name all after the emp id property in the JSON string we would get the following output:,When deserializing using a builder class with a nondefault constructor and any number of mutator methods annotated with  JsonUnwrapped the BuilderBasedDeserializer::deserializeUsingPropertyBasedWithUnwrapped method cuts short the process of adding SettableBeanProperties The logic dictates that once all properties necessary to construct the builder have been found the builder is constructed using all known SettableBeanProperties that have been found up to that point in the tokenizing process Therefore in the case that the builder has a single property required for construction and that property is found anywhere other than at the end of the JSON content any properties subsequent to the constructor property are not evaluated and are left with their default values Given the following classes: And given the following JSON string: { We will see the following output: However if we place the emp id property at the end of the JSON string we would get the following output: If we were to place emp age and emp first name and emp last name all after the emp id property in the JSON string we would get the following output:,When deserializing using a builder class with a nondefault constructor and any number of mutator methods annotated with JsonUnwrapped the BuilderBasedDeserializer::deserializeUsingPropertyBasedWithUnwrapped method cuts short the process of adding SettableBeanProperties The logic dictates that once all properties necessary to construct the builder have been found the builder is constructed using all known SettableBeanProperties that have been found up to that point in the tokenizing process Therefore in the case that the builder has a single property required for construction and that property is found anywhere other than at the end of the JSON content any properties subsequent to the constructor property are not evaluated and are left with their default values Given the following classes: And given the following JSON string: { We will see the following output: However if we place the emp id property at the end of the JSON string we would get the following output: If we were to place emp age and emp first name and emp last name all after the emp id property in the JSON string we would get the following output:,1
0,Bears,NullPointerException in ProjectingJackson2HttpMessageConverter [DATACMNS-972],opened and commented Managed to get a nullpointer after switching to spring-boot 1 5 0 RC1 from 1 4 3 RELEASE Nullpointer happens because the rawType is null when the type is generic type like T or D  With generic type the targetClass is initialised here correctly using ResolvableType forMethodParameter parameter  resolve  : spring The new ProjectingJackson2HttpMessageConverter converter is initialized as first converter here because spring-boot defines json-path depenency spring Stacktrace: Affects: 1 13 RC1 Ingalls  Reference URL: https: jira spring io browse DATACMNS-885 Attachments: Backported to: 1 13 GA Ingalls ,opened and commented Managed to get a nullpointer after switching to springboot    RC from    RELEASE Nullpointer happens because the rawType is null when the type is generic type like T or D  With generic type the targetClass is initialised here correctly using ResolvableType forMethodParameter parameter  resolve  : spring The new ProjectingJacksonHttpMessageConverter converter is initialized as first converter here because springboot defines jsonpath depenency spring Stacktrace: Affects:   RC Ingalls  Reference URL: https: jira spring io browse DATACMNS Attachments: Backported to:   GA Ingalls ,opened and commented Managed to get a nullpointer after switching to springboot RC from RELEASE Nullpointer happens because the rawType is null when the type is generic type like T or D With generic type the targetClass is initialised here correctly using ResolvableType forMethodParameter parameter resolve : spring The new ProjectingJacksonHttpMessageConverter converter is initialized as first converter here because springboot defines jsonpath depenency spring Stacktrace: Affects: RC Ingalls Reference URL: https: jira spring io browse DATACMNS Attachments: Backported to: GA Ingalls ,1
0,Bears,issue with isOverriding behavior when extending TypeParameters,If you consider the interface Iterable<E> which contain a method forEach Consumer< super E>  and if you create a class with a T extends String which implements Iterable<T> then you implement your own version of forEach : if you use ClassTypingContext isSameSignature   on the two forEach methods it will return false because they do not have the same type parameter I m really not sure if this is a bug or not: in the overriding method the type parameter is more defined so the signature is not exactly the same But then if we only use isSameSignature in getAllMethods see  1375   we will get both Iterable forEach and ArrayList forEach when using it on ArrayList WDYT Should we consider the signature are the same or should we consider that getAllMethods should indeed return the two different methods Edit: Actually I extended my test to check with isOverriding and it returns false which is obviously wrong So there s a real issue here ,If you consider the interface Iterable<E> which contain a method forEach Consumer< super E>  and if you create a class with a T extends String which implements Iterable<T> then you implement your own version of forEach : if you use ClassTypingContext isSameSignature   on the two forEach methods it will return false because they do not have the same type parameter I m really not sure if this is a bug or not: in the overriding method the type parameter is more defined so the signature is not exactly the same But then if we only use isSameSignature in getAllMethods see     we will get both Iterable forEach and ArrayList forEach when using it on ArrayList WDYT Should we consider the signature are the same or should we consider that getAllMethods should indeed return the two different methods Edit: Actually I extended my test to check with isOverriding and it returns false which is obviously wrong So there s a real issue here ,If you consider the interface Iterable<E> which contain a method forEach Consumer< super E> and if you create a class with a T extends String which implements Iterable<T> then you implement your own version of forEach : if you use ClassTypingContext isSameSignature on the two forEach methods it will return false because they do not have the same type parameter I m really not sure if this is a bug or not: in the overriding method the type parameter is more defined so the signature is not exactly the same But then if we only use isSameSignature in getAllMethods see we will get both Iterable forEach and ArrayList forEach when using it on ArrayList WDYT Should we consider the signature are the same or should we consider that getAllMethods should indeed return the two different methods Edit: Actually I extended my test to check with isOverriding and it returns false which is obviously wrong So there s a real issue here ,1
0,Bears,NPE on DefaultJavaPrettyPrinter printCtFieldAccess,More intel about bug reproduction can be found on the following issue: HabchiSarra SmellDetector 8 The full stack trace using spoon 5 9 0-SNAPSHOT below,More intel about bug reproduction can be found on the following issue: HabchiSarra SmellDetector  The full stack trace using spoon   SNAPSHOT below,More intel about bug reproduction can be found on the following issue: HabchiSarra SmellDetector The full stack trace using spoon SNAPSHOT below,1
0,Bears, JsonProperty access = READ ONLY  together with generated constructor lombok  causes JsonMappingException: Could not find creator property with name [ ],The following class fails to deserialise with a com fasterxml jackson databind JsonMappingException: Could not find creator property with name s in class LombokObject  : Whereas the following class - which is functionally identical but with constructors getters and setters in the code - can be deserialised: The exception is,The following class fails to deserialise with a com fasterxml jackson databind JsonMappingException: Could not find creator property with name s in class LombokObject  : Whereas the following class  which is functionally identical but with constructors getters and setters in the code  can be deserialised: The exception is,The following class fails to deserialise with a com fasterxml jackson databind JsonMappingException: Could not find creator property with name s in class LombokObject : Whereas the following class which is functionally identical but with constructors getters and setters in the code can be deserialised: The exception is,1
0,Bears,No Object Id found for an instance when using  ConstructorProperties,Hi We recently migrated from 2 4 6 to 2 8 1 and we encountered the issue We use lombok s  AllArgsConstructor which adds  ConstructorProperties to constructor We also used  JsonIdentityInfo on our POJO which lead to JsonMappingException: No Object Id found for an instance exception The following test code demonstrates the issue Stack trace Prior to the version 2 5 0 this was not an issue because the offending method com fasterxml jackson databind deser impl PropertyValueBuffer handleIdValue DeserializationContext Object    had a comment TODO: is this an error case and did nothing else ,Hi We recently migrated from    to    and we encountered the issue We use lombok s  AllArgsConstructor which adds  ConstructorProperties to constructor We also used  JsonIdentityInfo on our POJO which lead to JsonMappingException: No Object Id found for an instance exception The following test code demonstrates the issue Stack trace Prior to the version    this was not an issue because the offending method com fasterxml jackson databind deser impl PropertyValueBuffer handleIdValue DeserializationContext Object    had a comment TODO: is this an error case and did nothing else ,Hi We recently migrated from to and we encountered the issue We use lombok s AllArgsConstructor which adds ConstructorProperties to constructor We also used JsonIdentityInfo on our POJO which lead to JsonMappingException: No Object Id found for an instance exception The following test code demonstrates the issue Stack trace Prior to the version this was not an issue because the offending method com fasterxml jackson databind deser impl PropertyValueBuffer handleIdValue DeserializationContext Object had a comment TODO: is this an error case and did nothing else ,1
0,Bears,Jackson Deserializer security vulnerability via default typing CVE-2017-7525 ,I have send email to info fasterxml com,I have send email to info fasterxml com,I have send email to info fasterxml com,1
0,Bears,Missing properties from base class when recursive types are involved ,When a type hierarchy as follows is constructed and the base class type is constructed first by the TypeFactory then serializing the sub class fails due to missing properties from the base class Serializes sub as { sub :2} where { base :1 sub :2} is expected I ve created a minimal scenario of this bug here: https: github com slobo-showbie jackson-recursive-type-bug I ve experienced this bug in 2 7 8 2 8 8 and 2 8 8 1,When a type hierarchy as follows is constructed and the base class type is constructed first by the TypeFactory then serializing the sub class fails due to missing properties from the base class Serializes sub as { sub :} where { base : sub :} is expected I ve created a minimal scenario of this bug here: https: github com sloboshowbie jacksonrecursivetypebug I ve experienced this bug in       and    ,When a type hierarchy as follows is constructed and the base class type is constructed first by the TypeFactory then serializing the sub class fails due to missing properties from the base class Serializes sub as { sub :} where { base : sub :} is expected I ve created a minimal scenario of this bug here: https: github com sloboshowbie jacksonrecursivetypebug I ve experienced this bug in and ,1
0,Bears,When i use the parameters configured in the dubbo provider in the routing rules the rules can not be matched,如果将参数添加到dubbo provider中 例如  <dubbo:provider serialization= fastjson > 这样生成的url中会带有 default serialization=fastjson 这样的参数  如果路由规则设置为 => serialization=fastjson  是无法过滤出带有 default serialization=fastjson 的提供者的 ,如果将参数添加到dubbo provider中 例如  <dubbo:provider serialization= fastjson > 这样生成的url中会带有 default serialization=fastjson 这样的参数  如果路由规则设置为 => serialization=fastjson  是无法过滤出带有 default serialization=fastjson 的提供者的 ,如果将参数添加到dubbo provider中 例如 <dubbo:provider serialization= fastjson > 这样生成的url中会带有 default serialization=fastjson 这样的参数 如果路由规则设置为 => serialization=fastjson 是无法过滤出带有 default serialization=fastjson 的提供者的 ,1
0,Bears,When I upload data with one row data is not uploaded,How to Reproduce Upload with advanced importer add mode: eric de test model xlsx Upload csv in this zip: eu bbmri eric DE biobanks csv zip Expected behavior 1 row is added to the biobanks table Observed behavior Import succeeds 0 rows imported,How to Reproduce Upload with advanced importer add mode: eric de test model xlsx Upload csv in this zip: eu bbmri eric DE biobanks csv zip Expected behavior  row is added to the biobanks table Observed behavior Import succeeds  rows imported,How to Reproduce Upload with advanced importer add mode: eric de test model xlsx Upload csv in this zip: eu bbmri eric DE biobanks csv zip Expected behavior row is added to the biobanks table Observed behavior Import succeeds rows imported,1
0,Bears,NativeQuery with Pagination validation error at startup [DATAJPA-928],opened and commented According to Example 50 at Using  Query docs it s possible to use a native query with pagination using Pageable but in my case it s failing with a org springframework data jpa repository query InvalidJpaQueryMethodException NativeJpaQuery constructor is checking if the query has a Pageable parameter and if the queryString contains a  pageable or  sort sequence The query has Pageable parameter but it does not contain a  pageable string: If I provide a  pageable string at the end of the query validation passes but when the query executes it fails saying that it s expecting 3 parameters instead of 2 Funny thing is that when the server is starting if I set a breakpoint inside NativeJpaQuery and change containsPageableOrSortInQueryExpression from false to true manually validation passes just fine and the query executes well paginating Affects: 1 10 1 Hopper SR1  1 10 2 Hopper SR2  Reference URL: http: stackoverflow com questions 38349930 spring-data-and-native-query-with-pagination Issue Links: Referenced from: pull request  246 and commits Backported to: 2 0 4 Kay SR4  1 votes 12 watchers,opened and commented According to Example  at Using  Query docs it s possible to use a native query with pagination using Pageable but in my case it s failing with a org springframework data jpa repository query InvalidJpaQueryMethodException NativeJpaQuery constructor is checking if the query has a Pageable parameter and if the queryString contains a  pageable or  sort sequence The query has Pageable parameter but it does not contain a  pageable string: If I provide a  pageable string at the end of the query validation passes but when the query executes it fails saying that it s expecting  parameters instead of  Funny thing is that when the server is starting if I set a breakpoint inside NativeJpaQuery and change containsPageableOrSortInQueryExpression from false to true manually validation passes just fine and the query executes well paginating Affects:    Hopper SR     Hopper SR  Reference URL: http: stackoverflow com questions  springdataandnativequerywithpagination Issue Links: Referenced from: pull request   and commits Backported to:    Kay SR   votes  watchers,opened and commented According to Example at Using Query docs it s possible to use a native query with pagination using Pageable but in my case it s failing with a org springframework data jpa repository query InvalidJpaQueryMethodException NativeJpaQuery constructor is checking if the query has a Pageable parameter and if the queryString contains a pageable or sort sequence The query has Pageable parameter but it does not contain a pageable string: If I provide a pageable string at the end of the query validation passes but when the query executes it fails saying that it s expecting parameters instead of Funny thing is that when the server is starting if I set a breakpoint inside NativeJpaQuery and change containsPageableOrSortInQueryExpression from false to true manually validation passes just fine and the query executes well paginating Affects: Hopper SR Hopper SR Reference URL: http: stackoverflow com questions springdataandnativequerywithpagination Issue Links: Referenced from: pull request and commits Backported to: Kay SR votes watchers,1
0,Bears,StackOverflowError in Dynamic StdKeySerializer,There seem to be a problem checked and doesn t seem to be fixed in latest version  with the serialize method of the Dynamic static class of the StdKeySerializer The problem comes from the fact that when ser is null the new ser returned by findAndAddDynamic is incorrectly filled So say we are in ser 1 ser 1 dynamicSerializers now has the correct PropertySerializerMap Single However result serializer dynamicSerializers has PropertySerializerMap Empty Therefore a new call with that result ser 2 is made which ends up creating an infinite loop Possible fix: replace If I m mistaken please let me know but It seems obvious when debugging that something s is not working as intended,There seem to be a problem checked and doesn t seem to be fixed in latest version  with the serialize method of the Dynamic static class of the StdKeySerializer The problem comes from the fact that when ser is null the new ser returned by findAndAddDynamic is incorrectly filled So say we are in ser  ser  dynamicSerializers now has the correct PropertySerializerMap Single However result serializer dynamicSerializers has PropertySerializerMap Empty Therefore a new call with that result ser  is made which ends up creating an infinite loop Possible fix: replace If I m mistaken please let me know but It seems obvious when debugging that something s is not working as intended,There seem to be a problem checked and doesn t seem to be fixed in latest version with the serialize method of the Dynamic static class of the StdKeySerializer The problem comes from the fact that when ser is null the new ser returned by findAndAddDynamic is incorrectly filled So say we are in ser ser dynamicSerializers now has the correct PropertySerializerMap Single However result serializer dynamicSerializers has PropertySerializerMap Empty Therefore a new call with that result ser is made which ends up creating an infinite loop Possible fix: replace If I m mistaken please let me know but It seems obvious when debugging that something s is not working as intended,1
>>>>>>> 45fdc9b5e77fd91508f00a1412fc0e9b4c6aaadd
